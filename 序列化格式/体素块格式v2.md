
# 体素块格式v2

 警告

  
本文档是关于该格式的旧版本。您可以查看最新版本。

 版本： 2

  
本页介绍本模块中默认使用的二进制格式，用于将体素块序列化为文件、网络或数据库。

###   
与版本 1 相比的变化

  
总体而言，该格式可以比以前更加独立，因为必须预先知道信息。

-     
    使压缩容器更加独立，带有标头
-    添加了版本标头
-    添加了 3D 尺寸
-     
    添加了每个通道的深度信息

  
版本 1 中没有可用的迁移。

##  规范

###  压缩容器

  
块通常序列化为压缩数据。这是 `VoxelBlockSerializer` 实用程序类提供的格式。如果不使用压缩，则布局将对应于 `BlockData` 下一个列表中的描述，并且不会有此包装器。

  
压缩数据以一个字节开头。根据其值，接下来的内容会有所不同。

-     
    0：无压缩。以下字节可以直接读取为块格式。这很少使用，可用于调试。
-     
    1：LZ4压缩。下一个大端 32 位无符号整数是解压缩数据的大小，后续字节是使用 LZ4 默认参数的压缩数据。默认情况下使用此模式。

  
在以后解析块时，了解解压缩数据的大小可能很重要。

###  块格式

  
然后，获得的数据包含实际块。

  
它从一个字节中的版本号 `2` 开始，然后是一些元数据和实际的体素。

 注意

  
存在大小和格式以使格式独立。在分块容器（如区域文件）中使用时，建议检查它们是否与整个卷的预期格式匹配。

```
BlockData
- version: uint8_t
- size_x: uint16_t
- size_y: uint16_t
- size_z: uint16_t
- channels[8]
- metadata*
- epilogue
```

###  通道

  
块数据以 8 个通道一个接一个开始，每个通道具有以下结构：

```
Channel
- format: uint8_t (low nibble = compression, high nibble = depth)
- data
```

  
`format` 包含压缩和位深度，分别称为 `VoxelBuffer::Compression` 和 `VoxelBuffer::Depth` 枚举。低咬包含压缩，高咬包含深度。根据这些值， `data` 会有所不同。

  
深度可以是 0（8 位）、1（16 位）、2（32 位）或 3（64 位）。

  
如果压缩为 `COMPRESSION_NONE` （0）， `data` 则将是一个 N\*S 字节数组，其中 N 是块内的体素数乘以对应于位深度的字节数。例如，大小为 16x16x16 的块和 32 位深度的通道将具有 `16*16*16*4` 要从文件加载到此通道的字节。该数据的 3D 索引是有序 `ZXY` 的。

  
如果压缩为 `COMPRESSION_UNIFORM` （1），则数据将是单个体素值，这意味着块中的所有体素都具有相同的值。未使用的频道将始终使用此模式。该值跨越由深度定义的相同字节数。

  
其他压缩值无效。

###  元数据

  
在所有通道信息之后，块数据可以包含元数据信息。不包含任何内容的块在达到要读取的总数据大小之前，将只剩下固定数量的字节（来自结语）。如果有更多，则块包含元数据。

```
Metadata
- metadata_size: uint32_t
- block_metadata
- voxel_metadata[*]
```

  
它从一个 32 位无符号整数开头，表示要读取的所有元数据的总大小。该数据分为两组：一组用于整个块，另一组用于每个体素。

  
块元数据是一个戈多 `Variant` ，使用引擎 `encode_variant` 的方法编码。

  
体素元数据紧随其后。它是以下数据结构的序列，必须读取这些数据结构，直到从头开始读取总 `metadata_size` 字节数：

```
VoxelMetadata
- x: uint16_t
- y: uint16_t
- z: uint16_t
- data
```

  
`x` ， `y` 并 `z` 指示数据对应的体素。 `data` 也是以与前面描述相同的方式进行 `Variant` 编码。这将导致相对于块的体素位置与其相应的元数据之间的关联集合。

###  尾声

  
最后，块数据以 4 个字节的序列结束，一旦读入 `uint32_t` 整数，必须与值 `0x900df00d` 匹配。如果不满足该条件，则必须假定该块已损坏。

 注意

  
在小端架构（主要是桌面）上，二进制编辑器不会将尾声显示为 `0x900df00d` ，而是 `0x0df00d90` 显示为。

##  当前问题

  
尽管此格式当前已实现且可用，但它存在已知问题。

###  恩迪亚斯

  
Godot's `encode_variant` 似乎并不关心跨架构的字节序，因此将来可能会成为一个问题并更改为自定义格式。该规范的其余部分不受此影响，并假设我们使用小端序，但是深度大于 8 位的块通道的实现目前也没有考虑这一点。这可能会在以后的迭代中得到优化。

  
如果体素游戏需要在移动设备和桌面设备之间进行通信，这将变得非常重要。
