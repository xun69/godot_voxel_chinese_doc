# 体素块格式v3

 警告

  
本文档是关于该格式的旧版本。您可以查看最新版本。

 版本： 3

  
本页介绍本模块中默认使用的二进制格式，用于将体素块序列化为文件、网络或数据库。

###   
与版本 2 相比的变化

-     
    第二个通道（索引 1）用于 SDF 数据，但格式没有规定任何关于它的特殊内容。现在预计它将用于自卫队。它曾经具有定点编码的任意格式。它现在正在使用 inorm16。
-     
    压缩格式 `1` 已弃用。
-     
    已将压缩包装器移至其自己的规范。

##  规范

###  恩迪亚斯

  
默认情况下，小端序。

###  压缩容器

  
块通常在压缩数据容器中序列化。这是 `VoxelBlockSerializer` 实用程序类提供的格式。如果不使用压缩，则布局将对应于 `BlockData` 下一个列表中的描述，并且不会有此包装器。有关规范，请参阅压缩容器格式。

###  块格式

  
它从一个字节中的版本号 `3` 开始，然后是一些元数据和实际的体素。

 注意

  
存在大小和格式以使格式独立。在分块容器（如区域文件）中使用时，建议检查它们是否与整个卷的预期格式匹配。

```
BlockData
- version: uint8_t
- size_x: uint16_t
- size_y: uint16_t
- size_z: uint16_t
- channels[8]
- metadata*
- epilogue
```

###  通道

  
块数据以 8 个通道一个接一个开始，每个通道具有以下结构：

```
Channel
- format: uint8_t (low nibble = compression, high nibble = depth)
- data
```

  
`format` 包含压缩和位深度，分别称为 `VoxelBuffer::Compression` 和 `VoxelBuffer::Depth` 枚举。低咬包含压缩，高咬包含深度。根据这些值， `data` 会有所不同。

  
深度可以是 0（8 位）、1（16 位）、2（32 位）或 3（64 位）。

  
如果压缩为 `COMPRESSION_NONE` （0）， `data` 则将是一个 N\*S 字节数组，其中 N 是块内的体素数乘以对应于位深度的字节数。例如，大小为 16x16x16 的块和 32 位深度的通道将具有 `16*16*16*4` 要从文件加载到此通道的字节。该数据的 3D 索引是有序 `ZXY` 的。

  
如果压缩为 `COMPRESSION_UNIFORM` （1），则数据将是单个体素值，这意味着块中的所有体素都具有相同的值。未使用的频道将始终使用此模式。该值跨越由深度定义的相同字节数。

  
其他压缩值无效。

####  SDF 通道

  
第二个通道（索引 1 处）用于 SDF 数据。如果深度为 8 或 16 位，则可能包含编码为 `inorm8` 或 `inorm16` 的定点值。这是 \[-1..1\] 范围内的数字。

  
要从 `int8` 获取 ， `float` 请使用 `max(i / 127, -1.f)` 。 要从 `int16` 获取 ， `float` 请使用 `max(i / 32767, -1.f)` 。

  
对于 32 位深度，使用常规 `float` 。对于 64 位深度，使用常规 `double` 。

###  元数据

  
在所有通道信息之后，块数据可以包含元数据信息。不包含任何内容的块在达到要读取的总数据大小之前，将只剩下固定数量的字节（来自结语）。如果有更多，则块包含元数据。

```
Metadata
- metadata_size: uint32_t
- block_metadata
- voxel_metadata[*]
```

  
它从一个 32 位无符号整数开头，表示要读取的所有元数据的总大小。该数据分为两组：一组用于整个块，另一组用于每个体素。

  
块元数据是一个戈多 `Variant` ，使用引擎 `encode_variant` 的方法编码。

  
体素元数据紧随其后。它是以下数据结构的序列，必须读取这些数据结构，直到从头开始读取总 `metadata_size` 字节数：

```
VoxelMetadata
- x: uint16_t
- y: uint16_t
- z: uint16_t
- data
```

  
`x` ， `y` 并 `z` 指示数据对应的体素。 `data` 也是以与前面描述相同的方式进行 `Variant` 编码。这将导致相对于块的体素位置与其相应的元数据之间的关联集合。

###  尾声

  
最后，块数据以 4 个字节的序列结束，一旦读入 `uint32_t` 整数，必须与值 `0x900df00d` 匹配。如果不满足该条件，则必须假定该块已损坏。

 注意

  
在小端架构（如桌面）上，二进制编辑器不会将尾声显示为 `0x900df00d` ，而是 `0x0df00d90` 显示为。

##  当前问题

###  恩迪亚斯

  
该格式旨在使用小端序，但是引擎的实现并不能完全保证这一点。

  
Godot's `encode_variant` 似乎并不关心跨架构的字节序，因此将来可能会成为一个问题并更改为自定义格式。深度大于 8 位的块通道的实现目前也没有考虑这一点。这可能会在以后的迭代中得到优化。

  
如果体素游戏需要在移动设备和桌面设备之间进行通信，这将变得非常重要。
