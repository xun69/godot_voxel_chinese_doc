# 区域格式v3

 版本： 3

  
区域文件允许以适合频繁流式传输和部分编辑的格式保存大型固定大小的 3D 体素体积。这种格式的灵感来自仙女座种子和我的世界。它由 使用 `VoxelStreamRegionFiles` ，在此C++文件中实现

  
存在两个用例： - 独立区域：固定大小的体素体积 - 区域森林：将多个区域文件用于无限的体素世界，没有边界。这曾经是唯一用于案例区域文件。

 注意

  
本文档中的“区域”名称不指定标准，而是一种方法。这里描述的格式特定于Godot模块，可以称为 `Godot Voxel VXR` 需要全名。

##  迁移

  
使用此格式进行的较旧保存如果使用版本 2，则可以迁移这些保存。

###   
版本 3 中的更改

  
添加了有关块大小、体素格式和调色板的信息，以便独立区域文件包含加载和保存体素数据所需的所有信息。以前，用户必须事先知道此信息。迁移将插入额外的字节并偏移文件的其余部分，并将写入新的标头。

##  坐标空间

  
本文档使用 3 个不同的坐标空间。每个都可以通过使用乘数转换为另一个。

-     
    体素坐标：体素在空间中的实际位置
-     
    块坐标：具有定义大小 B 的体素块的位置。例如，常见的块大小为 16x16x16 体素。块坐标可以通过将其乘以 B 转换为体素坐标，从而给出该块内的原点体素。
-     
    区域坐标：具有定义大小 R 的块区域的位置。区域坐标可以通过将其乘以 R 转换为块坐标，从而得到该区域内的原点块。

  
2的幂可以用作乘数。

##  区域林

###  文件系统结构

  
区域林组织在多个区域文件中，并包含在包含它们的根目录中。区域文件不需要位于林内即可使用。在该目录下，位于两件事：

-    一个 `meta.vxrm` 文件
-    目录 `regions`

  
在区域目录下，每个详细级别 （LOD） 都必须有一个子目录。这些文件夹必须命名 `lodX` 为 ，其中 `X` 是 LOD 索引，从 开始 `0` 。

  
然后，详细级别文件夹包含该详细级别的区域文件。每个区域文件使用以下约定命名： `r.X.Y.Z.vxr` ，其中 X、Y 和 Z 是区域坐标空间中区域的坐标。

-   `world/`
    -   `meta.vxrm`
    -   `regions/`
        -   `lod0/`
            -   `r.0.0.0.vxr`
            -   `r.1.6.0.vxr`
            -   `r.32.-2.-6.vxr`
            -   ...
        -   `lod1/`
            -   ...
        -   `lod2/`
            -   ...
        -   ...

###  元文件

  
根目录下的元文件包含有关所有体素数据的全局信息。它当前正在使用 JSON，但可能无法手动编辑。

  
它必须包含以下字段：

-     
    `version` ：表示该格式版本的整数。一定是 `3` .可能会迁移旧版本。
-     
    `block_size_po2` ：体素中块的大小，作为 2 的整数幂（4 表示 16,5 表示 32 等）。块始终是立方体的。
-     
    `lod_count` ：LOD关卡有多少个。将有同样多的 LOD 文件夹。它必须大于 0。
-     
    `region_size_po2` ：以块为单位的区域大小，作为 2 的整数幂（4 表示 16,5 表示 32 等）。区域始终是立方体的。
-     
    `sector_size` ：区域文件中扇区的大小，作为严格正整数。有关详细信息，请参阅区域格式。
-     
    `channel_depths` ：8 个整数的数组，表示每个体素通道的位深度：
    -     `0` ： 8 位
    -     `1` ： 16 位
    -     `2` ： 32 位
    -     `3` ： 64 位
    -     
        有关详细信息，请参阅块格式。

##  区域文件

  
区域文件是二进制的，小端序。它们由序言、标题和扇区数据组成。

```
Prologue:
- "VXR_"
- version: uint8_t
Header:
- block_size_po2: uint8_t // cubic size of the block as a power of two. Must not be zero.
- region_size_x: uint8_t // How many blocks the region spans across X
- region_size_y: uint8_t // How many blocks the region spans across Y
- region_size_z: uint8_t // How many blocks the region spans across Z
- channel_depths: uint8_t[8] // Channel depths, same as described in region forest meta files
- sector_size: uint16_t
- palette_hint: uint8_t
- palette: uint32_t[256]
- blocks: uint32_t[region_size ^ 3]
SectorData:
- ...
```

###  序幕

  
它以四个 8 位字符开头： `VXR_` ，后跟一个字节，表示二进制形式的格式版本。版本必须是 `3` 。

  
标头以描述体积大小和体素格式的一些元数据开头。它不再具有固定大小。

  
可以选择提供调色板。如果设置为 `0xff` （ `255` ），则必须 `palette_hint` 后跟 256 个 8 位 RGBA 值。如果为 `0x00` （ `0` ），则 `palette_hint` 后面不会有调色板数据。其他值目前无效。

  
`blocks` 是 32 位整数序列，位于标头的末尾。每个整数表示有关块在文件中的位置及其序列化数据的大小的信息。该序列的计数是一个区域可以包含的块数，对于给定的区域大小保持不变。该序列中元素的索引是根据 3D 块位置按 ZXY 顺序计算的。块的索引可以使用公式 `y + block_size * (x + block_size * z)` 获得。每个整数包含两个信息： - 第一个字节是块跨越的扇区数。获得为 `n & 0xff` .- 其他 3 个字节是第一个扇区的索引。获得为 `n >> 8` .

  
因此，如果块未被占用，则其值为 `0` 。

###  扇区

  
文件的其余部分被扇区占用。扇区是固定大小的数据块。它们的大小由前面描述的标头确定，如果属于区域林，则在元文件中确定。块存储在这些扇区中。一个块可以跨越一个或多个扇区。以这种方式对文件进行分区，以允许频繁写入可变大小的块，而不必经常移动连续的内容。

  
当我们需要加载一个区块时，区块信息开始的地址如下：

```
header_size + first_sector_index * sector_size
```

  
一旦我们有了块的地址，这个地址的前 4 个字节将包含写入数据的大小。注意：确定占用扇区数时，这 4 个字节包含在总块大小中。

```
RegionBlockData
- buffer_size: uint32_t
- buffer
```

  
可以使用块格式读取获得的缓冲区。

##  块格式

 请参阅块格式

##  当前问题

  
尽管此格式当前已实现且可用，但它存在已知问题。

###  恩迪亚斯

  
Godot's `encode_variant` 似乎并不关心跨架构的字节序，因此将来可能会成为一个问题并更改为自定义格式。该规范的其余部分不受此影响，并假设我们使用小端序，但是块通道的实现目前也没有考虑这一点。这可能会在以后的迭代中得到优化。

###  版本控制

  
区域格式应被视为块格式实例的容器。前者有版本号，但后者没有，这很难管理。我们可能会引入单独的版本控制，这将导致较旧的存档变得不兼容。

  
用户版本控制也可以作为第三层添加：如果游戏需要用新的元数据替换一些元数据，或者由于游戏的变化而交换体素 ID，则需要公开一个钩子来迁移旧版本。
