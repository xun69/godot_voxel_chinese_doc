
# 区域格式v2

警告

  
本文档是关于该格式的旧版本。您可以查看最新版本。

 版本： 2

  
区域允许以适合所有方向频繁流式传输的格式保存大型 3D 体素体积。  
  
这种格式的灵感来自 https://www.seedofandromeda.com/blogs/1-creating-a-region-file-system-for-a-voxel-game  
  
它由 实现 `VoxelStreamRegionFiles` ，可以在 https://github.com/Zylann/godot\_voxel/blob/master/streams/voxel\_stream\_region\_files.cpp 中找到

##  坐标空间

  
此格式使用 3 个不同的坐标空间。每个都可以通过使用乘数转换为另一个。

-     
    体素坐标：体素在空间中的实际位置
-     
    块坐标：具有定义大小 B 的体素块的位置。例如，常见的块大小为 16x16x16 体素。块坐标可以通过将其乘以 B 转换为体素坐标，从而给出该块内的原点体素。
-     
    区域坐标：具有定义大小 R 的块区域的位置。区域坐标可以通过将其乘以 R 转换为块坐标，从而得到该区域内的原点块。

  
2的幂可以用作乘数。

##  文件结构

  
区域保存组织在多个文件中，并包含在包含这些文件的根目录中。在该目录下，位于两件事：

-    一个 `meta.vxrm` 文件
-    目录 `regions`

  
在区域目录下，每个详细级别 （LOD） 都必须有一个子目录。这些文件夹必须命名 `lodX` 为 ，其中 `X` 是 LOD 索引，从 开始 `0` 。

  
然后，详细级别文件夹包含该详细级别的区域文件。每个区域文件使用以下约定命名： `r.X.Y.Z.vxr` ，其中 X、Y 和 Z 是区域坐标空间中区域的坐标。

-   `world/`
    -   `meta.vxrm`
    -   `regions/`
        -   `lod0/`
            -   `r.0.0.0.vxr`
            -   `r.1.6.0.vxr`
            -   `r.32.-2.-6.vxr`
            -   ...
        -   `lod1/`
            -   ...
        -   `lod2/`
            -   ...
        -   ...

  
根目录下的元文件包含有关所有体素数据的全局信息。它当前正在使用 JSON，但可能无法手动编辑。

  
它必须包含以下字段：

-     
    `version` ：表示该格式版本的整数。一定是 `2` .可能会迁移旧版本。
-     
    `block_size_po2` ：体素中块的大小，作为 2 的整数幂（4 表示 16,5 表示 32 等）。块始终是立方体的。
-     
    `lod_count` ：LOD关卡有多少个。将有同样多的 LOD 文件夹。它必须大于 0。
-     
    `region_size_po2` ：以块为单位的区域大小，作为 2 的整数幂（4 表示 16,5 表示 32 等）。区域始终是立方体的。
-     
    `sector_size` ：区域文件中扇区的大小，作为严格正整数。有关详细信息，请参阅区域格式。
-     
    `channel_depths` ：8 个整数的数组，表示每个体素通道的位深度：
    -     `0` ： 8 位
    -     `1` ： 16 位
    -     `2` ： 32 位
    -     `3` ： 64 位
    -     
        有关详细信息，请参阅块格式。

##  区域文件

  
区域文件是二进制的，小端序。它们由序言、标题和扇区数据组成。

```
Prologue:
- "VXR_"
- version: uint8_t
Header:
- blocks: uint32_t[region_size ^ 3]
SectorData:
- ...
```

###  序幕

  
它以四个 8 位字符开头： `VXR_` ，后跟一个字节，表示二进制形式的格式版本。版本必须是 `2` 。版本 `1` 具有相同的数据布局，因此可以读取相同的数据布局。无法读取其他版本。

  
标头是 32 位整数序列。每个整数表示有关块在文件中的位置及其大小的信息。该序列的计数是一个区域可以包含的块数，并且在所有区域中都是相同的。该序列中元素的索引是根据 3D 块位置按 ZXY 顺序计算的。块的索引可以使用公式 `y + block_size * (x + block_size * z)` 获得。每个整数包含两个信息： - 第一个字节是块跨越的扇区数。获得为 `n & 0xff` .- 其他 3 个字节是第一个扇区的索引。获得为 `n >> 8` .

###  扇区

  
文件的其余部分被扇区占用。扇区是固定大小的数据块。它们的大小由前面描述的元文件确定。块存储在这些扇区中。一个块可以跨越一个或多个扇区。以这种方式对文件进行分区，以允许频繁写入可变大小的块，而不必经常移动连续的内容。

  
当我们需要加载一个区块时，区块信息开始的地址如下：

```
header_size + first_sector_index * sector_size
```

  
一旦我们有了块的地址，这个地址的前 4 个字节将包含写入数据的大小。

 注意

  
确定占用扇区数时，这 4 个字节包含在总块大小中。

```
RegionBlockData
- buffer_size: uint32_t
- buffer
```

  
可以使用块格式读取获得的缓冲区。

##  块格式

 请参阅块格式

##  当前问题

  
尽管此格式当前已实现且可用，但它存在已知问题。

###  恩迪亚斯

  
Godot's `encode_variant` 似乎并不关心跨架构的字节序，因此将来可能会成为一个问题并更改为自定义格式。该规范的其余部分不受此影响，并假设我们使用小端序，但是块通道的实现目前也没有考虑这一点。这可能会在以后的迭代中得到优化。

###  版本控制

  
区域格式应被视为块格式实例的容器。前者有版本号，但后者没有，这很难管理。我们可能会引入单独的版本控制，这将导致较旧的存档变得不兼容。

  
用户版本控制也可以作为第三层添加：如果游戏需要用新的元数据替换一些元数据，或者由于游戏的变化而交换体素 ID，则需要公开一个钩子来迁移旧版本。
