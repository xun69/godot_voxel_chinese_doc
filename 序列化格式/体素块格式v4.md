# 体素块格式v4

 版本： 4

  
本页介绍本模块中默认使用的二进制格式，用于将体素块序列化为文件、网络或数据库。

###   
与版本 3 相比的变化

-     
    元数据使用一种新的格式，不再需要依赖Godot引擎（仍然可以使用 `Variant` ，但内部有其他选项可用）。

##  规范

###  恩迪亚斯

  
默认情况下，小端序。

###  压缩容器

  
块通常在压缩数据容器中序列化。这是 `VoxelBlockSerializer` 实用程序类提供的格式。如果不使用压缩，则布局将对应于 `BlockData` 下一个列表中的描述，并且不会有此包装器。有关规范，请参阅压缩容器格式。

###  块格式

  
它从一个字节中的版本号 `4` 开始，然后是一些信息和实际的体素。（可选）后跟自定义元数据。

 注意

  
存在大小和格式以使格式独立。在分块容器（如区域文件）中使用时，建议检查它们是否与整个卷的预期格式匹配。

```
BlockData
- version: uint8_t
- size_x: uint16_t
- size_y: uint16_t
- size_z: uint16_t
- channels[8]
- metadata*
- epilogue
```

###  通道

  
块数据以 8 个通道一个接一个开始，每个通道具有以下结构：

```
Channel
- format: uint8_t (low nibble = compression, high nibble = depth)
- data
```

  
`format` 包含压缩和位深度，分别称为 `VoxelBuffer::Compression` 和 `VoxelBuffer::Depth` 枚举。低咬包含压缩，高咬包含深度。根据这些值， `data` 会有所不同。

  
深度可以是 0（8 位）、1（16 位）、2（32 位）或 3（64 位）。

  
如果压缩为 `COMPRESSION_NONE` （0）， `data` 则将是一个 N\*S 字节数组，其中 N 是块内的体素数乘以对应于位深度的字节数。例如，大小为 16x16x16 的块和 32 位深度的通道将具有 `16*16*16*4` 要从文件加载到此通道的字节。该数据的 3D 索引是有序 `ZXY` 的。

  
如果压缩为 `COMPRESSION_UNIFORM` （1），则数据将是单个体素值，这意味着块中的所有体素都具有相同的值。未使用的频道将始终使用此模式。该值跨越由深度定义的相同字节数。

  
其他压缩值无效。

####  SDF 通道

  
第二个通道（索引 1 处）用于 SDF 数据。如果深度为 8 或 16 位，则可能包含编码为 `inorm8` 或 `inorm16` 的定点值。这是 \[-1..1\] 范围内的数字。

  
要从 `int8` 获取 ， `float` 请使用 `max(i / 127, -1.f)` 。 要从 `int16` 获取 ， `float` 请使用 `max(i / 32767, -1.f)` 。

  
对于 32 位深度，使用常规 `float` 。对于 64 位深度，使用常规 `double` 。

###  元数据

  
在所有通道信息之后，块数据可以包含元数据信息。不包含任何内容的块在达到要读取的总数据大小之前，将只剩下固定数量的字节（来自结语）。如果有更多，则块包含元数据。

```
Metadata
- metadata_size: uint32_t
- block_metadata: MetadataItem
- voxel_metadata: VoxelMetadataItem[*]

VoxelMetadataItem
- x: uint16_t
- y: uint16_t
- z: uint16_t
- metadata: MetadataItem
```

  
它从一个 32 位无符号整数开头，表示要读取的所有元数据的总大小。该数据分为两组：一组用于整个块，另一组为每个体素关联一个的列表（并非所有体素都有元数据）。

  
每个元数据项使用以下格式：

```
MetadataItem
- type: uint8_t
- data
```

  
它以 `type` 标头开头，后跟数据，具体取决于该类型。

-     
    如果是，则 `type` 该项为空 `0` ，没有 `data` 要读取的内容。
-     
    如果是 ，则 `type` `1` 后跟 8 个字节 （ `uint64_t` ）。
-     
    如果是，则 `type` 后跟一个戈多引擎 `32` `Variant` ，使用该 `encode_variant` 函数进行编码。这仅在使用Godot引擎时可用。
-     
    如果大于 `32` ，则 `type` 以下数据是应用程序定义的。应用程序通常知道哪些数据对应于该类型，并定义如何序列化和反序列化它。

  
元数据的含义是应用程序定义的。使用不同元数据的两个游戏不应兼容。

###  尾声

  
最后，块数据以 4 个字节的序列结束，一旦读入 `uint32_t` 整数，必须与值 `0x900df00d` 匹配。如果不满足该条件，则必须假定该块已损坏。

 注意

  
在小端架构（如桌面）上，二进制编辑器不会将尾声显示为 `0x900df00d` ，而是 `0x0df00d90` 显示为。

##  当前问题

###  恩迪亚斯

  
该格式旨在使用小端序，但是引擎的实现并不能完全保证这一点。

  
Godot's `encode_variant` 似乎并不关心跨架构的字节序，因此将来可能会成为一个问题并更改为自定义格式。深度大于 8 位的块通道的实现目前也没有考虑这一点。这可能会在以后的迭代中得到优化。

  
如果体素游戏需要在移动设备和桌面设备之间进行通信，这将变得非常重要。
