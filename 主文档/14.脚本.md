---
created: 2023-09-26T22:29:22 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/scripting/
author: 
---

# Scripting脚本

> ## Excerpt
> This page shows some examples in how to use the scripting API.本页显示了如何使用脚本 API 的一些示例。

---
This page shows some examples in how to use the scripting API.  
本页显示了如何使用脚本 API 的一些示例。

## Editing the terrain 编辑地形

### Using [VoxelTool](https://voxel-tools.readthedocs.io/en/latest/api/VoxelTool/) 使用体素工具

`VoxelTool` is a simplified API to access and modify voxel data. It is possible to obtain one from any class storing voxels, using the `get_voxel_tool()` function. That function will return a `VoxelTool` tied to the volume you got it from.  
`VoxelTool` 是用于访问和修改体素数据的简化 API。可以使用该 `get_voxel_tool()` 函数从存储体素的任何类中获取一个。该函数将返回一个 `VoxelTool` 绑定到您从中获取它的卷。

See [VoxelTool](https://voxel-tools.readthedocs.io/en/latest/api/VoxelTool/) for available functions. Note, depending on which class you get it from, subclasses of `VoxelTool` may have more specialized functions.  
有关可用功能，请参阅体素工具。请注意，根据您从哪个类获取它，的 `VoxelTool` 子类可能具有更专业的函数。

It is possible to store a reference to `VoxelTool` in a member variable, in case you want to access voxels from the same volume many times. It is more efficient, because every call to `get_voxel_tool()` creates a new instance of it.  
可以在成员变量中存储对的引用，以防您想多次访问来自同一卷的 `VoxelTool` 体素。它更有效，因为每次调用都会 `get_voxel_tool()` 创建它的新实例。

Before you start modifying voxels, make sure you access the right channel.  
在开始修改体素之前，请确保您访问了正确的通道。

```
# If you use VoxelMesherBlocky
voxel_tool.channel = VoxelBuffer.CHANNEL_TYPE

```

```
# If you use VoxelMesherTransvoxel
voxel_tool.channel = VoxelBuffer.CHANNEL_SDF

```

```
# If you use VoxelMesherCubes
voxel_tool.channel = VoxelBuffer.CHANNEL_COLOR

```

### Boundary limitation 边界限制

When a terrain is streaming blocks in and out, it is not possible to edit past loaded borders. Either you will get an error, or nothing will happen. You can test if the area you want to access or edit is available by calling `VoxelTool.is_area_editable()`.  
当地形流入和流出块时，无法编辑过去加载的边界。要么你会收到错误，要么什么都不会发生。您可以通过调用 `VoxelTool.is_area_editable()` 来测试要访问或编辑的区域是否可用。

### LOD limitation 详细级别限制

Similarly to bounds limitation, when you use LOD with `VoxelLodTerrain`, it is not possible to access or edit voxels beyond the first LOD level. Past this level, voxel data is no longer available at full resolution.  
与边界限制类似，将 LOD 与 一起使用 `VoxelLodTerrain` 时，无法访问或编辑超出第一个 LOD 级别的体素。超过此级别后，体素数据不再以全分辨率提供。

### Editing performance 编辑性能

In general, editing voxels one by one is the slowest. It is ok for actually getting only a few, but if you plan to modify larger areas at once, you may prefer functions that do this in bulk, or copy/paste buffers.  
通常，逐个编辑体素是最慢的。实际上只获取几个是可以的，但是如果您计划一次修改更大的区域，您可能更喜欢批量执行此操作的函数，或者复制/粘贴缓冲区。

See [Access to voxels and multithreading](https://voxel-tools.readthedocs.io/en/latest/performance/)  
请参阅访问体素和多线程

## Custom generator 自定义生成器

You can provide your own voxel generator by extending `VoxelGeneratorScript` in either GDScript, C# or C++.  
您可以通过在 GDScript、C# 或 C++ 中扩展 `VoxelGeneratorScript` 来提供自己的体素生成器。

Note 注意

custom generators can also be created without scripts, using [VoxelGeneratorGraph](https://voxel-tools.readthedocs.io/en/latest/generators/)  
自定义生成器也可以在没有脚本的情况下使用VoxelGeneratorGraph

### Example 示例

Here is how to make a bare bones generator usable with a blocky terrain. Make sure you use `VoxelMesherBlocky` as mesher.  
以下是使裸骨发电机可用于块状地形的方法。确保用作 `VoxelMesherBlocky` 网格器。

Create a standalone script `my_generator.gd` with the following contents:  
创建包含以下内容的独立脚本 `my_generator.gd` ：

```
extends VoxelGeneratorScript

const channel : int = VoxelBuffer.CHANNEL_TYPE

func _get_used_channels_mask() -> int:
    return 1 << channel

func _generate_block(buffer : VoxelBuffer, origin : Vector3i, lod : int) -> void:
    if lod != 0:
        return
    if origin.y < 0:
        buffer.fill(1, channel)
    if origin.x == origin.z and origin.y < 1:
        buffer.fill(1, channel)

```

In your terrain scene, add another script to a node, which will setup your generator when the game starts. Code might differ a bit depending on how you structure your scene.  
在地形场景中，向节点添加另一个脚本，该脚本将在游戏开始时设置生成器。代码可能会有所不同，具体取决于您构建场景的方式。

```
const MyGenerator = preload("my_generator.gd")

# Get the terrain
var terrain = $VoxelTerrain

func _ready():
    terrain.generator = MyGenerator.new()

```

Make sure to have a `VoxelViewer` node in the scene under the camera, and you should see this:  
确保场景中的摄像机下方有一个 `VoxelViewer` 节点，您应该看到以下内容：

![Custom stream](https://voxel-tools.readthedocs.io/en/latest/images/custom-stream.jpg)

Though `VoxelBuffer.fill()` is probably not what you want to use, the above is a quick example. Generate\_block generally gives you a block of 16x16x16 cubes to fill all at once, so you may also use `VoxelBuffer.set_voxel()` to specify each one individually. You can change the channel to `VoxelBuffer.CHANNEL_SDF` to get smooth voxels using another mesher such as `VoxelMesherTransvoxel`.  
虽然可能不是您想要使用的，但 `VoxelBuffer.fill()` 上面是一个快速示例。Generate\_block通常会为您提供一个由 16x16x16 个立方体组成的块，以便一次填充所有立方体，因此您也可以使用 `VoxelBuffer.set_voxel()` 单独指定每个立方体。您可以将通道更改为 ， `VoxelBuffer.CHANNEL_SDF` 以使用其他网格器（如 `VoxelMesherTransvoxel` ）获得平滑体素。

### Thread-safety 线程安全

Generators are invoked from multiple threads. Make sure your code is thread-safe.  
生成器是从多个线程调用的。确保代码是线程安全的。

If your generator uses resources or exports parameters that you want to change while it might be running, you should make sure they are read-only or copied per thread, so if the resource is modified from outside or another thread it won't disrupt the generator.  
如果生成器使用资源或导出要在运行时更改的参数，则应确保它们是只读的或按线程复制的，因此，如果从外部或其他线程修改资源，则不会中断生成器。

You can use `Mutex` to enforce single-thread access to variables, but use it with caution because otherwise you could end up limiting performance to one thread (while the other waits for the lock to be released). Using Read-Write locks and thread-locals are good options, unfortunately the Godot script API does not provide this.  
您可以使用 强制 `Mutex` 单线程访问变量，但要谨慎使用它，否则最终可能会将性能限制在一个线程上（而另一个线程等待锁被释放）。使用读写锁和线程局部是不错的选择，不幸的是，Godot脚本API不提供这一点。

Careful about lazy-initialization, it can cause crashes if two threads run it at the same time. `Curve` is one of the resources doing that: if you call `interpolate_baked()` and it wasn't baked yet, it will be baked at the very last moment. Here is an example of working around this:  
小心延迟初始化，如果两个线程同时运行它，可能会导致崩溃。 `Curve` 是这样做的资源之一：如果你打电话 `interpolate_baked()` 并且它还没有烘烤，它将在最后一刻烘烤。下面是解决此问题的示例：

```
extends VoxelGeneratorScript

const MountainsCurve : Curve = preload("moutains_curve.tres")

# This is called when the generator is created
func _init():
    # Call `bake()` to be sure it doesn't happen later inside `generate_block()`.
    MountainsCurve.bake()

# ...

```

A similar story occurs with `Image`. It needs to be locked before you can access pixels, but calling `lock()` and `unlock()` itself is not thread-safe. One approach to solve this is to `lock()` the image in `_init()` and leave it locked for the whole lifetime of the generator. This assumes of course that the image is never accessed from outside:  
类似的故事也发生在 `Image` 中。它需要先锁定，然后才能访问像素，但调用 `lock()` 和 `unlock()` 本身不是线程安全的。解决此问题的一种方法是将 `lock()` 图像放入 `_init()` 并在生成器的整个生命周期内将其锁定。当然，这假设图像永远不会从外部访问：

```
extends VoxelGeneratorScript

var image : Image

# This is called when the generator is created
func _init():
    image = Image.new()
    image.load("some_heightmap.png")
    image.lock()

func generate_block(buffer : VoxelBuffer, origin : Vector3i, lod : int) -> void:
    # ... use image.get_pixel() freely ...
    # ... but DO NOT use image.set_pixel() ...

func _notification(what: int):
    if what == NOTIFICATION_PREDELETE:
        # Called when the script is destroyed.
        # I don't know if it's really required, but unlock for correctness.
        image.unlock()

# ...

```

Image.lock() won't be required anymore in Godot 4.  
在Godot 4中不再需要Image.lock（）。

## Custom stream 自定义流

Making a custom stream works similarly to a custom generator.  
创建自定义流的工作方式与自定义生成器类似。

You have to extend the class `VoxelStreamScript` and override the methods `_load_block` and `_save_block`. See  
您必须扩展类 `VoxelStreamScript` 并覆盖方法 `_load_block` 和 `_save_block` .看

TODO Script example of a custom stream  
自定义流的待办事项脚本示例
