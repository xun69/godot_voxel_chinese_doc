<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>基于VoxelInstancer的实例化</title>
	<link rel="stylesheet" href="../index.css">
	<!-- 引入语法高亮 -->
	<link href="../highlight/dark.min.css" rel="stylesheet">
	<script src="../highlight/highlight.min.js"></script>
	<!-- 引入JQuery -->
	<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
	<script>
		$(function(){
			// 根据正文内容创建目录
			let content = "";
			$(".main h1,.main h2,.main h3").each(function(index,ele){
				$(this).before(`<a name ="ctn_${index}"></li>`)
				switch(ele.tagName){
					case "H1":
						content += `<li class="h1"><a href="#ctn_${index}">${ele.textContent}</a></li>`;
						break;
					case "H2":
						content += `<li class="h2"><a href="#ctn_${index}">${ele.textContent}</a></li>`;
						break;
					case "H3":
						content += `<li class="h3"><a href="#ctn_${index}">${ele.textContent.split("(")[0]}</a></li>`;
						break;
				}
			})
			$(".right ul").append(content);
			// 侧边栏子文件夹点击事件
			$(".doc_tree li>span").on("click",function(){
				$(this).next("ul").toggle();
			})
		})
	</script>
</head>
<body>
<!-- 左侧 -->
	<aside class="left">
		<div class="logo_box">
			<a href="#" class="logo_text">Godot Voxel</a>
			<span>中文文档</span>
		</div>
		<!-- 文档列表 -->
		<div class="doc_tree">
<ul>
	<li><a href="../README.html">README</a></li>
<li><span>API</span>
	<ul>
		<li><a href="../API/API文档.html">API文档</a></li>
		<li><a href="../API/FastNoise2.html">FastNoise2</a></li>
		<li><a href="../API/VoxelBlockSerializer.html">VoxelBlockSerializer</a></li>
		<li><a href="../API/VoxelBlockyAttribute.html">VoxelBlockyAttribute</a></li>
		<li><a href="../API/VoxelBlockyAttributeAxis.html">VoxelBlockyAttributeAxis</a></li>
		<li><a href="../API/VoxelBlockyAttributeCustom.html">VoxelBlockyAttributeCustom</a></li>
		<li><a href="../API/VoxelBlockyAttributeDirection.html">VoxelBlockyAttributeDirection</a></li>
		<li><a href="../API/VoxelBlockyAttributeRotation.html">VoxelBlockyAttributeRotation</a></li>
		<li><a href="../API/VoxelBlockyLibrary.html">VoxelBlockyLibrary</a></li>
		<li><a href="../API/VoxelBlockyLibraryBase.html">VoxelBlockyLibraryBase</a></li>
		<li><a href="../API/VoxelBlockyModel.html">VoxelBlockyModel</a></li>
		<li><a href="../API/VoxelBlockyModelCube.html">VoxelBlockyModelCube</a></li>
		<li><a href="../API/VoxelBlockyModelEmpty.html">VoxelBlockyModelEmpty</a></li>
		<li><a href="../API/VoxelBlockyModelMesh.html">VoxelBlockyModelMesh</a></li>
		<li><a href="../API/VoxelBlockyType.html">VoxelBlockyType</a></li>
		<li><a href="../API/VoxelBlockyTypeLibrary.html">VoxelBlockyTypeLibrary</a></li>
		<li><a href="../API/VoxelBoxMover.html">VoxelBoxMover</a></li>
		<li><a href="../API/VoxelBuffer.html">VoxelBuffer</a></li>
		<li><a href="../API/VoxelColorPalette.html">VoxelColorPalette</a></li>
		<li><a href="../API/VoxelDataBlockEnterInfo.html">VoxelDataBlockEnterInfo</a></li>
		<li><a href="../API/VoxelEngine.html">VoxelEngine</a></li>
		<li><a href="../API/VoxelGenerator.html">VoxelGenerator</a></li>
		<li><a href="../API/VoxelGeneratorFlat.html">VoxelGeneratorFlat</a></li>
		<li><a href="../API/VoxelGeneratorGraph.html">VoxelGeneratorGraph</a></li>
		<li><a href="../API/VoxelGeneratorHeightmap.html">VoxelGeneratorHeightmap</a></li>
		<li><a href="../API/VoxelGeneratorImage.html">VoxelGeneratorImage</a></li>
		<li><a href="../API/VoxelGeneratorNoise.html">VoxelGeneratorNoise</a></li>
		<li><a href="../API/VoxelGeneratorNoise2D.html">VoxelGeneratorNoise2D</a></li>
		<li><a href="../API/VoxelGeneratorScript.html">VoxelGeneratorScript</a></li>
		<li><a href="../API/VoxelGeneratorWaves.html">VoxelGeneratorWaves</a></li>
		<li><a href="../API/VoxelGraphFunction.html">VoxelGraphFunction</a></li>
		<li><a href="../API/VoxelInstanceComponent.html">VoxelInstanceComponent</a></li>
		<li><a href="../API/VoxelInstanceGenerator.html">VoxelInstanceGenerator</a></li>
		<li><a href="../API/VoxelInstanceLibrary.html">VoxelInstanceLibrary</a></li>
		<li><a href="../API/VoxelInstanceLibraryItem.html">VoxelInstanceLibraryItem</a></li>
		<li><a href="../API/VoxelInstanceLibraryMultiMeshItem.html">VoxelInstanceLibraryMultiMeshItem</a></li>
		<li><a href="../API/VoxelInstanceLibrarySceneItem.html">VoxelInstanceLibrarySceneItem</a></li>
		<li><a href="../API/VoxelInstancer.html">VoxelInstancer</a></li>
		<li><a href="../API/VoxelLodTerrain.html">VoxelLodTerrain</a></li>
		<li><a href="../API/VoxelMeshSDF.html">VoxelMeshSDF</a></li>
		<li><a href="../API/VoxelMesher.html">VoxelMesher</a></li>
		<li><a href="../API/VoxelMesherBlocky.html">VoxelMesherBlocky</a></li>
		<li><a href="../API/VoxelMesherCubes.html">VoxelMesherCubes</a></li>
		<li><a href="../API/VoxelMesherDMC.html">VoxelMesherDMC</a></li>
		<li><a href="../API/VoxelMesherTransvoxel.html">VoxelMesherTransvoxel</a></li>
		<li><a href="../API/VoxelModifier.html">VoxelModifier</a></li>
		<li><a href="../API/VoxelModifierMesh.html">VoxelModifierMesh</a></li>
		<li><a href="../API/VoxelModifierSphere.html">VoxelModifierSphere</a></li>
		<li><a href="../API/VoxelNode.html">VoxelNode</a></li>
		<li><a href="../API/VoxelRaycastResult.html">VoxelRaycastResult</a></li>
		<li><a href="../API/VoxelStream.html">VoxelStream</a></li>
		<li><a href="../API/VoxelStreamRegionFiles.html">VoxelStreamRegionFiles</a></li>
		<li><a href="../API/VoxelStreamSQLite.html">VoxelStreamSQLite</a></li>
		<li><a href="../API/VoxelStreamScript.html">VoxelStreamScript</a></li>
		<li><a href="../API/VoxelTerrain.html">VoxelTerrain</a></li>
		<li><a href="../API/VoxelTool.html">VoxelTool</a></li>
		<li><a href="../API/VoxelToolBuffer.html">VoxelToolBuffer</a></li>
		<li><a href="../API/VoxelToolLodTerrain.html">VoxelToolLodTerrain</a></li>
		<li><a href="../API/VoxelToolTerrain.html">VoxelToolTerrain</a></li>
		<li><a href="../API/VoxelViewer.html">VoxelViewer</a></li>
		<li><a href="../API/VoxelVoxLoader.html">VoxelVoxLoader</a></li>
		<li><a href="../API/ZN_FastNoiseLite.html">ZN_FastNoiseLite</a></li>
		<li><a href="../API/ZN_FastNoiseLiteGradient.html">ZN_FastNoiseLiteGradient</a></li>
		<li><a href="../API/ZN_ThreadedTask.html">ZN_ThreadedTask</a></li>
	</ul>

</li>
<li><span>主文档</span>
	<ul>
		<li><a href="../主文档/VoxelGeneratorGraph节点.html">VoxelGeneratorGraph节点</a></li>
		<li><a href="../主文档/VoxelGeneratorGraph详细使用.html">VoxelGeneratorGraph详细使用</a></li>
		<li><a href="../主文档/下载安装.html">下载安装</a></li>
		<li><a href="../主文档/优化性能.html">优化性能</a></li>
		<li><a href="../主文档/体素相关概念.html">体素相关概念</a></li>
		<li><a href="../主文档/使用脚本创建和修改体素数据.html">使用脚本创建和修改体素数据</a></li>
		<li><a href="../主文档/创建多人游戏.html">创建多人游戏</a></li>
		<li><a href="../主文档/参与GoodotVoxel模块开发.html">参与GoodotVoxel模块开发</a></li>
		<li><a href="../主文档/在编辑器中的使用.html">在编辑器中的使用</a></li>
		<li><a href="../主文档/地形类型.html">地形类型</a></li>
		<li><a href="../主文档/块状地形.html">块状地形</a></li>
		<li><a href="../主文档/基于VoxelInstancer的实例化.html">基于VoxelInstancer的实例化</a></li>
		<li><a href="../主文档/学习资源.html">学习资源</a></li>
		<li><a href="../主文档/平滑地形.html">平滑地形</a></li>
		<li><a href="../主文档/快速上手.html">快速上手</a></li>
		<li><a href="../主文档/流.html">流</a></li>
		<li><a href="../主文档/生成器.html">生成器</a></li>
		<li><a href="../主文档/程序化生成.html">程序化生成</a></li>
	</ul>

</li>
<li><span>序列化格式</span>
	<ul>
		<li><a href="../序列化格式/SQLite格式.html">SQLite格式</a></li>
		<li><a href="../序列化格式/体素块格式v1.html">体素块格式v1</a></li>
		<li><a href="../序列化格式/体素块格式v2.html">体素块格式v2</a></li>
		<li><a href="../序列化格式/体素块格式v3.html">体素块格式v3</a></li>
		<li><a href="../序列化格式/体素块格式v4.html">体素块格式v4</a></li>
		<li><a href="../序列化格式/区域格式v2.html">区域格式v2</a></li>
		<li><a href="../序列化格式/区域格式v3.html">区域格式v3</a></li>
		<li><a href="../序列化格式/压缩数据格式.html">压缩数据格式</a></li>
		<li><a href="../序列化格式/实例块格式v0.html">实例块格式v0</a></li>
		<li><a href="../序列化格式/实例块格式v1.html">实例块格式v1</a></li>
		<li><a href="../序列化格式/序列化格式.html">序列化格式</a></li>
	</ul>

</li>
</ul>

		</div>

	</aside>
	<!-- 整体布局 -->
	<div class="layout center">
		<!-- 正文区 -->
		<div class="main">
<h1>基于VoxelInstancer的实例化</h1><p>

<h2>概述</h2><p>

Godot Voxel提供了一个<span class="inline_code">VoxelInstancer</span>节点，以及基于它的实例化系统，用于在地形的表面实例化网格或场景。必须将此节点添加为体素地形的子节点。<p>

它可以生成两种不同类型的对象：<p>
<li>    </li><p>
    多网格实例。它们可以非常多，并且可以选择发生碰撞。
<li>    </li><p>
    场景实例。他们使用常规场景，但是速度要慢得多，因此应调整为低数字。<p>

该系统主要用于模仿自然分布：随机生成草，岩石，树木、树叶和其他。它不适合复杂的人造结构，如房屋或村庄，但如果可用功能适合您的游戏，在某些情况下可以使用场景实例。<p>
此功能目前仅在 <span class="inline_code">VoxelLodTerrain</span> 下可用。<p>
<h2>基础使用</h2><p>

在<span class="inline_code">VoxelLodTerrain</span> 节点下添加一个<span class="inline_code">VoxelInstancer</span>子节点。<p>
<img src="./基于VoxelInstancer的实例化.assets/image-20231009202442333.png" alt="image-20231009202442333" style="zoom: 50%;" /><p>
为其<span class="inline_code">Library</span>属性创建一个新的<span class="inline_code">VoxelInstanceLibrary</span>资源。并为其添加一个MutiMesh项。<p>
<img src="./基于VoxelInstancer的实例化.assets/image-20231009202255936.png" alt="image-20231009202255936" style="zoom: 33%;" /><p>
<img src="./基于VoxelInstancer的实例化.assets/image-20231009202607072.png" alt="image-20231009202607072" style="zoom:33%;" /><p>
此时默认成绩中已经出现了随机分布的立方体，它们嵌入地形网格的表面。<p>
<img src='./基于VoxelInstancer的实例化.assets/image-20231009203133558.png' alt="image-20231009203133558" /><p>

更改地形的生成器类型，也会自动更新实例化的内容。<p>
<img src='./基于VoxelInstancer的实例化.assets/image-20231009203110303.png' alt="image-20231009203110303" /><p>

<hr><p>
<b>注意</b><p>

如果你正在制作一颗行星，你可能想将  <span class="inline_code">VoxelInstancer</span> 的<span class="inline_code">up_mode</span> 设置为 <span class="inline_code">Sphere</span> 模式。这将告诉Instancer向上的方向在哪里，并根据地形的本地原点对齐项目。<p>
<hr><p>
<h3>修改实例化的网格</h3><p>

通过Mesh属性，可以指定实例化的网格。<p>
<img src="./基于VoxelInstancer的实例化.assets/image-20231009203715946.png" alt="image-20231009203715946" style="zoom:33%;" /><p>
比如我们修改默认的立方体为圆柱体，则整个实例化的网格都变为了圆柱体。<p>
<img src='./基于VoxelInstancer的实例化.assets/image-20231009203828461.png' alt="image-20231009203828461" /><p>

<h3> 修改生成的范围</h3><p>

<span class="inline_code">VoxelInstancer</span> 实例化网格的范围基于体素地形本身的 LOD 系统。你可以通过修改<span class="inline_code">VoxelInstanceLibraryItem </span>的<span class="inline_code">lod_index</span> 属性修改范围的大小。<p>
<img src="./基于VoxelInstancer的实例化.assets/image-20231009204447176.png" alt="image-20231009204447176" style="zoom:33%;" /><p>
例如，选择 <span class="inline_code">0</span> 将使物品在最近的范围内生成，并在远处快速淡出。更高的索引将在更大的范围内生成，因此随着玩家越来越近，也会更早地开始出现。实例在与地面相同的“块”中生成。<p>
<img src='https://voxel-tools.readthedocs.io/en/latest/images/instances_lod_index.webp' alt="Screenshot showing the effect of lod_index on the range of instances" /><p>
<p>
通常，场景可能由多个图层组成，因此越接近，细节就越多。一些较大的项目可以使用较高的 <span class="inline_code">lod_index</span>，这样就可以看到很远的地方，而较小的项目可以使用较低的 <span class="inline_code">lod_index</span>。<p>
<img src='https://voxel-tools.readthedocs.io/en/latest/images/landscape_with_instances.webp' alt="Screenshot of landscape using layers of instances" /><p>
<p>
在选择合适的网格时需要考虑一个平衡 <span class="inline_code">lod_index</span> ：目前，较大的索引更加不精确，因为它们在较低分辨率的网格之上工作。当靠近时，可能会看到这样的实例漂浮在地面上，或者沉入其中。这主要发生在山脊、裂缝或洞穴等变化剧烈的地区：<p>
<img src='https://voxel-tools.readthedocs.io/en/latest/images/misaligned_instances.webp' alt="Screemshot of misaligned instances" /><p>
<p>
为了解决这个问题，您可以调整与项目 <span class="inline_code">generator</span> 关联的 <span class="inline_code">offset_along_normal</span> 参数。这取决于资产，因此将它们设计为可以将部分底部沉入地下可能会产生一些误差。<p>

有时可能还不够，所以这个问题仍然需要在将来解决。可能的方法包括：<p>
<li>    </li><p>
    查询世界生成器以在不使用网格的情况下近似表面（如果对地面进行了编辑，则不适合）
<li>    </li><p>
    随着更高分辨率数据的可用，逐渐以某种方式捕捉实例
<li>    </li>
一次加载整个世界的编辑体素，以便即使从远处也可以查询它们（占用更多内存）<p>
<hr><p>
<b>注意</b><p>

制作草或其他物品时，最好使用自定义着色器根据与摄像机的距离淡化网格，这样它们就不会突然消失。使用相似颜色的地面纹理也有助于使其混合。<p>
<hr><p>
<h3> 网格 LOD</h3><p>
<p>
包括一个辅助LOD系统，它在一定程度上适用于网格体本身。Godot 3没有LOD系统（Godot 4有），因此这允许从一组可见网格内减少远距离的顶点数量。<p>

要使用它，您必须在 <span class="inline_code">VoxelInstanceLibraryItem</span> 以下位置填充 3 个网格 LOD 属性：<p>
<img src='https://voxel-tools.readthedocs.io/en/latest/images/mesh_lod_properties.webp' alt="Screenshot of mesh LOD properties" /><p>
<p>
如果仅设置该 <span class="inline_code">mesh</span> 属性，则不会使用 LOD。<p>

选择 LOD 的距离当前是硬编码的，因为它取决于该项目的加载块，而后者又取决于 <span class="inline_code">lod_index</span> <span class="inline_code">lod_distance</span> 父体素地形的属性。<p>
<img src='https://voxel-tools.readthedocs.io/en/latest/images/mesh_lods.webp' alt="Screenshot of mesh LODs with colors" /><p>
<p>
如果需要较少的LOD，则可以分配两次相同的网格。这个系统非常严格，因为在Godot 4中，它可能会被更改为只有一个专用于冒名顶替者网格的插槽。事实上，Godot 4 可能支持网格体上的 LOD，但并没有计划让最后一个 LOD 成为冒名顶替者，所以这应该仍然可以实现。<p>
 注意<p>

冒名顶替者网格是简单的四边形，可以在很远的距离上伪造真实模型的存在。例如，这是一种从远处渲染森林的非常快速的方法，同时能够在靠近时使用详细的树木。<p>
<h3> 版本</h3><p>
<p>
尚不支持在编辑器中手动编辑实例。只能使用过程生成来定义实例生成的位置。<p>

但是，在挖掘它们生成的地面时，可以从游戏中移除它们。<p>
<h3> 持久性</h3><p>
<p>
某些项目可能是永久性的。可以使用 VoxelInstanceLibraryItem 的属性启用 <span class="inline_code">persistent</span> 此选项。如果父地形有 <span class="inline_code">VoxelStream</span> 支撑，则来自已编辑方块的实例将保存到流中，并且下次玩家靠近该区域时不会重生。非持久性实例将始终在满足过程条件的每个图面上重生。<p>

持久性项的 ID 很重要，因为它将在保存的数据中使用。如果删除项目并尝试从仍包含实例的流中加载实例，则会出现警告。<p>

在撰写本文时，只有VoxelStreamSQLite支持保存实例。<p>

本文档介绍了保存格式。<p>
<h2>从场景创建MutiMesh项</h2><p>
<p>
可以添加现有场景为MutiMesh项。场景将被转换以适合多网格的实例化渲染。场景方式可以设置碰撞体。<p>

有两种方法可以从场景进行设置：<p>
<li>    </li><p>
    分配 <span class="inline_code">scene</span> 属性。这将在运行时转换场景。场景将链接到项目，因此如果场景发生变化，它将保持更新。
<li>    </li><p>
    使用检查器顶部的 <span class="inline_code">Setup from scene</span> 按钮。这不会链接场景，而是分配在编辑器中执行转换的手动属性。如果场景发生变化，该项目将不会更新。如果场景嵌入了网格、材质或纹理，它们最终可能会被复制到项目的资源文件中。<p>

转换过程希望场景遵循特定结构：<p>
<div class="code_block"><pre><code>- PhysicsBody (StaticBody, RigidBody...)
    - MeshInstance_LOD0 &lt;-- "LOD" suffixes are optional but allow to specify the 4 LODs if needed
    - MeshInstance_LOD1
    - MeshInstance_LOD2
    - MeshInstance_LOD3
    - CollisionShape1
    - CollisionShape2
    - ...
</code>
</pre>
</div><p>
<p>
可以通过两种方式设置材质：<p>
<li>    </li><p>
    <span class="inline_code">material_override</span> 在网格实例上
<li>    </li><p>
    直接在网格资源上添加材料<p>

不支持 <span class="inline_code">MeshInstance</span> 节点上的曲面材料属性。<p>
<h3> 场景实例</h3><p>
<p>
多网格项目快速高效，但有局限性。<p>

通过添加类型 <span class="inline_code">VoxelInstanceLibrarySceneItem</span> 为的项目来支持实例化场景。常规场景实例将创建为 的 <span class="inline_code">VoxelInstancer</span> 子级，而不是生成多网格体。优点是能够对它们施加更多样化的行为，例如脚本、声音、动画，甚至进一步生成逻辑或交互。唯一的约束是，场景的根必须是 <span class="inline_code">Node3D</span> 或派生自它。<p>
与多网格实例相比，这种自由度的代价很高。添加许多实例可能会很快变慢，因此从编辑器创建这些项目时，这些项目的默认密度较低。强烈建议不要使用太复杂的场景，因为根据设置，如果您的计算机无法处理太多实例，可能会导致Godot冻结或崩溃。<p>
<hr><p>
<b>警告</b><p>

如果将场景添加到库中，然后尝试从同一场景加载该库，Godot 将崩溃。这是一个循环引用，目前很难在所有情况下检测到。<p>
<hr><p>
<h2> 程序生成</h2><p>

<h3> 内置生成器</h3><p>

<img src='https://voxel-tools.readthedocs.io/en/latest/images/instances_procgen.webp' alt="Screenshot of a layer of instances using noise" /><p>
<p>
项目是使用默认的内置生成器添加的，因此它们已经根据程序规则生成，而不是手动绘制。您可以通过检查 <span class="inline_code">generator</span> VoxelInstanceLibraryItem 的属性来调整生成器。<p>

位于游戏中编辑的块中的持久实例将不再重新生成。<p>
<h2>自定义实例生成器</h2><p>
<p>
该功能是最新的，API 可能仍会更改，因此目前脚本无法使用此功能。<p>
<h2>流事件（高级）</h2><p>
<p>
<span class="inline_code">VoxelInstancer</span> 知道何时通过向父级的块事件注册来生成事物。这目前不适用于 的 <span class="inline_code">VoxelLodTerrain</span> 脚本 API，但将来可能会添加。

		</div>
		
	</div>
	<!-- 右侧 - 文章目录区 -->
	<aside class="right">
		<h3>目录</h3>
		<ul>
			
		</ul>
	</aside>
	<!-- 实施语法高亮 -->
	<script>hljs.highlightAll();</script>
</body>
</html>