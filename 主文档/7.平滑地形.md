---
created: 2023-09-26T22:26:52 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/smooth_terrain/
author: 
---

# Smooth terrains平滑地形

> ## Excerpt
> It is possible to work with smooth-looking terrains, using signed distance fields and VoxelMesherTransvoxel.可以使用带符号的距离字段和 VoxelMesherTransvoxel .

---
It is possible to work with smooth-looking terrains, using signed distance fields and `VoxelMesherTransvoxel`.  
可以使用带符号的距离字段和 `VoxelMesherTransvoxel` .

## Signed distance fields 有符号距离字段

### Concept 概念

In order to represent smooth terrain, using a grid with points being either 0 or 1 is not enough. Such a grid is good for polygonizing blocky surfaces, but not curves. It could be averaged or blurred somehow, but this would be expensive.  
为了表示平滑地形，使用点为 0 或 1 的格网是不够的。这样的网格适用于多边形块状表面，但不适用于曲线。它可以以某种方式平均或模糊，但这将是昂贵的。

For any point in space, a signed distance field (SDF) is a distance to the closest surface. It is "signed" because if the point is below a surface ("inside of something"), that distance becomes negative. That means the surface is defined by all the points for which the SDF is 0. That `0` is usually called the `isolevel`.  
对于空间中的任何点，有符号距离场 （SDF） 是到最近表面的距离。它是“有符号的”，因为如果点在表面下方（“某物内部”），则该距离变为负数。这意味着曲面由 SDF 为 0 的所有点定义。这 `0` 通常称为 `isolevel` .

SDF is commonly used in raymarching shaders as a way to define volumes. It is also used in the Transvoxel algorithm (a variant of Marching Cubes), which is implemented by this engine. So instead of discrete values, voxels store a sort of smooth "gradient" of distances.  
SDF 通常用于光线行进着色器中，作为定义体积的一种方式。它也用于Transvoxel算法（行进立方体的变体），该算法由该引擎实现。因此，体素存储的不是离散值，而是存储一种平滑的距离“梯度”。

### Technical explanation 技术说明

Voxels use SDF in 3D, so to help visualizing it, we'll have a look at 2D examples. If we were to represent a sphere with blocky voxels, we would apply the following pseudo-code to every voxel:  
体素在 3D 中使用 SDF，因此为了帮助可视化它，我们将查看 2D 示例。如果我们要表示一个具有块状体素的球体，我们会将以下伪代码应用于每个体素：

```
if distance(center, position) < radius:
    voxel = 1
else:
    voxel = 0

```

Which gives the following:  
这给出了以下内容：

![Blocky SDF](https://voxel-tools.readthedocs.io/en/latest/images/sdf_example_blocky.webp)

Each voxel has binary values, either 1 or 0. But that gives no information about how the transition occurs between "matter" and "air", so if we were to render this using Transvoxel, the result would be:  
每个体素都有二进制值，即 1 或 0。但这并没有提供关于“物质”和“空气”之间如何发生转换的信息，所以如果我们使用 Transvoxel 渲染它，结果将是：

![SDF sphere blocky](https://voxel-tools.readthedocs.io/en/latest/images/sdf_sphere_blocky.webp)

It is kinda blocky. Now, we might indeed want this result (see section about shaders). But if we dont, we will need to change the code. In fact, if we walk back one step, the answer is already there:  
它有点块状。现在，我们可能确实想要这个结果（请参阅有关着色器的部分）。但是如果我们不这样做，我们将需要更改代码。事实上，如果我们往后退一步，答案就已经存在了：

```
voxel = distance(origin, position) - radius

```

This is the signed distance of a sphere. Here shown normalized, so voxels close to `0` are grey:  
这是球体的有符号距离。此处显示归一化，因此接近的 `0` 体素为灰色：

![True SDF](https://voxel-tools.readthedocs.io/en/latest/images/sdf_example_true.webp)

Every voxel now contains a slowly changing gradient, so when Transvoxel marches through all cells to find the surface, it will see much more precise variations than just `0` or `1`, which allows it to produce smooth polygons.  
现在，每个体素都包含一个缓慢变化的渐变，因此当Transvoxel遍历所有单元格以找到表面时，它将看到比“或 `1` ” `0` 更精确的变化，这允许它产生平滑的多边形。

![SDF sphere blocky](https://voxel-tools.readthedocs.io/en/latest/images/sdf_sphere_smooth.webp)

### Scaling and clamping 缩放和夹紧

This engine allows to edit voxels and save them. Storing true SDF can be expensive for games. For example, because it is a _distance_, if a player builds a small tower on the ground, we would have to keep voxels up to date far away in the sky, just because the tower made the ground slightly closer to them. So in practice, it is not required to deal with exact SDF. We only need something that's good enough, so the gradients can vary at different speeds and modifications can stay "local".  
该引擎允许编辑体素并保存它们。存储真正的 SDF 对于游戏来说可能很昂贵。例如，因为这是一个距离，如果玩家在地面上建造一座小塔，我们将不得不让体素在天空中保持最新状态，只是因为塔使地面稍微靠近它们。因此，在实践中，不需要处理确切的SDF。我们只需要足够好的东西，所以梯度可以以不同的速度变化，修改可以保持“局部”。

Voxels far away in the sky are actually not interesting for us. The surface is what we really need. So we can clamp distances, such that voxels far enough from the surface will have the same value. And if a whole chunk has the same value, it can be optimized out as "uniform".  
远在天空中的体素对我们来说实际上并不有趣。表面是我们真正需要的。因此，我们可以夹紧距离，这样离表面足够远的体素将具有相同的值。如果整个块具有相同的值，则可以将其优化为“均匀”。

So the sphere SDF we've seen earlier would actually look like this in the data:  
因此，我们之前看到的球体 SDF 在数据中实际上看起来像这样：

![Clamped SDF](https://voxel-tools.readthedocs.io/en/latest/images/sdf_example_clamped.webp)

Over multiple chunks, all regions without a gradient will take very little space in memory.  
在多个块上，所有没有梯度的区域将占用很少的内存空间。

To save further memory, this engine does not store SDF using 32-bit `float` numbers (not by default). Instead, it uses either 8-bit or 16-bit integers, which are interpreted as fixed-point decimal numbers between -1 and 1. Anything lower or higher is clamped. That means the distance we want to store has to be scaled to best exploit this interval.  
为了节省更多内存，此引擎不使用 32 位 `float` 数字存储 SDF（默认情况下不是）。相反，它使用 8 位或 16 位整数，这些整数被解释为 -1 到 1 之间的定点十进制数。任何更低或更高的东西都被夹紧。这意味着我们必须调整要存储的距离以最好地利用此间隔。

In practice, it means before storing SDF in a `VoxelBuffer`, we scale it by `0.1`, or lower when using 16-bit. The lower the scale, the longer the gradient will span before it gets clamped, but the more memory will be used to store that variation. It should not be too low either, because 16-bit cannot represent variations that are too small. This scale may need to be tweaked if you use a lot of LOD levels, because if voxels are seen from very far away, the gradient will need to extend for long enough to remain smooth.  
实际上，这意味着在将 SDF 存储在 `VoxelBuffer` 中之前，我们在使用 16 位时将其缩放 `0.1` 或更低。比例越低，梯度在被钳制之前的时间越长，但用于存储该变化的内存就越多。它也不应该太低，因为 16 位不能表示太小的变体。如果使用大量 LOD 级别，则可能需要调整此比例，因为如果从很远的地方看到体素，则渐变需要延长足够长的时间才能保持平滑。

For more information about SDF and other domains where they are used, you can check out some of these videos:  
有关 SDF 和使用它们的其他域的详细信息，您可以查看以下一些视频：

-   [Glyphs, shapes, fonts, signed distance fields. (Martin Donald)  
    字形、形状、字体、有符号的距离字段。（马丁·唐纳德）](https://www.youtube.com/watch?v=1b5hIMqz_wM)
-   [Coding Adventure: Marching Cubes (Sebastian Lague)  
    编程冒险：行进的立方体（塞巴斯蒂安·拉格）](https://www.youtube.com/watch?v=M3iI2l0ltbE)
-   [Painting a Cartoon Girl using Mathematics (Inigo Quilez)  
    用数学画一个卡通女孩（Inigo Quilez）](https://www.youtube.com/watch?v=8--5LwHRhjk)
-   [Code for a bunch of SDF functions and operations (Inigo Quilez)  
    一堆SDF函数和操作的代码（Inigo Quilez）](https://iquilezles.org/articles/distfunctions/)

## Transvoxel 异体素

### Definition 定义

Transvoxel is an extension of Marching Cubes that can be used to create smooth meshes from voxel data. The advantage of this algorithm is to integrate stitching of different levels of details without causing cracks, so it can be used to render very large landscapes.  
Transvoxel 是行进立方体的扩展，可用于从体素数据创建平滑网格。该算法的优点是可以集成不同层次细节的拼接而不会引起裂缝，因此可用于渲染非常大的景观。

For more information, visit [https://transvoxel.org/](https://transvoxel.org/).  
有关更多信息，请访问 https://transvoxel.org/。

### Smooth stitches in vertex shader  
顶点着色器中的平滑拼接

Transvoxel uses special meshes to stitch blocks of different level of detail. However the seams may still be visible as occasional sharp little steps. To smooth this out a bit, meshes produced by `VoxelMesherTransvoxel` contain extra information in their `CUSTOM0` attribute, telling how to move vertices to smooth those steps, and make room for them in the regular part of the mesh.  
Transvoxel使用特殊的网格来拼接不同细节级别的块。然而，接缝可能仍然可见，偶尔会有尖锐的小台阶。为了平滑这一点，生成的 `VoxelMesherTransvoxel` 网格在其 `CUSTOM0` 属性中包含额外的信息，告诉如何移动顶点以平滑这些步骤，并在网格的常规部分中为它们腾出空间。

Create and setup a `ShaderMaterial` on your terrain, and integrate this snippet to it:  
在您的地形上创建和设置 ， `ShaderMaterial` 并将以下代码片段集成到其中：

```
// This is recognized and assigned automatically by the voxel engine
uniform int u_transition_mask;

float get_transvoxel_secondary_factor(int idata) {
    int cell_border_mask = idata & 63; // Which sides the cell is touching
    int vertex_border_mask = (idata >> 8) & 63; // Which sides the vertex is touching
    // If the vertex is near a side where there is a low-resolution neighbor,
    // move it to secondary position
    int m = u_transition_mask & cell_border_mask;
    float t = float(m != 0);
    // If the vertex lies on one or more sides, and at least one side has no low-resolution neighbor,
    // don't move the vertex.
    t *= float((vertex_border_mask & ~u_transition_mask) == 0);
    return t;
}

vec3 get_transvoxel_position(vec3 vertex_pos, vec4 fdata) {
    int idata = floatBitsToInt(fdata.a);

    // Move vertices to smooth transitions
    float secondary_factor = get_transvoxel_secondary_factor(idata);
    vec3 secondary_position = fdata.xyz;
    vec3 pos = mix(vertex_pos, secondary_position, secondary_factor);

    // If the mesh combines transitions and the vertex belongs to a transition,
    // when that transition isn't active we change the position of the vertices so
    // all triangles will be degenerate and won't be visible.
    // This is an alternative to rendering them separately,
    // which has less draw calls and less mesh resources to create in Godot.
    // Ideally I would tweak the index buffer like LOD does but Godot does not
    // expose anything to use it that way.
    int itransition = (idata >> 16) & 0xff; // Is the vertex on a transition mesh?
    float transition_cull = float(itransition == 0 || (itransition & u_transition_mask) != 0);
    pos *= transition_cull;

    return pos;
}

void vertex() {
    VERTEX = get_transvoxel_position(VERTEX, CUSTOM0);
    //...
}

```

Research issue which led to this code: [Issue #2](https://github.com/Zylann/godot_voxel/issues/2)  
导致此代码的研究问题：问题#2

## Texturing 纹理

Texturing a voxel surface can be more difficult than classic 3D meshes, because the geometry isn't known in advance, and can have almost any shape. So in this section we'll review ways to solve UV-mapping, procedural techniques and blending textures from voxel data.  
对体素表面进行纹理处理可能比经典 3D 网格更困难，因为几何图形事先并不知道，并且几乎可以具有任何形状。因此，在本节中，我们将回顾解决UV映射，程序技术和从体素数据混合纹理的方法。

### Triplanar mapping 三平面映射

Classic UV-mapping cannot be used on smooth voxel surfaces, because of the arbitrary shapes it can contain. In fact, smooth meshers don't provide any proper UV. So instead, we can use triplanar mapping.  
经典的 UV 映射不能用于平滑的体素表面，因为它可以包含任意形状。事实上，平滑网格划分器不提供任何适当的 UV。因此，我们可以改用三平面映射。

The method involves projecting the texture on to the part of object that directly faces the X-axis. Then projecting it on the sides that directly face the Y-axis. Then again for the Z-axis. The edges of these projections are then blended together with a specified sharpness.  
该方法涉及将纹理投影到直接面向 X 轴的对象部分。然后将其投影到直接面向 Y 轴的侧面。然后再次用于 Z 轴。然后将这些投影的边缘以指定的锐度混合在一起。

Look at how the brick textures are blended together on the top right sphere.  
看看砖块纹理是如何在右上角的球体上混合在一起的。

![Triplanar mapping image](https://voxel-tools.readthedocs.io/en/latest/images/triplanar_example.webp)

Read about [triplanar mapping in Godot](https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html#triplanar-mapping).  
阅读有关戈多中的三平面映射的信息。

It is also possible to choose a different texture for the 3 axes.  
也可以为 3 个轴选择不同的纹理。

Here's a shader that supports two materials, such as grass on the top and rock on the sides, each with triplanar mapped albedo, normal and AO maps, then blended together based on if their normal faces the upward direction or the sides.  
这是一个着色器，它支持两种材质，例如顶部的草和侧面的岩石，每种材质都有三平面映射的反照率、法线和 AO 贴图，然后根据它们的法线朝向上还是面向侧面混合在一起。

You can find a working example in the [demo](https://github.com/Zylann/voxelgame), or see the [shader](https://github.com/Zylann/voxelgame/blob/godot4/project/smooth_terrain/transvoxel_terrain.gdshader) itself (triplanar functions defined here https://github.com/Zylann/voxelgame/blob/godot4/project/smooth\_terrain/shaders/triplanar.gdshaderinc).  
您可以在演示中找到工作示例，或查看着色器本身（此处定义的三平面函数 https://github.com/Zylann/voxelgame/blob/godot4/project/smooth\_terrain/shaders/triplanar.gdshaderinc）。

In the shader parameters, add your two albedo maps, and optionally normal, and AO maps. Then play with the `AB Mix 1` and `AB Mix 2` sliders to adjust how the top and sides blend together. The other settings should be self explanatory. The screenshot below also has a little bit of fog and far DOF added.  
在着色器参数中，添加两个反照率贴图、法线贴图和 AO 贴图（可选）。然后使用 和 滑块来调整顶部 `AB Mix 1` 和 `AB Mix 2` 侧面混合在一起的方式。其他设置应不言自明。下面的屏幕截图还添加了一点雾和远自由度。

![Textured terrain](https://voxel-tools.readthedocs.io/en/latest/images/textured-terrain.jpg)

### Procedural texturing 程序纹理

Voxel data is heavy, so if texturing rules of your game are simple enough to be determined from a shader and don't impact gameplay, you won't need to define any extra data in the voxels. For example, you can check the normal of a terrain surface to blend between a grass and rock texture, and use snow above a certain height.  
体素数据量很大，因此，如果游戏的纹理规则足够简单，可以从着色器确定并且不影响游戏玩法，则无需在体素中定义任何额外的数据。例如，您可以检查地形表面的法线以混合草和岩石纹理，并使用一定高度以上的雪。

### 4-blend over 16 textures  
4-混合超过16种纹理¶

#### Voxel data 体素数据

If you want textures to come from voxel data, `VoxelMesherTransvoxel` has a `texture_mode` property which can be set to `TEXTURES_BLEND_4_OVER_16`. This mode allows up to 16 textures and blends only the 4 most used ones per voxel. It expects voxel data in the `INDICES` and `WEIGHTS` channels, encoded into 16-bit depth values. There are 4 weights and 4 indices per voxel, each using 4 bits. It is very tight and does not allow for long gradients, but should be enough for most cases.  
如果希望纹理来自体素数据， 具有 `VoxelMesherTransvoxel` 一个 `texture_mode` 可以设置为 `TEXTURES_BLEND_4_OVER_16` .此模式最多允许 16 个纹理，并且每个体素仅混合 4 个最常用的纹理。它期望 `INDICES` 和 `WEIGHTS` 通道中的体素数据编码为 16 位深度值。每个体素有 4 个权重和 4 个索引，每个使用 4 位。它非常紧密，不允许长梯度，但在大多数情况下应该足够了。

```
          1st byte    2nd byte
INDICES:  aaaa bbbb   cccc dddd
WEIGHTS:  aaaa bbbb   cccc dddd

```

By default, these channels default to indices `(0,1,2,3)` and weights `(1,0,0,0)`, meaning voxels always start with texture `0`.  
默认情况下，这些通道默认为索引 `(0,1,2,3)` 和权重 `(1,0,0,0)` ，这意味着体素始终以纹理开头 `0` 。

The feature is recent and will need further work or changes in this area. At the moment, indices and weights are mostly applied manually. It is possible to set them directly with `VoxelTool.set_voxel` but it is up to you to pack them properly. One easy way to paint is to use `VoxelTool.do_sphere()`:  
该功能是最新的，需要在此领域进行进一步的工作或更改。目前，指数和权重大多是手动应用的。可以直接设置它们， `VoxelTool.set_voxel` 但由您正确包装它们。一种简单的绘画方法是使用 `VoxelTool.do_sphere()` ：

```
# Paints texture 2 in a sphere area (does not create matter)
voxel_tool.set_mode(VoxelTool.MODE_TEXTURE_PAINT)
voxel_tool.set_texture_index(2)
voxel_tool.set_texture_opacity(1.0)
voxel_tool.do_sphere(hit_position, radius)

```

It is also possible to generate this in `VoxelGeneratorGraph` using special outputs, but it still requires a bit of math to produce valid data.  
也可以使用特殊输出生成 `VoxelGeneratorGraph` 它，但它仍然需要一些数学运算才能生成有效数据。

#### Mesh data 网格数据

The mesher will include texturing information in the `CUSTOM1` attribute of vertices. Contrary to voxel values, the packed information will have 8 bits of precision:  
网格器将在顶点 `CUSTOM1` 的属性中包含纹理信息。与体素值相反，打包的信息将具有 8 位精度：

-   `CUSTOM1.x` will contain 4 indices, encoded as 4 bytes, which can be obtained by reinterpreting the float number as an integer and using bit-shifting operators.  
    `CUSTOM1.x` 将包含 4 个索引，编码为 4 个字节，可以通过将浮点数重新解释为整数并使用位移运算符来获得。
-   `CUSTOM1.y` will contain 4 weights, again encoded as 4 bytes.  
    `CUSTOM1.y` 将包含 4 个权重，再次编码为 4 个字节。

Each index tell which texture needs to be used, and each weight respectively tells how much of that texture should be blended. It is essentially the same as a classic color splatmap, except textures can vary. One minor downside is that you cannot blend more than 4 textures per voxel, so if this happens, it might cause artifacts. But in practice, it is assumed this case is so infrequent it can be ignored.  
每个索引指示需要使用哪种纹理，每个权重分别指示应混合多少纹理。它本质上与经典的彩色贴图相同，只是纹理可以变化。一个小缺点是每个体素不能混合超过 4 个纹理，因此如果发生这种情况，可能会导致伪影。但在实践中，人们认为这种情况很少见，可以忽略不计。

#### Shader 着色器

Here is the shader code you will need:  
以下是您需要的着色器代码：

```
shader_type spatial;

// Textures should preferably be in a TextureArray, so looking them up is cheap
uniform sampler2DArray u_texture_array : source_color;

// We'll need to pass data from the vertex shader to the fragment shader
varying vec4 v_indices;
varying vec4 v_weights;
varying vec3 v_normal;
varying vec3 v_pos;

// We'll use a utility function to decode components.
// It returns 4 values in the range [0..255].
vec4 decode_8bit_vec4(float v) {
    uint i = floatBitsToUint(v);
    return vec4(
        float(i & uint(0xff)),
        float((i >> uint(8)) & uint(0xff)),
        float((i >> uint(16)) & uint(0xff)),
        float((i >> uint(24)) & uint(0xff)));
}

// A voxel mesh can have overhangs in any direction,
// so we may have to use triplanar mapping functions.
vec3 get_triplanar_blend(vec3 world_normal) {
    vec3 blending = abs(world_normal);
    blending = normalize(max(blending, vec3(0.00001))); // Force weights to sum to 1.0
    float b = blending.x + blending.y + blending.z;
    return blending / vec3(b, b, b);
}

vec4 texture_array_triplanar(sampler2DArray tex, vec3 world_pos, vec3 blend, float i) {
    vec4 xaxis = texture(tex, vec3(world_pos.yz, i));
    vec4 yaxis = texture(tex, vec3(world_pos.xz, i));
    vec4 zaxis = texture(tex, vec3(world_pos.xy, i));
    // blend the results of the 3 planar projections.
    return xaxis * blend.x + yaxis * blend.y + zaxis * blend.z;
}

void vertex() {
    // Indices are integer values so we can decode them as-is
    v_indices = decode_8bit_vec4(CUSTOM1.x);

    // Weights must be in [0..1] so we divide them
    v_weights = decode_8bit_vec4(CUSTOM1.y) / 255.0;

    v_pos = VERTEX;
    v_normal = NORMAL;

    //...
}

void fragment() {
    // Define a texture scale for convenience.
    // We can use an array instead if different scales per index is needed.
    float uv_scale = 0.5;

    // Sample the 4 blending textures, all with triplanar mapping.
    // We can re-use the same triplanar blending factors for all of them so separating that part
    // of the function improves performance a little.
    vec3 blending = get_triplanar_blend(v_normal);
    vec3 col0 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.x).rgb;
    vec3 col1 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.y).rgb;
    vec3 col2 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.z).rgb;
    vec3 col3 = texture_array_triplanar(u_texture_array, v_pos * uv_scale, blending, v_indices.w).rgb;

    // Get weights and make sure they are normalized.
    // We may add a tiny safety margin so we can afford some degree of error.
    vec4 weights = v_weights;
    weights /= (weights.x + weights.y + weights.z + weights.w + 0.00001);

    // Calculate albedo
    vec3 col = 
        col0 * weights.r + 
        col1 * weights.g + 
        col2 * weights.b + 
        col3 * weights.a;

    ALBEDO = col;

    //...
}

```

![Smooth voxel painting prototype](https://voxel-tools.readthedocs.io/en/latest/images/smooth_voxel_painting_on_plane.webp)

Note 注意

If you only need 4 textures, then you can leave indices to their default values (which contains `0,1,2,3`) and only use weights. When using `VoxelTool`, you may only use texture indices 0, 1, 2 or 3. Texture arrays are less relevant in this case.  
如果您只需要 4 个纹理，则可以将索引保留为其默认值（包含 `0,1,2,3` ）并仅使用权重。使用 时，只能使用 `VoxelTool` 纹理索引 0、1、2 或 3。在这种情况下，纹理数组不太相关。

### Recommended Reading 推荐阅读

-   [SpatialMaterial](https://docs.godotengine.org/en/stable/classes/class_spatialmaterial.html) - demonstrates many of the shader options available in Godot.  
    空间材质 - 演示了Godot中可用的许多着色器选项。
-   [Shading Index](https://docs.godotengine.org/en/stable/tutorials/shading/index.html) - tutorials and the shader language API  
    着色索引 - 教程和着色器语言 API
-   Shader API Reference - some of the most frequently accessed references  
    着色器 API 参考 - 一些最常访问的参考
    -   [Shading Language 着色语言](https://docs.godotengine.org/en/stable/tutorials/shading/shading_reference/shading_language.html)
    -   [SpatialShader 空间着色器](https://docs.godotengine.org/en/stable/tutorials/shading/shading_reference/spatial_shader.html)

## Shading 着色

By default smooth voxels also produce smooth meshes by sharing vertices. This also contributes to meshes being smaller in memory.  
默认情况下，平滑体素还通过共享顶点生成平滑网格。这也会导致网格在内存中更小。

### Low-poly / flat-shaded look  
低多边形/平面阴影外观

It is currently not possible to make the mesher produce vertices with split flat triangles, but you can use this in your fragment shader.  
目前无法使网格器生成具有分割平面三角形的顶点，但您可以在片段着色器中使用它。

When using Vulkan: 使用 Vulkan 时：

```
NORMAL = normalize(cross(dFdy(VERTEX), dFdx(VERTEX)));

```

When using OpenGL: 使用 OpenGL 时：

```
NORMAL = normalize(cross(dFdx(VERTEX), dFdy(VERTEX)));

```

![Flat shading](https://voxel-tools.readthedocs.io/en/latest/images/flat_shading.webp)

### Blocky look 块状外观

It is also possible to give a "blocky" look to "smooth" voxels:  
也可以为“平滑”体素提供“块状”外观：

![Flat shading](https://voxel-tools.readthedocs.io/en/latest/images/blocky_sdf.webp)

This can be done by saturating SDF values in the voxel generator: they have to be always -1 or 1, without transition values. Since values are clamped when using `set_voxel_f`, multiplying by a large number also works. Built-in basic generators might not have this option, but you can do it if you use your own generator script or `VoxelGeneratorGraph`.  
这可以通过在体素生成器中饱和 SDF 值来完成：它们必须始终为 -1 或 1，没有转换值。由于值 `set_voxel_f` 在使用时是固定的，因此乘以大量也有效。内置的基本生成器可能没有此选项，但如果使用自己的生成器脚本或 `VoxelGeneratorGraph` .

You may also make shading hard-edged in your shader for better results.  
您还可以在着色器中使着色硬边以获得更好的效果。

## Shader API reference 着色器 API 参考

If you use a `ShaderMaterial` on a voxel node, the module may exploit some uniform (shader parameter) names to provide extra information. Some are necessary for features to work.  
如果在体素节点上使用 ， `ShaderMaterial` 模块可能会利用一些统一的（着色器参数）名称来提供额外信息。有些是功能工作所必需的。

| Parameter name 参数名称 | Type 类型 | Description 描述 |
| --- | --- | --- |
| `u_lod_fade` | `vec2` | Information for progressive fading between levels of detail. Only available with `VoxelLodTerrain`. See [Lod fading](https://voxel-tools.readthedocs.io/en/latest/smooth_terrain/#lod-fading-experimental)  
有关细节级别之间渐进淡入淡出的信息。仅与 一起使用 `VoxelLodTerrain` 。见 Lod 褪色 |
| `u_block_local_transform` | `mat4` | Transform of the rendered block, local to the whole volume, as they may be rendered with multiple meshes. Useful if the volume is moving, to fix triplanar mapping. Only available with `VoxelLodTerrain` at the moment.  
渲染块的变换，本地到整个体积，因为它们可能使用多个网格渲染。如果体积在移动，则可用于修复三平面映射。目前仅可用 `VoxelLodTerrain` 。 |
| `u_voxel_cell_lookup` | `usampler2D` | 3D `RG8` texture where each pixel contains a cell index packed in bytes of `R` and part of `G` (`r + ((g & 0x3f) << 8)`), and an axis index in 2 bits of `G` (`g >> 6`). The position to use for indexing this texture is relative to the origin of the mesh. The texture is 2D and square, so coordinates may be computed knowing the size of the mesh in voxels. Will only be assigned in meshes using detail texturing of [normalmaps](https://voxel-tools.readthedocs.io/en/latest/smooth_terrain/#distance-normals).  
3D `RG8` 纹理，其中每个像素包含一个以字节 `R` 和 `G` 部分 （ ） 为单位的单元格索引，以及一个以 （ ） `r + ((g & 0x3f) << 8)` 的 2 位为单位的 `G` 轴索引 `g >> 6` 。用于索引此纹理的位置相对于网格的原点。纹理是 2D 和正方形的，因此可以计算坐标，知道体素中网格的大小。将仅使用法线贴图的详细纹理在网格中分配。 |
| `u_voxel_normalmap_atlas` | `sampler2D` | Texture atlas where each tile contains a model-space normalmap (it is not relative to surface, unlike common normalmaps). Coordinates may be computed from `u_voxel_cell_lookup` and `u_voxel_virtual_texture_tile_size`. UV orientation is similar to triplanar mapping, but the axes are known from the information in `u_voxel_cell_lookup`. Will only be assigned in meshes using detail texturing of [normalmaps](https://voxel-tools.readthedocs.io/en/latest/smooth_terrain/#distance-normals).  
纹理图集，其中每个图块都包含一个模型空间法线贴图（与普通法线贴图不同，它不相对于表面）。坐标可以从 和 `u_voxel_virtual_texture_tile_size` 计算 `u_voxel_cell_lookup` 。UV 方向类似于三平面映射，但轴是从中 `u_voxel_cell_lookup` 的信息中知道的。将仅使用法线贴图的详细纹理在网格中分配。 |
| `u_voxel_virtual_texture_tile_size` | `int` | Resolution in pixels of each tile in `u_voxel_normalmap_atlas`.  
中 `u_voxel_normalmap_atlas` 每个磁贴的分辨率（以像素为单位）。 |
| `u_voxel_cell_size` | `float` | Size of one cubic cell in the mesh, in model space units. Will be > 0 in voxel meshes having [normalmaps](https://voxel-tools.readthedocs.io/en/latest/smooth_terrain/#distance-normals).  
网格中一个立方体单元的大小，以模型空间单位表示。在具有法线贴图的体素网格中将> 0。 |
| `u_voxel_block_size` | `int` | Size of the cubic block of voxels that the mesh represents, in voxels.  
网格表示的体素立方块的大小（以体素为单位）。 |
| `u_voxel_virtual_texture_fade` | `float` | When LOD fading is enabled, this will be a value between 0 and 1 for how much to mix in detail textures such as `u_voxel_normalmap_atlas`. They take time to update so this allows them to appear smoothly. The value is 1 if fading is not enabled, or 0 if the mesh has no detail textures.  
启用 LOD 淡入淡出后，此值将介于 0 和 1 之间，表示在细节纹理（如 `u_voxel_normalmap_atlas` .它们需要时间来更新，因此可以使它们顺利显示。如果未启用淡入淡出，则值为 1;如果网格没有细节纹理，则值为 0。 |
| `u_voxel_virtual_texture_offset_scale` | `vec4` | Used in LOD terrains where normalmaps are enabled. Contains a transformation to apply when sampling `u_voxel_cell_lookup` and `u_voxel_normalmap_atlas`. `x`, `y` and `z` contain an offset, and `w` contain a scale. This is relevant when textures for the current mesh aren't ready yet, so it falls back on a parent LOD: parent meshes are larger, so we need to sample a sub-region.  
在启用了法线贴图的 LOD 地形中使用。包含采样 `u_voxel_cell_lookup` 时要应用的转换和 `u_voxel_normalmap_atlas` 。 `x` ， `y` 并 `z` 包含偏移量和 `w` 比例。当当前网格体的纹理尚未准备就绪时，这一点很重要，因此它会回退到父 LOD：父网格更大，因此我们需要对子区域进行采样。 |
| `u_transition_mask` | `int` | When using `VoxelMesherTransvoxel`, this is a bitmask storing informations about neighboring meshes of different levels of detail. If one of the 6 sides of the mesh has a lower-resolution neighbor, the corresponding bit will be `1`. Side indices are in order `-X`, `X`, `-Y`, `Y`, `-Z`, `Z`. See [smooth stitches in vertex shaders](https://voxel-tools.readthedocs.io/en/latest/smooth_terrain/#smooth-stitches-in-vertex-shader).  
使用 `VoxelMesherTransvoxel` 时，这是一个位掩码，用于存储有关不同细节级别的相邻网格的信息。如果网格的 6 个边之一具有分辨率较低的相邻边，则相应的位将为 `1` 。侧索引按顺序 `-X` 排列 、 。 `X` `Z` `-Y` `Y` `-Z` 查看顶点着色器中的平滑拼接。 |

## Level of detail (LOD)  
详细级别 （LOD）

`VoxelLodTerrain` implements dynamic level of detail for smooth terrain.  
`VoxelLodTerrain` 实现平滑地形的动态细节级别。

### Description 描述

LOD (Level Of Detail) is a technique used to change the amount of geometry dymamically, such that meshes close to the viewer have high definition, while meshes far from the viewer are simplified down. This aims at improving performance.  
LOD（细节层次）是一种用于动态更改几何体数量的技术，使得靠近查看器的网格具有高清晰度，而远离查看器的网格则简化。这旨在提高性能。

![LOD example](https://voxel-tools.readthedocs.io/en/latest/images/lod_example.webp)

Note 注意

Careful: in this engine, `LOD` _levels_ are frequently represented with numbers from `0` to `N-1`, where `N` is the number of LODs. `0` is the _highest level of detail_, while LOD `1`, `2` etc up to `N-1` are _lower levels of detail_.  
注意：在这个引擎中， `LOD` 关卡经常用从 to `N-1` 的数字 `0` 表示，其中 `N` LOD 的数量。 `0` 是最高级别的细节，而LOD `1` 等 `2` `N-1` 是较低级别的细节。

![Illustration of level of detail with a grid of voxels](https://voxel-tools.readthedocs.io/en/latest/images/lod_density_schema.webp)

When going from LOD `i` to `i+1`, voxels and blocks double in size, covering more space. However resolution of blocks doesn't change, so detail density is lower and consumes less resources.  
当从LOD `i` 到 `i+1` ，体素和块的大小加倍，覆盖更多的空间。但是，块的分辨率不会改变，因此细节密度较低，消耗的资源更少。

### Octrees 八叉树

LOD is implemented using a _grid of octrees_. Each octree may then be subdivided into chunks of variable size, where the smallest size will be LOD 0.  
LOD 是使用八叉树网格实现的。然后可以将每个八叉树细分为可变大小的块，其中最小大小将为 LOD 0。

Subdivision occurs as the viewer gets closer. The threshold upon which it happens is controlled with the `lod_distance` property. It represents how far LOD 0 will spread around the viewer. It also affects how far other LODs will go, so it controls quality overall.  
随着观看者越来越近，细分就会发生。它发生的阈值由 `lod_distance` 属性控制。它表示 LOD 0 将在查看器中传播多远。它还会影响其他LOD的移动距离，因此它可以控制整体质量。

Similarly to `VoxelTerrain`, as the viewer moves around, octrees are loaded in front and those getting too far are unloaded. This allows to keep support for "infinite" terrain, without having to setup a single octree with unnecessary depth levels.  
与 `VoxelTerrain` 类似 ，当观看者四处移动时，章鱼树被加载在前面，而那些走得太远的章鱼树被卸载。这允许保持对“无限”地形的支持，而无需设置具有不必要的深度级别的单个八叉树。

In the editor, gizmos are showing the _grid of octrees_. Block bounds can be shown by checking the `Terrain -> Show octree nodes` menu.  
在编辑器中，小控件显示八叉树的网格。可以通过选中 `Terrain -> Show octree nodes` 菜单来显示块边界。

The size of the grid around the viewer depends on two factors:  
查看器周围的网格大小取决于两个因素：

-   The `view_distance` parameter of `VoxelLodTerrain`  
    的 `view_distance` `VoxelLodTerrain` 参数
-   The `view_distance` parameter on `VoxelViewer`.  
    上的 `view_distance` `VoxelViewer` 参数。

### Number of LODs LOD 数量

Increasing the number of LODs allows the terrain to have larger octrees, which in turns allows to increase view distance. It does not actually make `LOD0` sharper, it goes the other way around (if you expected otherwise, maybe you need to tweak your generator to produce larger shapes, reduce voxel size or change the scales of your game which might be too small). You might notice the grid of octrees changes size if you change LOD count: this is because it rounds to the current `view_distance`.  
增加LOD的数量允许地形具有更大的八叉树，这反过来又允许增加视图距离。它实际上并没有变得更 `LOD0` 清晰，而是相反（如果你另有预期，也许你需要调整你的生成器以产生更大的形状，减小体素大小或改变游戏的规模，这可能太小）。您可能会注意到，如果您更改 LOD 计数，八叉树的网格会改变大小：这是因为它四舍五入到当前 `view_distance` .

Reducing the number of LODs reduces the size of octrees, however it also means there will be much more of them to fill the grid up to `view_distance`. Make sure to keep a good sweetspot between LOD count and `view_distance` so that the density of octrees is not too high.  
减少LOD的数量可以减小八叉树的大小，但这也意味着将有更多的八叉树填充网格 `view_distance` 。确保在LOD计数和八叉树的密度之间保持良好的最佳平衡点， `view_distance` 以便八叉树的密度不会太高。

If you are not making an infinite terrain, you may give it fixed bounds with the `bounds` property, as well as a very large view distance so it stays in view. `bounds` will be rounded to octree size: for example, with 4 LODs and mesh block size of 16, LOD0 blocks will be 16, LOD1 will be 32, LOD2 will be 64... and LOD3 (the biggest) will be 128. Since the current implementation keeps at minimum 8 octrees around the origin, optimal bounds for this setup would be 256.  
如果您没有创建无限地形，则可以为其提供属性的 `bounds` 固定边界，以及非常大的视图距离，以便它保持在视野中。 `bounds` 将四舍五入为八叉树大小：例如，如果 4 个 LOD 和网格块大小为 16，LOD0 块将为 16，LOD1 将为 32，LOD2 将为 64...LOD3（最大）将为 128。由于当前实现在原点周围至少保留了 8 个八叉树，因此此设置的最佳边界为 256。

![Screenshot of fixed bounds LOD terrain](https://voxel-tools.readthedocs.io/en/latest/images/fixed_bounds_octrees.webp)

Following the same logic, fixed bounds of 512 is optimal with 5 LODs, 1024 is optimal with 6 LODs and so on. This is based on mesh block size of `16`, so if you set it to `32`, you may set one less LOD since meshes are twice as big.  
遵循相同的逻辑，512 的固定边界对于 5 个 LOD 是最佳的，1024 对于 6 个 LOD 是最佳的，依此类推。这是基于 的 `16` 网格块大小，因此如果将其设置为 `32` ，则可以少设置一个 LOD，因为网格的大小是其两倍。

For information about LOD behavior in the editor, see [Camera options in editor](https://voxel-tools.readthedocs.io/en/latest/editor/#camera-options).  
有关编辑器中 LOD 行为的信息，请参阅编辑器中的摄像机选项。

### Voxel size 体素大小

Currently, the size of voxels is fixed to 1 space unit. It might be possible in a future version to change it. For now, a workaround is to scale down the node. However, make sure it is a uniform scale, and careful not to scale too low otherwise it might blow up.  
目前，体素的大小固定为 1 个空间单位。在将来的版本中可能会更改它。目前，解决方法是缩减节点。但是，请确保它是均匀的刻度，并注意不要刻度太低，否则可能会爆炸。

`scale` from Node3D must not be confused with the concept of _size_. If you change `scale`, _it will also scale the voxel grid_, view distances, all the dimensions you might have set in generators, and of course it will apply to child nodes as well. The result will _look the same_, just bigger, no more details. So if you want something larger _with more details as a result_, it is recommended to change these sizes instead of scaling everything. For example, if your generator contains a sphere and Perlin noise, you may change the radius of the sphere and the frequency/period of the noise instead of scaling the node. Doing it this way preserve the size of voxels and so it preserves accuracy.  
`scale` 从 Node3D 不能与大小的概念混淆。如果更改 `scale` ，它还将缩放体素网格、查看距离、可能在生成器中设置的所有维度，当然它也适用于子节点。结果看起来是一样的，只是更大，没有更多细节。因此，如果您想要更大的内容和更多细节，建议更改这些大小而不是缩放所有内容。例如，如果发生器包含球体和柏林噪声，则可以更改球体的半径和噪声的频率/周期，而不是缩放节点。这样做可以保留体素的大小，从而保持准确性。

Godot also allows you to scale non-uniformly, but it's not recommended (might cause collision issues too).  
Godot还允许您不均匀地缩放，但不建议这样做（也可能导致碰撞问题）。

### Full load mode 满载模式

LOD applies both to meshes and to voxel data, keeping memory usage relatively constant. Depending on your settings, distant voxels will not load full-resolution data. Only full-resolution voxels can be edited, so that means you can only modify terrain in a limited distance around the viewer.  
LOD 适用于网格和体素数据，使内存使用量保持相对恒定。根据您的设置，远距离体素将不会加载全分辨率数据。只能编辑全分辨率体素，这意味着您只能在查看器周围有限距离内修改地形。

If this limitation isn't suitable for your game, a workaround is to enable `full_load_mode`. This will load all edited chunks present in the `stream` (if any), such that all the data is available and can be edited anywhere without wait. Non-edited chunks will cause the generator to be queried on the fly instead of being cached. Because data streaming won't take place, keep in mind more memory will be used the more edited chunks the terrain contains.  
如果此限制不适合您的游戏，解决方法是启用 `full_load_mode` 。这将加载（如果有的话 `stream` ）中存在的所有已编辑的块，以便所有数据都可用，并且可以在任何地方进行编辑而无需等待。未编辑的区块将导致生成器被动态查询而不是缓存。由于不会发生数据流，因此请记住，地形包含的编辑区块越多，将使用的内存就越多。

### LOD fading LOD 淡入淡出

LOD changes can introduce some mild "popping" in the landscape, which might be a bit disturbing. One way to attenuate this problem is to fade meshes when they switch from two different levels of details. When a "parent" mesh subdivides into higher-resolution "child" meshes, they can be both rendered at the same time for a brief period of time, while the parent fades out and the children fade in, and vice-versa. This trick requires you to use a `ShaderMaterial` on `VoxelLodTerrain`, as the rendering part needs an extra bit of code inside the fragment shader.  
LOD 更改可能会在景观中引入一些轻微的“爆裂”，这可能会有点令人不安。缓解此问题的一种方法是在网格从两个不同的细节级别切换时淡入淡出网格。当“父”网格细分为更高分辨率的“子”网格时，它们可以在短时间内同时渲染，而父网格淡出，子网格淡入，反之亦然。此技巧要求您使用 `ShaderMaterial` on `VoxelLodTerrain` ，因为渲染部分需要在片段着色器中增加一些代码。

`VoxelLodTerrain` has a property `lod_fade_duration`, expressed in seconds. By default it is `0`, which makes it inactive. Setting it to a small value like `0.25` will enable it.  
`VoxelLodTerrain` 有一个属性 `lod_fade_duration` ，以秒表示。默认情况下为 `0` ，这使它处于非活动状态。将其设置为较小的值，例如 `0.25` 将启用它。

In your shader, add the following uniform:  
在着色器中，添加以下统一：

```
// This is recognized and assigned automatically by the voxel node
uniform vec2 u_lod_fade;

```

Add also this function (unless you have it already):  
还要添加此函数（除非您已经拥有它）：

```
float get_hash(vec2 c) {
    return fract(sin(dot(c.xy, vec2(12.9898,78.233))) * 43758.5453);
}

```

And _at the end_ of `fragment()`, add this:  
在 的 `fragment()` 末尾添加以下内容：

```
// Discard pixels progressively.
// It has to be last to workaround https://github.com/godotengine/godot/issues/34966
float h = get_hash(SCREEN_UV);
if (u_lod_fade.y > 0.5) {
    // Fade in
    if (u_lod_fade.x < h) {
        discard;
    }
} else {
    // Fade out
    if (u_lod_fade.x > h) {
        discard;
    }
}

```

Note: this is an example of implementation. There might be more optimized ways to do it.  
注意：这是一个实现示例。可能有更优化的方法可以做到这一点。

This will discard such that pixels of the two meshes will be complementary without overlap. `discard` is used so the mesh can remain rendered in the same pass (usually the opaque pass).  
这将丢弃，使两个网格的像素互补而不重叠。 `discard` ，以便网格可以保持在同一通道（通常是不透明通道）中渲染。

This technique has some limitations:  
此技术有一些局限性：

-   Shadow maps still create self-shadowing in cases the faded meshes are far enough from each other. While both meshes are rendered to cross-fade, one of them will eventually project shadows on the other. This creates a lot of noisy patches. Turning off shadows from one of them does not fix the other, and turning shadows off will make them pop. I haven't found a solution yet. See https://github.com/godotengine/godot-proposals/issues/692#issuecomment-782331429  
    阴影贴图仍会在褪色网格彼此足够远的情况下创建自阴影。虽然两个网格都渲染为交叉淡入淡出，但其中一个网格最终会在另一个网格上投影阴影。这会产生很多嘈杂的补丁。关闭其中一个阴影并不能修复另一个阴影，关闭阴影会使它们弹出。我还没有找到解决方案。见 https://github.com/godotengine/godot-proposals/issues/692#issuecomment-782331429

### Detail rendering 细节渲染

LOD decimates geometric details quite fast in the distance. It can be tuned up, but it quickly gets very expensive to generate and render a lot of polygons. An alternative is to generate normalmaps instead for medium/far meshes, to give the illusion of detail on otherwise flat polygons.  
LOD可以非常快速地消除远处的几何细节。它可以调整，但生成和渲染大量多边形很快就会变得非常昂贵。另一种方法是为中/远网格生成法线贴图，以在其他平面多边形上产生细节错觉。

This engine contains an implementation of such a technique adapted to voxel meshes (thanks to [Victor Careil](https://twitter.com/phyronnaz/status/1544005424495607809) for the insight!), so it can work even with overhangs.  
该引擎包含适用于体素网格的这种技术的实现（感谢 Victor Careil 的洞察力！），因此它甚至可以处理悬垂。

Here is a landscape without the feature:  
下面是一个没有该功能的景观：

![Landscape without detailed normals](https://voxel-tools.readthedocs.io/en/latest/images/distance_normals_off.webp)

With the feature: 具有以下功能：

![Landscape with detailed normals](https://voxel-tools.readthedocs.io/en/latest/images/distance_normals_on.webp)

The number of polygons is the same:  
多边形的数量相同：

![Landscape wireframe](https://voxel-tools.readthedocs.io/en/latest/images/distance_normals_wireframe.webp)

This can be turned on in the inspector when using `VoxelLodTerrain`. The cost is slower mesh generation and more memory usage to store normalmap textures.  
使用 时 `VoxelLodTerrain` ，可以在检查器中打开此功能。成本是网格生成速度较慢，存储法线贴图纹理的内存使用量增加。

This feature is only available in `VoxelLodTerrain`. It also works best with data streaming turned off (`full_load_mode_enabled`), because being able to see all details from far away requires to not unload edited blocks. It will still use the generator if data streaming is on, but you won't see edited regions.  
此功能仅在 中 `VoxelLodTerrain` 可用。它在关闭数据流的情况下也最有效 （ `full_load_mode_enabled` ），因为能够从远处查看所有细节需要不卸载编辑的块。如果数据流处于打开状态，它仍将使用生成器，但你不会看到编辑的区域。

Despite improving detail at lower cost than geometry, detail rendering is significantly more expensive than generating regular blocks. Several ways to optimize it are:  
尽管以比几何体更低的成本改善细节，但细节渲染比生成常规块要昂贵得多。优化它的几种方法是：

-   Tweak tile sizes and LOD levels. The bigger tiles are, the higher the quality, but the more expensive it gets. Also the feature is usually not doing much if used at LODs 0 and 1, so usually a good default is to begin at LOD 2, with minimum tile size 4 and maximum 16.  
    调整磁贴大小和 LOD 级别。瓷砖越大，质量越高，但价格越高。此外，如果在 LOD 0 和 1 处使用，该功能通常不会执行太多操作，因此通常一个好的默认值是从 LOD 2 开始，最小切片大小为 4，最大为 16。
-   Use a simplified version of the `VoxelGenerator`. It is possible to override the generator that will be used to compute normalmaps, with `VoxelLodTerrain.set_normalmap_generator_override`. A typical use case is when the generator can produce caves. Caves don't have enough impact on surface visuals, so they could be ignored beyond a certain LOD level.  
    使用 的 `VoxelGenerator` 简化版本 .可以使用 覆盖 `VoxelLodTerrain.set_normalmap_generator_override` 将用于计算法线贴图的生成器。一个典型的用例是发电机可以产生洞穴。洞穴对表面视觉效果的影响不够，因此在超出某个LOD级别时可以忽略它们。
-   Use SIMD noise. Noise is often the biggest bottleneck. In general, SIMD noise such as `FastNoise2` will perform better.  
    使用单边噪声。噪音往往是最大的瓶颈。一般来说，诸如 SIMD 噪声的性能 `FastNoise2` 会更好。

#### Shader 着色器

Rendering these normals requires special shader code in your terrain material.  
渲染这些法线需要在地形材质中使用特殊的着色器代码。

```
// NOTE: this is not a full shader code, just the part of it required for this feature

// TODO Godot is not binding integer samplers properly.
// See https://github.com/godotengine/godot/issues/57841
// TODO Workaround using float texelFetch doesnt't work either...
// See https://github.com/godotengine/godot/issues/31732
//uniform usampler2D u_voxel_cell_lookup;
uniform sampler2D u_voxel_cell_lookup : filter_nearest;

uniform sampler2D u_voxel_normalmap_atlas;
uniform int u_voxel_virtual_texture_tile_size;
uniform float u_voxel_cell_size;
uniform int u_voxel_block_size;
// This is used when falling back on a detail texture from a parent mesh.
// The texture will cover a larger cube, so we use this information
// to query only inside a sub-region.
// (x, y, z) is offset, (w) is scale.
uniform vec4 u_voxel_virtual_texture_offset_scale;

varying vec3 v_vertex_pos_model;


vec2 pad_uv(vec2 uv, float amount) {
    return uv * (1.0 - 2.0 * amount) + vec2(amount);
}

// https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/
vec3 octahedron_decode(vec2 f) {
    f = f * 2.0 - 1.0;
    // https://twitter.com/Stubbesaurus/status/937994790553227264
    vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));
    float t = clamp(-n.z, 0.0, 1.0);
    // GLSL didn't accept the vector version of this. Any impact?
    n.x += n.x >= 0.0 ? -t : t;
    n.y += n.y >= 0.0 ? -t : t;
    return /*f == vec2(0.0) ? vec3(0.0) : */normalize(n);
}

vec3 get_voxel_normal_model() {
    float cell_size = u_voxel_cell_size;
    int block_size = u_voxel_block_size;
    int normalmap_tile_size = u_voxel_virtual_texture_tile_size;

    vec3 cell_posf = vertex_pos_model / cell_size;
    cell_posf = cell_posf * u_voxel_virtual_texture_offset_scale.w + u_voxel_virtual_texture_offset_scale.xyz;
    ivec3 cell_pos = ivec3(floor(cell_posf));
    vec3 cell_fract = fract(cell_posf);

    int cell_index = cell_pos.x + cell_pos.y * block_size + cell_pos.z * block_size * block_size;
    int lookup_sqri = int(ceil(sqrt(float(block_size * block_size * block_size))));
    ivec2 lookup_pos = ivec2(cell_index % lookup_sqri, cell_index / lookup_sqri);
    //uvec3 lookup_value = texelFetch(u_voxel_cell_lookup, lookup_pos, 0).rgb;
    //vec3 lookup_valuef = texelFetch(u_voxel_cell_lookup, lookup_pos, 0).rgb;
    vec2 lookup_valuef = texture(u_voxel_cell_lookup, (vec2(lookup_pos) + vec2(0.5)) / float(lookup_sqri)).rg;
    ivec2 lookup_value = ivec2(round(lookup_valuef * 255.0));
    int tile_index = lookup_value.r | ((lookup_value.g & 0x3f) << 8);
    int tile_direction = lookup_value.g >> 6;

    vec3 tile_texcoord = vec3(0.0, 0.0, float(tile_index));
    // TODO Could do it non-branching with weighted addition
    switch(tile_direction) {
        case 0:
            tile_texcoord.xy = cell_fract.zy;
            break;
        case 1:
            tile_texcoord.xy = cell_fract.xz;
            break;
        case 2:
            tile_texcoord.xy = cell_fract.xy;
            break;
    }
    float padding = 0.5 / normalmap_tile_size;
    tile_texcoord.xy = pad_uv(tile_texcoord.xy, padding);

    ivec2 atlas_size = textureSize(u_voxel_normalmap_atlas, 0);
    int tiles_per_row = atlas_size.x / normalmap_tile_size;
    ivec2 tile_pos_pixels = ivec2(tile_index % tiles_per_row, tile_index / tiles_per_row) * normalmap_tile_size;
    vec2 atlas_texcoord = (vec2(tile_pos_pixels) + float(normalmap_tile_size) * tile_texcoord) / vec2(atlas_size);
    vec3 encoded_normal = texture(u_voxel_normalmap_atlas, atlas_texcoord).rgb;

    // You may switch between these two snippets depending on if you use octahedral compression or not
    // 1) XYZ
    vec3 tile_normal_model = 2.0 * encoded_normal - vec3(1.0);
    // 2) Octahedral
    // vec3 tile_normal_model = octahedron_decode(encoded_normal.rg);

    return tile_normal_model;
}

vec3 get_voxel_normal_view(vec3 geometry_normal_view, mat4 model_to_view) {
    if (u_voxel_cell_size == 0.0) {
        // Detail texture not available in this mesh
        return geometry_normal_view;
    }
    vec3 debug;
    vec3 tile_normal_model = get_voxel_normal_model(debug);
    vec3 tile_normal_view = (model_to_view * vec4(tile_normal_model, 0.0)).xyz;
    // In some edge cases the normal can be invalid (length close to zero), causing black artifacts.
    // Workaround this by falling back on the geometry normal.
    vec3 normal = mix(geometry_normal_view, tile_normal_view, dot(tile_normal_view, tile_normal_view));
    return normal;
}

void vertex() {
    // [...]

    // Note, if you use Transvoxel, this may be placed after modifications to `VERTEX`
    v_vertex_pos_model = VERTEX;

    // [...]
}

void fragment() {
    // [...]

    NORMAL = get_voxel_normal_view(NORMAL, VIEW_MATRIX * MODEL_MATRIX);

    // [...]
}

```

#### Details on the technique  
有关技术的详细信息

Normal-mapping usually requires texture coordinates (UVs). However, smooth voxel meshes aren't trivial to UV-map at runtime. Some methods exist to generate UV-maps on completely arbitrary meshes, but they are too expensive for realtime, or inappropriate for seamless chunked terrain. So instead, we can use something similar to "virtual texturing".  
法线贴图通常需要纹理坐标 （UV）。但是，平滑体素网格对于运行时的 UV 贴图来说并非易事。存在一些在完全任意网格上生成UV贴图的方法，但它们对于实时来说过于昂贵，或者不适合无缝分块地形。因此，我们可以使用类似于“虚拟纹理”的东西。

The mesh is first subdivided into a grid of cells (we can use Transvoxel cells, which are ready to use). In each cell, we pick an axis-aligned projection working best with triangles of the cell using the average of their normals. A tile can then be generated by projecting its pixels on triangles, evaluating a normal from voxel data, and storing it in an atlas (a TextureArray could be used, but it has more limited number of layers). A shader can then read the atlas using a lookup texture to find the tile. The lookup texture is a 3D texture that tells for each "cell" where is the tile in the atlas (but it can be stored as a 2D texture).  
网格首先细分为单元格网格（我们可以使用可以使用的Transvoxel单元格）。在每个单元格中，我们使用它们的法线平均值选择一个轴对齐的投影，最适合与单元格的三角形配合使用。然后，可以通过将其像素投影到三角形上，评估体素数据的法线并将其存储在图集中（可以使用 TextureArray，但它的图层数量更有限）来生成图块。然后，着色器可以使用查找纹理读取图集以查找磁贴。查找纹理是一种 3D 纹理，它告诉每个“单元格”图集中的磁贴在哪里（但它可以存储为 2D 纹理）。

![Image of an atlas of voxel normals](https://voxel-tools.readthedocs.io/en/latest/images/virtual_normalmap.webp)

To generate pixels of each tile, we need to access SDF data from two sources:  
要生成每个图块的像素，我们需要从两个来源访问 SDF 数据：

-   The procedural generator  
    程序生成器
-   Edited voxels at LOD 0  
    在 LOD 0 处编辑的体素

A classic method is used to obtain normals: on the desired position, we take 4 samples offset by a small step, compute their difference, and normalize the result. It's known as "forward differences" (see [Inigo Quilez's article about SDF normals](https://iquilezles.org/articles/normalsSDF/)).  
一种经典的方法用于获得法线：在所需位置，我们取 4 个样本偏移一小步，计算它们的差异，并对结果进行归一化。它被称为“前向差分”（参见Inigo Quilez关于SDF法线的文章）。

Since every mesh will have its own textures, another technique that comes in handy is [Octahedral Compression](https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/). These normals are world-space, and encoding them in a texture naively would require 3 bytes per pixel (for X, Y, Z). With octahedral compression, we trade off a bit of quality for a much smaller size of 2 bytes per pixels.  
由于每个网格都有自己的纹理，因此另一种派上用场的技术是八面体压缩。这些法线是世界空间，在纹理中编码它们需要每个像素 3 个字节（对于 X、Y、Z）。使用八面体压缩，我们牺牲了一些质量，以获得每像素 2 个字节的更小尺寸。

#### Rendering on the GPU  
在 GPU 上渲染

This feature is very expensive, so it is possible to run it on the graphics card if it supports Vulkan. This is enabled by checking `run on GPU` in the terrain's inspector.  
此功能非常昂贵，因此如果它支持 Vulkan，则可以在显卡上运行它。可通过选中 `run on GPU` 地形检查器来启用此功能。

Limitations: 局限性：

-   GPU normalmaps currently don't support edited voxels. Edited areas will fallback using the CPU.  
    GPU 法线贴图目前不支持编辑的体素。编辑的区域将使用 CPU 回退。
-   The generator you're using must support a shader variant using GLSL. `VoxelGeneratorGraph` is the only one supporting it at the moment. Some of its nodes don't have support for it.  
    您使用的生成器必须支持 GLSL 的着色器变体。 `VoxelGeneratorGraph` 是目前唯一支持它的人。它的某些节点不支持它。
