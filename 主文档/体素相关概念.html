<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>体素相关概念</title>
	<link rel="stylesheet" href="../index.css">
	<!-- 引入语法高亮 -->
	<link href="../highlight/dark.min.css" rel="stylesheet">
	<script src="../highlight/highlight.min.js"></script>
	<!-- 引入JQuery -->
	<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
	<script>
		$(function(){
			// 根据正文内容创建目录
			let content = "";
			$(".main h1,.main h2,.main h3").each(function(index,ele){
				$(this).before(`<a name ="ctn_${index}"></li>`)
				switch(ele.tagName){
					case "H1":
						content += `<li class="h1"><a href="#ctn_${index}">${ele.textContent}</a></li>`;
						break;
					case "H2":
						content += `<li class="h2"><a href="#ctn_${index}">${ele.textContent}</a></li>`;
						break;
					case "H3":
						content += `<li class="h3"><a href="#ctn_${index}">${ele.textContent.split("(")[0]}</a></li>`;
						break;
				}
			})
			$(".right ul").append(content);
			// 侧边栏子文件夹点击事件
			$(".doc_tree li>span").on("click",function(){
				$(this).next("ul").toggle();
			})
		})
	</script>
</head>
<body>
<!-- 左侧 -->
	<aside class="left">
		<div class="logo_box">
			<a href="#" class="logo_text">Godot Voxel</a>
			<span>中文文档</span>
		</div>
		<!-- 文档列表 -->
		<div class="doc_tree">
<ul>
	<li><a href="../README.html">README</a></li>
<li><span>API</span>
	<ul>
		<li><a href="../API/API文档.html">API文档</a></li>
		<li><a href="../API/FastNoise2.html">FastNoise2</a></li>
		<li><a href="../API/VoxelBlockSerializer.html">VoxelBlockSerializer</a></li>
		<li><a href="../API/VoxelBlockyAttribute.html">VoxelBlockyAttribute</a></li>
		<li><a href="../API/VoxelBlockyAttributeAxis.html">VoxelBlockyAttributeAxis</a></li>
		<li><a href="../API/VoxelBlockyAttributeCustom.html">VoxelBlockyAttributeCustom</a></li>
		<li><a href="../API/VoxelBlockyAttributeDirection.html">VoxelBlockyAttributeDirection</a></li>
		<li><a href="../API/VoxelBlockyAttributeRotation.html">VoxelBlockyAttributeRotation</a></li>
		<li><a href="../API/VoxelBlockyLibrary.html">VoxelBlockyLibrary</a></li>
		<li><a href="../API/VoxelBlockyLibraryBase.html">VoxelBlockyLibraryBase</a></li>
		<li><a href="../API/VoxelBlockyModel.html">VoxelBlockyModel</a></li>
		<li><a href="../API/VoxelBlockyModelCube.html">VoxelBlockyModelCube</a></li>
		<li><a href="../API/VoxelBlockyModelEmpty.html">VoxelBlockyModelEmpty</a></li>
		<li><a href="../API/VoxelBlockyModelMesh.html">VoxelBlockyModelMesh</a></li>
		<li><a href="../API/VoxelBlockyType.html">VoxelBlockyType</a></li>
		<li><a href="../API/VoxelBlockyTypeLibrary.html">VoxelBlockyTypeLibrary</a></li>
		<li><a href="../API/VoxelBoxMover.html">VoxelBoxMover</a></li>
		<li><a href="../API/VoxelBuffer.html">VoxelBuffer</a></li>
		<li><a href="../API/VoxelColorPalette.html">VoxelColorPalette</a></li>
		<li><a href="../API/VoxelDataBlockEnterInfo.html">VoxelDataBlockEnterInfo</a></li>
		<li><a href="../API/VoxelEngine.html">VoxelEngine</a></li>
		<li><a href="../API/VoxelGenerator.html">VoxelGenerator</a></li>
		<li><a href="../API/VoxelGeneratorFlat.html">VoxelGeneratorFlat</a></li>
		<li><a href="../API/VoxelGeneratorGraph.html">VoxelGeneratorGraph</a></li>
		<li><a href="../API/VoxelGeneratorHeightmap.html">VoxelGeneratorHeightmap</a></li>
		<li><a href="../API/VoxelGeneratorImage.html">VoxelGeneratorImage</a></li>
		<li><a href="../API/VoxelGeneratorNoise.html">VoxelGeneratorNoise</a></li>
		<li><a href="../API/VoxelGeneratorNoise2D.html">VoxelGeneratorNoise2D</a></li>
		<li><a href="../API/VoxelGeneratorScript.html">VoxelGeneratorScript</a></li>
		<li><a href="../API/VoxelGeneratorWaves.html">VoxelGeneratorWaves</a></li>
		<li><a href="../API/VoxelGraphFunction.html">VoxelGraphFunction</a></li>
		<li><a href="../API/VoxelInstanceComponent.html">VoxelInstanceComponent</a></li>
		<li><a href="../API/VoxelInstanceGenerator.html">VoxelInstanceGenerator</a></li>
		<li><a href="../API/VoxelInstanceLibrary.html">VoxelInstanceLibrary</a></li>
		<li><a href="../API/VoxelInstanceLibraryItem.html">VoxelInstanceLibraryItem</a></li>
		<li><a href="../API/VoxelInstanceLibraryMultiMeshItem.html">VoxelInstanceLibraryMultiMeshItem</a></li>
		<li><a href="../API/VoxelInstanceLibrarySceneItem.html">VoxelInstanceLibrarySceneItem</a></li>
		<li><a href="../API/VoxelInstancer.html">VoxelInstancer</a></li>
		<li><a href="../API/VoxelLodTerrain.html">VoxelLodTerrain</a></li>
		<li><a href="../API/VoxelMeshSDF.html">VoxelMeshSDF</a></li>
		<li><a href="../API/VoxelMesher.html">VoxelMesher</a></li>
		<li><a href="../API/VoxelMesherBlocky.html">VoxelMesherBlocky</a></li>
		<li><a href="../API/VoxelMesherCubes.html">VoxelMesherCubes</a></li>
		<li><a href="../API/VoxelMesherDMC.html">VoxelMesherDMC</a></li>
		<li><a href="../API/VoxelMesherTransvoxel.html">VoxelMesherTransvoxel</a></li>
		<li><a href="../API/VoxelModifier.html">VoxelModifier</a></li>
		<li><a href="../API/VoxelModifierMesh.html">VoxelModifierMesh</a></li>
		<li><a href="../API/VoxelModifierSphere.html">VoxelModifierSphere</a></li>
		<li><a href="../API/VoxelNode.html">VoxelNode</a></li>
		<li><a href="../API/VoxelRaycastResult.html">VoxelRaycastResult</a></li>
		<li><a href="../API/VoxelStream.html">VoxelStream</a></li>
		<li><a href="../API/VoxelStreamRegionFiles.html">VoxelStreamRegionFiles</a></li>
		<li><a href="../API/VoxelStreamSQLite.html">VoxelStreamSQLite</a></li>
		<li><a href="../API/VoxelStreamScript.html">VoxelStreamScript</a></li>
		<li><a href="../API/VoxelTerrain.html">VoxelTerrain</a></li>
		<li><a href="../API/VoxelTool.html">VoxelTool</a></li>
		<li><a href="../API/VoxelToolBuffer.html">VoxelToolBuffer</a></li>
		<li><a href="../API/VoxelToolLodTerrain.html">VoxelToolLodTerrain</a></li>
		<li><a href="../API/VoxelToolTerrain.html">VoxelToolTerrain</a></li>
		<li><a href="../API/VoxelViewer.html">VoxelViewer</a></li>
		<li><a href="../API/VoxelVoxLoader.html">VoxelVoxLoader</a></li>
		<li><a href="../API/ZN_FastNoiseLite.html">ZN_FastNoiseLite</a></li>
		<li><a href="../API/ZN_FastNoiseLiteGradient.html">ZN_FastNoiseLiteGradient</a></li>
		<li><a href="../API/ZN_ThreadedTask.html">ZN_ThreadedTask</a></li>
	</ul>

</li>
<li><span>主文档</span>
	<ul>
		<li><a href="../主文档/VoxelGeneratorGraph节点.html">VoxelGeneratorGraph节点</a></li>
		<li><a href="../主文档/VoxelGeneratorGraph详细使用.html">VoxelGeneratorGraph详细使用</a></li>
		<li><a href="../主文档/下载安装.html">下载安装</a></li>
		<li><a href="../主文档/优化性能.html">优化性能</a></li>
		<li><a href="../主文档/体素相关概念.html">体素相关概念</a></li>
		<li><a href="../主文档/使用脚本创建和修改体素数据.html">使用脚本创建和修改体素数据</a></li>
		<li><a href="../主文档/创建多人游戏.html">创建多人游戏</a></li>
		<li><a href="../主文档/参与GoodotVoxel模块开发.html">参与GoodotVoxel模块开发</a></li>
		<li><a href="../主文档/在编辑器中的使用.html">在编辑器中的使用</a></li>
		<li><a href="../主文档/地形类型.html">地形类型</a></li>
		<li><a href="../主文档/块状地形.html">块状地形</a></li>
		<li><a href="../主文档/基于VoxelInstancer的实例化.html">基于VoxelInstancer的实例化</a></li>
		<li><a href="../主文档/学习资源.html">学习资源</a></li>
		<li><a href="../主文档/平滑地形.html">平滑地形</a></li>
		<li><a href="../主文档/快速上手.html">快速上手</a></li>
		<li><a href="../主文档/流.html">流</a></li>
		<li><a href="../主文档/生成器.html">生成器</a></li>
		<li><a href="../主文档/程序化生成.html">程序化生成</a></li>
	</ul>

</li>
<li><span>序列化格式</span>
	<ul>
		<li><a href="../序列化格式/SQLite格式.html">SQLite格式</a></li>
		<li><a href="../序列化格式/体素块格式v1.html">体素块格式v1</a></li>
		<li><a href="../序列化格式/体素块格式v2.html">体素块格式v2</a></li>
		<li><a href="../序列化格式/体素块格式v3.html">体素块格式v3</a></li>
		<li><a href="../序列化格式/体素块格式v4.html">体素块格式v4</a></li>
		<li><a href="../序列化格式/区域格式v2.html">区域格式v2</a></li>
		<li><a href="../序列化格式/区域格式v3.html">区域格式v3</a></li>
		<li><a href="../序列化格式/压缩数据格式.html">压缩数据格式</a></li>
		<li><a href="../序列化格式/实例块格式v0.html">实例块格式v0</a></li>
		<li><a href="../序列化格式/实例块格式v1.html">实例块格式v1</a></li>
		<li><a href="../序列化格式/序列化格式.html">序列化格式</a></li>
	</ul>

</li>
</ul>

		</div>

	</aside>
	<!-- 整体布局 -->
	<div class="layout center">
		<!-- 正文区 -->
		<div class="main">
<h1>体素相关概念</h1><p>
<p>
本节介绍此体素引擎中使用的主要概念以及哪些部分实现这些概念。<p>
<h2> 什么是体素</h2><p>

<img src='./体素相关概念.assets/cubes_and_marching_cubes.webp' alt="Cubes and marching cubes" /><p>
<p>
“体素”是“体积图片元素”的缩写，类似于“像素”，意思是“图片元素”。它们组成体积，而不是简单的 2D 图像，这允许制作 3D 地形或 3D 模型。它们不像经典的基于多边形的模型那样仅表示对象的表面，还表示空间的每个点的内部。<p>

在此引擎中，体素是空间中保存某些值的特定点。这些值可以是：<p>
<li>    </li><p>
    体素的类型
<li>    </li><p>
    其密度（或符号距离）
<li>   它的颜色</li><p>
<li>   其材料</li><p>
<li>   等。。。</li><p>
<p>
体素可以通过在网格上手动确定其值或通过定义程序规则从任何位置生成体素（如分形噪声或符号距离字段公式）来获得。<p>
 注意<p>

虽然这个引擎最初是作为生成地形的一种方式，但它并不是你可以用它做的唯一事情。因此，您经常会在本文档中找到“体积”一词而不是“terrain”，以指定由体素组成的对象。<p>
<h2> 生成体素</h2><p>
<p>
体素跨越 3 维，因此与图像相反，随着体积变大，存储它们可能会占用更多内存。这就是为什么考虑体素的程序源很重要的原因，因为它们不消耗任何内存，并且可以以任何分辨率访问。<p>

此任务由派生 <a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelGenerator/' target="_blank">VoxelGenerator</a>
（体素生成器）的资源实现。他们的目标是在空间中的特定点或整个定义的体积中生成体素数据。生成模型、地形或行星的可能方法无穷无尽，我们不会在本节中详细介绍。<p>
生成器的类型包括：<p>
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorNoise2D/' target="_blank">VoxelGeneratorNoise2D</a></li><p>
: 使用 2D 分形噪声生成高度图
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorNoise/' target="_blank">VoxelGeneratorNoise</a></li><p>
: 使用3D噪声生成一个“海绵”世界，形成大型洞穴和悬垂物，经过修改，使大部分地形向下，仅成为某个高度以上的空气
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorFlat/' target="_blank">VoxelGeneratorFlat</a></li><p>
: 生成一个简单的平面。
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorGraph/' target="_blank">VoxelGeneratorGraph</a></li><p>
: 允许使用图形（如3D可视化着色器）组合各种操作，以产生比其他简单生成器更灵活的体积
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorScript/' target="_blank">VoxelGeneratorScript</a></li><p>
: 允许使用脚本实现生成逻辑。可能会比其他选项慢，除非使用 C<h1>或 GDNative。</h1><p>

<li>    </li>
其他<p>
<h2> 存储体素</h2><p>

<img src='./体素相关概念.assets/block_map_storage.webp' alt="Block map storage schema" /><p>
<p>
即使它需要大量内存，我们仍然必须在某个时候存储体素数据。这对于传递体素、存储无法使用生成器复制的玩家编辑或将地形保存到磁盘非常重要。<p>

执行此操作的核心类是VoxelBuffer。这是一个具有可配置格式的简单网格数据结构。您可能不必经常使用此类，但了解它的存储概念对于使用其他 API 如 VoxelTool 很有用。体素可以保存各种值，因此此对象使用多个通道，每个通道都是一种类型的信息：<p>
<li>    </li><p>
    <span class="inline_code">TYPE</span> ：体素的类型，主要用于将体素与《我的世界》中的模型类型相关联。这与磁贴地图或网格图中的磁贴 ID 非常相似。
<li>    </li>
<span class="inline_code">SDF</span> ：有符号距离场（Signed Distance Field）字段值，用于平滑体素。它告诉体素离表面有多远。这可以理解为物质密度，其中朝向的 <span class="inline_code">-1</span>值表示“物质”，朝向 <span class="inline_code">1</span> 的值表示“空气”。
<li>    </li>
<span class="inline_code">COLOR</span> ：颜色信息。它可以是压缩的RGBA，也可以是调色板的索引。
<li>   其他。</li><p>
<p>
引擎使用第一个通道，而其他通道暂时未使用。每个通道还可以使用可配置的位深度：8、16、32 或 64 位。这允许根据您的需要调整质量和内存使用情况。最后，应用简单的优化，以便如果通道填充相同的值，它不会分配内存，而是只存储该值。这样，天空等区域就不会占用内存。<p>
 警告<p>

有一个名为体素的类，但它实际上仅用于块状网格划分。它不是通用体素值，将来将重命名以避免混淆。<p>
<h3>将体素保存到磁盘</h3><p>

<img src='./体素相关概念.assets/region_file_seen_as_image.png' alt="Raw region file seen as an image" /><p>
<p>
当玩家对世界进行编辑时，或者当您想在编辑器中雕刻地形并保存更改时，有必要将体素保存到磁盘。<p>

此模块通过 VoxelStream 实现此功能。与生成器类似，流允许请求体素块，因此无需一次加载整个内容。而且，它还允许发回体素块以保存它们。如果世界非常大，这种基于块的方法特别有用。相比之下，较小的卷可能只是一次加载所有卷。子类可以通过各种方式实现它，通常使用压缩文件。<p>
<h2>将体素转换为网格</h2><p>

<img src='./体素相关概念.assets/cubes_and_wireframe.webp' alt="Cubes and wireframe" /><p>
<p>
当今的显卡功能越来越强大，但平均而言，多边形（网格）仍然是渲染 3D 模型的最快方式。所以我们不会真的直接画体素。相反，我们必须将它们转换为多边形，然后进行渲染。为此，此引擎使用名为VoxelMesher的资源。<p>

有几种方法可以从体素数据生成多边形，引擎提供了网格划分器类型来执行此操作：<p>
<li>    </li><p>
    体素网格立方体：
<li>    </li><p>
    体素网格块：
<li>    </li><p>
    VoxelMesherTransvoxel：
<li>    </li><p>
    VoxelMesherDMC：<p>
<h2>  </h2><p>

<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelMesherCubes/' target="_blank">VoxelMesherCubes</a></li><p>
: 体素的颜色用于生成彩色立方体。这是多边形体素的最简单方法。
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelMesherBlocky/' target="_blank">VoxelMesherBlocky</a></li><p>
: 体素类型用于将与该类型对应的网格批处理在一起。这也可以使用立方体，但如果提供自定义网格，则任何形状都可以。这与 Minecraft 中使用的技术类似，并且具有广泛的选择。
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelMesherTransvoxel/' target="_blank">VoxelMesherTransvoxel</a></li><p>
: 这个不是制作立方体，而是使用SDF值来产生基于Transvoxel算法的光滑表面。它还可以生成过渡网格，这对于将两个不同细节级别的网格拼接在一起很有用。
<li><a href='https://voxel-tools.readthedocs.io/en/latest/api/VoxelMesherDMC/' target="_blank">VoxelMesherDMC</a></li><p>
: 使用双行进立方体产生光滑表面的变体，如这些文章所述。但是，不再维护此实现。<p>
<h2>将其与节点放在一起</h2><p>

<img src='./体素相关概念.assets/game_examples.webp' alt="Game screenshots" /><p>
<p>
到目前为止，我们可以认为有足够的工具在游戏中使用体素。不过，从那里开始需要做更多的工作。<p>

将一堆体素转换为网格对于模型或一小块土地是可以的，但是它不能很好地缩放大型可编辑地形。如果该地形需要具有较大的视野距离，则会变得更加棘手。通常，建议的解决方案是将其分成块，最终使用可变的细节级别，并在玩家修改该地形的部分内容时正确更新它们。这就是 <span class="inline_code">VoxelTerrain*</span> 节点所做的，通过将之前看到的工具放在一起，并使用线程在后台运行繁重的操作。<p>
 注意<p>

在这个引擎中，“块”实际上被称为“块”。它们通常表示 16x16x16 体素的立方体。某些选项以块而不是空间单位指定。<p>

引擎支持两种主要类型的地形：<p>
<li>    </li><p>
    VoxelTerrain：这个使用一个简单的块网格，并在观众四处移动时负责加载和卸载块。它的视角距离与 Minecraft 类似，因此最好与块状体素或中等大小的平滑体积一起使用。
    
<li>    </li><p>
    VoxelLodTerrain：这个使用八叉树的块。与简单的网格相反，这允许在多个细节级别存储体素，从而允许渲染更大的距离。不过，它仅支持平滑体素，并且与其他体素相比具有不同的限制。
    <p>

这两种地形都可以实时编辑，只有编辑的部分才会动态重新划分网格。帮助程序类 VoxelTool 向脚本 API 公开，以简化编辑体素的过程，可以使用方法 <span class="inline_code">get_voxel_tool()</span> 获取体素。它允许设置单个体素，挖掘或混合简单的形状，如球体或盒子。此 API 上提供了与前面看到的相同的通道概念，因此根据您使用的网格器类型，您可能需要编辑 <span class="inline_code">TYPE</span> 或 <span class="inline_code">SDF</span> <span class="inline_code">COLOR</span> 通道。<p>

最后，要加载这些地形，需要在世界中至少放置一个体素查看器节点。这些通常可以作为玩家的子项或主 <span class="inline_code">Camera</span> .它们告诉体素引擎加载体素的位置、距离，并优先考虑它们附近发生的网格更新。

		</div>
		
	</div>
	<!-- 右侧 - 文章目录区 -->
	<aside class="right">
		<h3>目录</h3>
		<ul>
			
		</ul>
	</aside>
	<!-- 实施语法高亮 -->
	<script>hljs.highlightAll();</script>
</body>
</html>