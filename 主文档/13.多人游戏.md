---
created: 2023-09-26T22:29:22 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/multiplayer/
author: 
---

# Multiplayer多人游戏

> ## Excerpt
> Multiplayer in a voxel game can be implemented with lots of different details. Not all the features of the engine are supported, it is still a bit experimental and might change in the future. So how to setup multiplayer is explained in sections with a date. The most recent one will often relate to a new/better/simpler way, and old ones might eventually be removed.体素游戏中的多人游戏可以通过许多不同的细节来实现。并非支持引擎的所有功能，它仍然有点实验性，将来可能会发生变化。因此，如何在带有日期的部分中解释了如何设置多人游戏。最新的方法通常与新的/更好/更简单的方式有关，而旧的最终可能会被删除。

---
Multiplayer in a voxel game can be implemented with lots of different details. Not all the features of the engine are supported, it is still a bit experimental and might change in the future. So how to setup multiplayer is explained in sections with a date. The most recent one will often relate to a new/better/simpler way, and old ones might eventually be removed.  
体素游戏中的多人游戏可以通过许多不同的细节来实现。并非支持引擎的所有功能，它仍然有点实验性，将来可能会发生变化。因此，如何在带有日期的部分中解释了如何设置多人游戏。最新的方法通常与新的/更好/更简单的方式有关，而旧的最终可能会被删除。

Note 注意

This page assumes you already have knowledge in general multiplayer programming. It is strongly recommended you learn it beforehand. You can have a look at [Godot's documentation page about networking](https://docs.godotengine.org/en/stable/tutorials/networking/index.html).  
本页假定您已经具备一般多人游戏编程方面的知识。强烈建议您事先学习。你可以看看Godot关于网络的文档页面。

## 2023/04/13 - Server-side viewer with `VoxelTerrain` and `VoxelNetworkTerrain*` nodes  
2023/04/13 - 带有和 `VoxelNetworkTerrain*` 节点的 `VoxelTerrain` 服务器端查看器

This is a new iteration over the previous method, based on the same principle, but integrating it to the engine with some speed improvements.  
这是对以前方法的新迭代，基于相同的原理，但将其集成到引擎中，并提高了速度。

The server will be authoritative, and the client just receives information from it. Client and server will need a different setup.  
服务器将是权威的，客户端只是从中接收信息。客户端和服务器将需要不同的设置。

This will rely on Godot's high-level multiplayer API, using RPCs. It is important for a client or server to be setup before the terrain starts processing. This can be done before adding the game world to the tree, or initializing multiplayer in `_ready`.  
这将依赖于Godot的高级多人游戏API，使用RPC。在地形开始处理之前设置客户端或服务器非常重要。这可以在将游戏世界添加到树中或在 中 `_ready` 初始化多人游戏之前完成。

### On the server 在服务器上

-   Add `VoxelTerrain` to your scene.  
    添加到 `VoxelTerrain` 场景中。
-   Add a `VoxelTerrainMultiplayerSynchronizer` node as child of your `VoxelTerrain`.  
    添加一个 `VoxelTerrainMultiplayerSynchronizer` 节点作为 `VoxelTerrain` .
-   When a player joins, make sure a `VoxelViewer` is created for it. Assign its `network_peer_id` and enable `requires_data_block_notifications`. You may also want to turn off `require_visuals` on viewers representing remote players, since it's normally not necessary to render their surroundings.  
    当玩家加入时，请确保 `VoxelViewer` 为其创建一个。分配其 `network_peer_id` 并启用 `requires_data_block_notifications` .您可能还希望关闭 `require_visuals` 代表远程玩家的查看器，因为通常不需要渲染其周围环境。

### On the client 在客户端

-   Add `VoxelTerrain` to your scene.  
    添加到 `VoxelTerrain` 场景中。
-   Add `VoxelTerrainMultiplayerSynchronizer` node as child of the `VoxelTerrain`. Make sure it has the same name as its server equivalent.  
    将节点添加 `VoxelTerrainMultiplayerSynchronizer` 为 . `VoxelTerrain` 确保它与服务器等效项具有相同的名称。
-   The client will still need a `VoxelViewer`, which will allow the terrain to detect when it can unload voxel data (the server does not send that information). To reduce the likelihood of "holes" in the terrain if blocks get unloaded too soon, you may give the `VoxelViewer` a slightly larger view distance than the server.  
    客户端仍然需要一个 `VoxelViewer` ，这将允许地形检测何时可以卸载体素数据（服务器不发送该信息）。为了减少在块过早卸载时在地形中出现“漏洞”的可能性，您可以为服务器 `VoxelViewer` 提供稍大的视图距离。
-   The client can have remote players synchronized so the player can see them, but you should not add a `VoxelViewer` to them (only the server does). The client should not have to stream terrain for remote players, it only has one for the local player.  
    客户端可以同步远程播放器，以便播放器可以看到它们，但您不应向其添加 （ `VoxelViewer` 只有服务器这样做）。客户端不必为远程玩家流式传输地形，它只有一个用于本地玩家的地形。

## 2022/01/31 - Server-side viewer with `VoxelTerrain` and some scripting  
2022/01/31 - 带有一些脚本的 `VoxelTerrain` 服务器端查看器

This was the first iteration of support function allowing to implement multiplayer.  
这是支持功能的第一次迭代，允许实现多人游戏。

The idea is for the server to be authoritative, and the client just receives information from it.  
这个想法是让服务器具有权威性，客户端只是从中接收信息。

`VoxelTerrain` has a `Networking` category in the inspector. These properties are not necessarily specific to multiplayer, but were actually added to experiment with it, so they are grouped together.  
`VoxelTerrain` 在检查器中具有类别 `Networking` 。这些属性不一定特定于多人游戏，但实际上是为了试验而添加的，因此将它们组合在一起。

Client and server will need a different setup.  
客户端和服务器将需要不同的设置。

### On the server 在服务器上

-   Configure `VoxelTerrain` as normal, with a generator and maybe a stream.  
    正常配置 `VoxelTerrain` ，使用生成器和流。
-   On `VoxelTerrain`, Enable `block_enter_notification_enabled`  
    打开 `VoxelTerrain` ，启用 `block_enter_notification_enabled`
-   Add a script to `VoxelTerrain` implementing `func _on_data_block_entered(info)`. This function will be called each time a new voxel block enters a remote player's area. This will be a place where you may send the block to the client. You can use `VoxelBlockSerializer` to pack voxel data into bytes. The `info.are_voxels_edited()` boolean can tell if the block was ever edited: if it wasn't, you can avoid sending the whole data and just tell the client to generate the block locally.  
    将脚本添加到 `VoxelTerrain` 实现 `func _on_data_block_entered(info)` .每次新的体素块进入远程玩家区域时，都会调用此函数。这将是您可以将块发送到客户端的地方。您可以使用 将 `VoxelBlockSerializer` 体素数据打包到字节中。 `info.are_voxels_edited()` 布尔值可以判断块是否被编辑过：如果没有，你可以避免发送整个数据，而只是告诉客户端在本地生成块。
-   When a player joins, make sure a `VoxelViewer` is created for it, assign its `network_peer_id` and enable `requires_data_block_notifications`. This will make the terrain load blocks around it and notify when blocks need to be sent to the peer.  
    当玩家加入时，请确保为其创建 ， `VoxelViewer` 分配其 `network_peer_id` 并启用 `requires_data_block_notifications` .这将使地形加载其周围的块，并在需要将块发送到对等方时发出通知。
-   On `VoxelTerrain`, enable `area_edit_notification_enabled`  
    在 上 `VoxelTerrain` ，启用 `area_edit_notification_enabled`
-   In your `VoxelTerrain` script, implement `func _on_area_edited(origin, size)`. This function will be called each time voxels are edited within a bounding box. Voxels inside may have to be sent to all players close enough. You can get a list of network peer IDs by calling `get_viewer_network_peer_ids_in_area(origin, size)`.  
    在 `VoxelTerrain` 脚本中，实现 `func _on_area_edited(origin, size)` .每次在边界框中编辑体素时，都会调用此函数。内部的体素可能必须发送给所有足够近的玩家。您可以通过调用 `get_viewer_network_peer_ids_in_area(origin, size)` 来获取网络对等 ID 的列表。

### On the client 在客户端

-   Configure `VoxelTerrain` with a mesher and maybe a generator, and turn off `automatic_loading_enabled`. Voxels will only load based on what the server sends.  
    配置 `VoxelTerrain` 一个网格器，也许还有一个生成器，然后关闭 `automatic_loading_enabled` .体素只会根据服务器发送的内容进行加载。
-   Add a script handling network messages. When a block is received from the server, store it inside `VoxelTerrain` by using the `try_set_block_data` function.  
    添加处理网络消息的脚本。从服务器接收到块时，使用该 `try_set_block_data` 函数将其存储在内部 `VoxelTerrain` 。
-   When a box of edited voxels is received from the server, you may use a `VoxelTool` and the `paste` function to replace the edited voxels. If you want the client to generate the block locally, you could use the generator to make one with `generate_block_async()`. If you use asynchronous generation, note that blocks written with `try_set_block_data` will cancel blocks that are loading. That means if a client receives an edited block in the meantime, the generating block won't overwrite it.  
    当从服务器收到一盒已编辑的体素时，您可以使用 和 `VoxelTool` `paste` 函数来替换已编辑的体素。如果您希望客户端在本地生成块，则可以使用生成器创建一个 `generate_block_async()` 带有 .如果使用异步生成，请注意，写入的块将取消正在加载的 `try_set_block_data` 块。这意味着如果客户端在此期间收到编辑过的块，则生成块不会覆盖它。
-   The client will still need a `VoxelViewer`, which will allow the terrain to detect when it can unload voxel data (the server does not send that information). To reduce the likelihood of "holes" in the terrain if blocks get unloaded too soon, you may give the `VoxelViewer` a larger view distance than the server.  
    客户端仍然需要一个 `VoxelViewer` ，这将允许地形检测何时可以卸载体素数据（服务器不发送该信息）。为了减少块过早卸载时地形中出现“漏洞”的可能性，您可以为服务器提供比服务器 `VoxelViewer` 更大的视图距离。
-   The client can have remote players synchronized so the player can see them, but you should not add a `VoxelViewer` to them (only the server does). The client should not have to stream terrain for remote players, it only has one for the local player.  
    客户端可以同步远程播放器，以便播放器可以看到它们，但您不应向其添加 （ `VoxelViewer` 只有服务器这样做）。客户端不必为远程玩家流式传输地形，它只有一个用于本地玩家的地形。

## With `VoxelLodTerrain` 使用 `VoxelLodTerrain`

There is no support for now, but it is planned.  
目前没有支持，但已计划。

## Protocol notes 协议说明

RPCs in Godot use UDP (reliable or unreliable), so sending large amounts of voxels to clients could have limited speed. Instead, it would be an option to use TCP to send blocks instead, as well as large edits. Small edits or deterministic edits with ligthweight info could keep using reliable UDP. Problem: you would have to use two ports, one for UDP, one for TCP. So maybe it is a better idea to keep using reliable UDP.  
Godot 中的 RPC 使用 UDP（可靠或不可靠），因此向客户端发送大量体素的速度可能有限。相反，可以选择使用 TCP 发送块以及大型编辑。具有轻量级信息的小型编辑或确定性编辑可以继续使用可靠的 UDP。问题：您必须使用两个端口，一个用于UDP，一个用于TCP。因此，继续使用可靠的UDP也许是一个更好的主意。

Note: Minecraft's network protocol is entirely built on top of TCP.  
注意：Minecraft的网络协议完全建立在TCP之上。

## Other points to explore  
其他探索点

-   Block caching and versionning: save blocks client-side so the server doesn't have to send them again next time if they didn't change  
    块缓存和版本控制：在客户端保存块，这样服务器下次就不必在它们没有更改时再次发送它们
-   Client-requesting alternative model: having the client actively request blocks with custom code instead of passively receiving them from the server  
    客户端请求替代模型：让客户端主动请求带有自定义代码的块，而不是被动地从服务器接收它们
-   Block diffing: if it is acceptable for clients to know the world seed, instead of expecting clients to cache data (which requires the server to know what the client knows), store a diff map in voxel data server-side, 1-bit per voxel. Then if less than 30% of a block has changed, send only the difference and let the client fill the gaps.  
    块差异：如果客户端可以接受知道世界种子，而不是期望客户端缓存数据（这需要服务器知道客户端知道什么），而是在体素数据服务器端存储差异映射，每个体素 1 位。然后，如果不到 30% 的块发生了变化，则仅发送差额并让客户端填补空白。
