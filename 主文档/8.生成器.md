---
created: 2023-09-26T22:27:01 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/generators/
author: 
---

# Generators生成器

> ## Excerpt
> VoxelGenerator allows to generate voxels given a specific area in space, or from a single position. They can serve as a base to automate the creation of large landscapes, or can be used in a game to generate worlds. They have an important place because storing voxel data is expensive, while procedural sources are lightweight. VoxelGenerator 允许在空间中给定特定区域或从单个位置生成体素。它们可以作为自动创建大型景观的基础，也可以用于游戏中生成世界。它们占有重要地位，因为存储体素数据很昂贵，而程序源是轻量级的。

---
`VoxelGenerator` allows to generate voxels given a specific area in space, or from a single position. They can serve as a base to automate the creation of large landscapes, or can be used in a game to generate worlds. They have an important place because storing voxel data is expensive, while procedural sources are lightweight.  
`VoxelGenerator` 允许在空间中给定特定区域或从单个位置生成体素。它们可以作为自动创建大型景观的基础，也可以用于游戏中生成世界。它们占有重要地位，因为存储体素数据很昂贵，而程序源是轻量级的。

## How generators work 生成器如何工作

Generators currently run on the CPU and primarily work on blocks of voxels. For example, given a `VoxelBuffer` of 16x16x16 voxels, they decide what value each one will take. Using blocks makes it easier to split the work across multiple threads, and focus only on the area the player is located, especially if the world is infinite.  
生成器目前在 CPU 上运行，主要在体素块上工作。例如，给定 `VoxelBuffer` 16x16x16 个体素，他们决定每个体素将采用什么值。使用块可以更轻松地将工作拆分到多个线程中，并且只关注玩家所在的区域，尤其是在世界无限的情况下。

Voxel data is split into various channels, so depending on the kind of volume to generate, one or more different channels will be used. For example, a Minecraft generator will likely use the `TYPE` channel for voxel types, while a smooth terrain generator will use the `SDF` channel to fill in distance field values.  
体素数据分为不同的通道，因此根据要生成的体积类型，将使用一个或多个不同的通道。例如，Minecraft 生成器可能会将 `TYPE` 通道用于体素类型，而平滑地形生成器将使用 `SDF` 通道填充距离字段值。

Generators have a thread-safe API. The same generator `generate_block` method may be used by multiple threads at once. However, depending on the class, some parameters might only be modifiable from the main thread, so check the documentation to be sure.  
生成器具有线程安全的 API。同一个生成器 `generate_block` 方法可以同时由多个线程使用。但是，根据类的不同，某些参数可能只能从主线程修改，因此请查看文档以确保。

If a volume is not given a generator, blocks will be filled with air by default.  
如果没有为体积提供生成器，则默认情况下将用空气填充块。

## Basic generators 基本生成器

The module provides several built-in generators. They are simple examples to get a quick result, and showing how the base API can be implemented (see source code).  
该模块提供了几个内置生成器。它们是获得快速结果的简单示例，并展示了如何实现基本 API（请参阅源代码）。

Some of these generators have an option to choose which channel they will work on. If you use a smooth mesher, use the `SDF` channel (1), otherwise use the `TYPE` channel (0).  
其中一些发生器可以选择它们将在哪个频道上工作。如果使用平滑网格划分器，请使用通道 （1），否则使用 `SDF` `TYPE` 通道 （0）。

The following screenshots use a smooth `VoxelLodTerrain`.  
以下屏幕截图使用平滑 `VoxelLodTerrain` 的 .

### [Flat](https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorFlat/) 平面

Generates a flat ground.  
生成平坦的地面。

![Screenshot of flat generator](https://voxel-tools.readthedocs.io/en/latest/images/generator_flat.webp)

### [Waves](https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorWaves/) 波浪

Generates waves. 产生波浪。

![Screenshot of waves generator](https://voxel-tools.readthedocs.io/en/latest/images/generator_waves.webp)

### [Image](https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorImage/) 图片

Generates a heightmap based on an image, repeated infinitely.  
基于图像生成高度图，无限重复。

![Screenshot of image generator](https://voxel-tools.readthedocs.io/en/latest/images/generator_image.webp)

Note 注意

With this generator, an `Image` resource is required. By default, Godot imports image files as `StreamTexture`. You may change this in the Import dock. At time of writing, in Godot 3, this requires an editor restart.  
使用此生成器，需要资源 `Image` 。默认情况下，Godot 将图像文件导入为 `StreamTexture` .您可以在“导入”停靠栏中更改此设置。在撰写本文时，在Godot 3中，这需要重新启动编辑器。

### [Noise2D](https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorNoise2D/) 噪音2D

Generates a heightmap based on fractal noise.  
基于分形噪声生成高度贴图。

![Screenshot of 2D noise generator](https://voxel-tools.readthedocs.io/en/latest/images/generator_noise2d.webp)

### [Noise (3D)](https://voxel-tools.readthedocs.io/en/latest/api/VoxelGeneratorNoise/) 噪点 （3D）

Generates a blobby terrain with overhangs using 3D fractal noise. A gradient is applied along height so the volume becomes air when going up, and closes down into matter when going down.  
使用 3D 分形噪声生成具有悬垂的斑点地形。沿高度应用渐变，因此体积在上升时变成空气，并在下降时关闭成物质。

![Screenshot of 3D noise generator](https://voxel-tools.readthedocs.io/en/latest/images/generator_noise3d.webp)

## Node-graph generators (VoxelGraphs)  
节点图生成器 （体素图）

Basic generators may often not be suited to make a whole game from, but you don't necessarily need to program one. C++ is a very fast language to program a generator but it can be a tedious workflow, especially when prototyping. If you need smooth terrain, a graph-based generator is available, which offers a very customizable approach to make procedural volumes.  
基本的生成器通常可能不适合制作整个游戏，但您不一定需要编写一个。C++ 是一种非常快速的语言来编程生成器，但它可能是一个乏味的工作流程，尤其是在原型设计时。如果您需要平滑的地形，可以使用基于图形的生成器，它提供了一种非常可定制的方法来制作程序体积。

Warning 警告

This generator was originally made for smooth terrain, but works with blocky too, to some extent.  
该生成器最初是为平滑地形而设计的，但在某种程度上也适用于块状。

### Concept 概念

Voxel graphs allow to represent a 3D density by connecting operation nodes together. It takes 3D coordinates (X, Y, Z), and computes the value of every voxel from them. For example it can do a simple 2D or 3D noise, which can be scaled, deformed, masked using other noises, curves or even images.  
体素图允许通过将操作节点连接在一起来表示 3D 密度。它采用 3D 坐标（X、Y、Z），并从中计算每个体素的值。例如，它可以做一个简单的2D或3D噪声，可以使用其他噪声，曲线甚至图像进行缩放，变形，掩盖。

A big inspiration of this approach comes again from sculpting of signed-distance-fields (every voxel stores the distance to the nearest surface), which is why the main output node may be an `SdfOutput`. A bunch of nodes are meant to work on SDF as well. However, it is not strictly necessary to respect perfect distances, as long as the result looks correct for a game, so most of the time it's easier to work with approximations.  
这种方法的一大灵感再次来自有符号距离场的雕刻（每个体素存储到最近表面的距离），这就是为什么主输出节点可能是. `SdfOutput` 一堆节点也应该在SDF上工作。但是，只要结果对于游戏来说看起来是正确的，就不必严格尊重完美距离，因此大多数时候使用近似值更容易。

Note 注意

Voxel graphs are half-way between programming 3D shaders and procedural design. It has similar speed to C++ generators but has only basic instructions, so there are some maths involved. This might get eased a bit in the future when more high-level nodes are added.  
体素图介于编程 3D 着色器和程序设计之间。它的速度与C++发电机相似，但只有基本指令，因此涉及一些数学。将来添加更多高级节点时，这可能会有所缓解。

### Examples 示例

#### Flat plane 平面

The simplest possible graph with a visible output is a flat plane. The SDF of a flat plane is the distance to sea-level (0), which is `sdf = y`. In other words, the surface appears where voxel values are crossing zero.  
具有可见输出的最简单图形是平面。平面的 SDF 是到海平面的距离 （0），即 `sdf = y` 。换句话说，表面将显示在体素值与零交叉的位置。

Right-click the background of the graph, choose the nodes `InputY` and `SdfOutput`, then connect them together by dragging their ports together.  
右键单击图形的背景，选择节点 `InputY` 和 `SdfOutput` ，然后通过将它们的端口拖在一起将它们连接在一起。

![Plane voxel graph screenshot](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_flat.webp)

It is possible to decide the height of the plane by subtracting a constant (`sdf = y - height`), so that `sdf == 0` will occur at a higher coordinate. To do this, an extra node must be added:  
可以通过减去一个常数 （ `sdf = y - height` ） 来确定平面的高度，这样就会 `sdf == 0` 在更高的坐标处发生。为此，必须添加一个额外的节点：

![Offset plane voxel graph screenshot](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_flat_offset.webp)

By default, the `Add` node does nothing because its `b` port is not connected to anything. It is possible to give a default value to such port. You can set it by clicking on the node and changing it in the inspector.  
默认情况下， `Add` 节点不执行任何操作，因为它的 `b` 端口未连接到任何端口。可以为此类端口提供默认值。您可以通过单击节点并在检查器中进行更改来设置它。

(note: I used `Add` with a negative value for `b`, but you can also use a `Subtract` node to get the same result).  
（注意：我使用了 `Add` 负值 `b` ，但您也可以使用 `Subtract` 节点来获得相同的结果）。

#### Noise 噪音

A flat plane is simple but a bit boring, so one typical way to generate a terrain is adding good old fractal noise. You can do this in 2D (heightmap) or 3D (volumetric). The 2D approach is simpler, as we only need to take our previous setup, and add 2D noise to the result. Also, since noise is generated in the range \[-1 to 1\], we also need a multiplier to make it larger (`sdf = y - height + noise2d(x, y) * noise_multiplier`).  
平面很简单，但有点无聊，因此生成地形的一种典型方法是添加良好的旧分形噪声。您可以在 2D（高度贴图）或 3D（体积）中执行此操作。2D方法更简单，因为我们只需要采用以前的设置，并在结果中添加2D噪声。此外，由于噪声是在 \[-1 到 1\] 范围内产生的，我们还需要一个乘数来使其更大 （ `sdf = y - height + noise2d(x, y) * noise_multiplier` ）。

There are several types of noise available, each with their own parameters. At time of writing, `FastNoise2D` noise is the best option. `Noise2D` works too but it is slower and more limited (it uses Godot's `OpenSimplexNoise` class).  
有几种类型的噪声可用，每种都有自己的参数。在撰写本文时， `FastNoise2D` 噪音是最佳选择。 `Noise2D` 也可以工作，但它更慢，更有限（它使用戈多 `OpenSimplexNoise` 的类）。

Note 注意

After you create this node, a new `FastNoiseLite` resource must be created in its parameters. If that resource is not setup, an error will occur and no voxels will be generated.  
创建此节点后，必须在其参数中创建新 `FastNoiseLite` 资源。如果未设置该资源，则会发生错误，并且不会生成体素。

![Voxel graph 2D noise](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_noise2d.webp)

3D noise is more expensive to compute, but is interesting because it actually produces overhangs or even small caves. It is possible to replace 2D noise with 3D noise in the previous setup:  
3D噪声的计算成本更高，但很有趣，因为它实际上会产生悬垂甚至小洞穴。在以前的设置中，可以用 3D 噪声替换 2D 噪声：

![Voxel graph 3D noise](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_noise3d_not_expanded.webp)

You might notice that despite it being 3D, it still appears to produce a heightmap. That's because the addition of `Y` in the graph is gradually offsetting noise values towards higher and higher values when going towards the sky, which makes the surface fade away quickly. So if we multiply `Y` with a small value, it will increase slower, letting the 3D noise expand more (`sdf = y * height_multiplier - height + noise3d(x, y, z)`):  
您可能会注意到，尽管它是 3D 的，但它似乎仍然会产生高度图。这是因为在图表 `Y` 中添加的噪声值在朝向天空时会逐渐抵消到越来越高的值，这使得表面迅速消失。因此，如果我们 `Y` 乘以较小的值，它将增加得更慢，从而使 3D 噪声扩展得更多 （ `sdf = y * height_multiplier - height + noise3d(x, y, z)` ）：

![Voxel graph 3D noise expanded](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_noise3d_expanded.webp)

Note 注意

Some nodes have default connections. For example, with 3D noise, if you don't connect inputs, they will automatically assume (X,Y,Z) voxel position by default. If you need a specific constant in an input, this behavior can be opted out by turning off `autoconnect_default_inputs` in the inspector.  
某些节点具有默认连接。例如，对于 3D 噪声，如果不连接输入，默认情况下它们将自动采用 （X，Y，Z） 体素位置。如果需要输入中的特定常量，可以通过在检查器中关闭 `autoconnect_default_inputs` 来选择退出此行为。

#### Planet 星球

We are not actually forced to keep generating the world like a plane. We can go even crazier, and do planets. A good way to begin a planet is to make a sphere with the `SdfSphere` node:  
我们实际上并没有被迫像飞机一样不断创造世界。我们可以更疯狂，做行星。开始一个行星的一个好方法是用 `SdfSphere` 节点做一个球体：

![Voxel graph sdf sphere node](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_sphere.webp)

We cannot really use 2D noise here, so we can add 3D noise as well:  
我们在这里不能真正使用 2D 噪声，因此我们也可以添加 3D 噪声：

![Voxel graph sdf sphere with noise](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_sphere_with_noise.webp)

However you might still want a heightmap-like result. One way to do this is to feed the 3D noise normalized coordinates, instead of global ones. Picking a ridged fractal can also give an eroded look, although it requires to negate the noise multiplier node to invert its distance field (if we leave it positive it will look puffed instead of eroded).  
但是，您可能仍然想要类似高度图的结果。一种方法是输入 3D 噪声归一化坐标，而不是全局噪声归一化坐标。选择脊状分形也可以给出侵蚀的外观，尽管它需要否定噪声乘数节点以反转其距离场（如果我们将其保留为正值，它将看起来膨胀而不是侵蚀）。

![Voxel graph sdf sphere with height noise](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_sphere_with_noise2.webp)

Note 注意

You can obtain a donut-shaped planet if you replace the `SdfSphere` node with a `SdfTorus` node. ![Torus voxel graph](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_torus.webp)如果将节点替换为 `SdfSphere` `SdfTorus` 节点，则可以获得甜甜圈形状的行星。 ![Torus voxel graph](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_torus.webp) 

More techniques can be found in the [Procedural Generation](https://voxel-tools.readthedocs.io/en/latest/procedural_generation/) section.  
更多技术可以在过程生成部分找到。

### Usage with blocky voxels  
块状体素的使用

It is possible to use this generator with `VoxelMesherBlocky` by using an `OutputType` node instead of `OutputSDF`. However, `VoxelMesherBlocky` expects voxels to be IDs, not SDF values.  
可以通过使用 `OutputType` 节点而不是 `OutputSDF` 来使用此生成器。 `VoxelMesherBlocky` 但是，期望体素是 ID， `VoxelMesherBlocky` 而不是 SDF 值。

The simplest example is to pick any existing SDF generator, and replace `OutputSDF` with a `Select` node connected to an `OutputType`. The idea is to choose between the ID of two different voxel types (like air or stone) if the SDF value is above or below a threshold.  
最简单的示例是选取任何现有的 SDF 生成器，并替换为 `OutputSDF` `Select` 连接到 `OutputType` .这个想法是在 SDF 值高于或低于阈值时，在两种不同体素类型（如空气或石头）的 ID 之间进行选择。

![Example screenshot of a basic blocky heightmap made with a graph generator](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_blocky_basic_heightmap.webp)

If more variety is needed, `Select` nodes can be chained to combine multiple layers, using different thresholds and sources.  
如果需要更多种类，可以将节点链接起来， `Select` 使用不同的阈值和源组合多个层。

![Example screenshot of a blocky heightmap with two biomes made with a graph generator](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_blocky_biome.webp)

`Select` creates a "cut" between the two possible values, and it may be desirable to have some sort of transition. While this isn't possible with `VoxelMesherBlocky` without a lot of different types for each value of the gradient (usually done with a shader), it is however easy to add a bit of noise to the threshold. This reproduces a similar "dithered" transition, as can be seen in Minecraft between sand and dirt.  
`Select` 在两个可能的值之间创建一个“切口”，并且可能需要进行某种过渡。虽然对于渐变的每个值没有很多不同的类型（通常使用着色器完成），这是不可能的 `VoxelMesherBlocky` ，但是很容易在阈值中添加一些噪声。这再现了类似的“抖动”过渡，正如在《我的世界》中沙子和泥土之间所看到的那样。

![Example screenshot of a blocky heightmap with two biomes and dithering](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_blocky_biome_dithering.webp)

Currently, graph generators only work per voxel. That makes them good to generate base ground and biomes, but it isn't practical to generate structures like trees or villages with it. This may be easier to accomplish using a second pass on the whole block instead, using a custom generator.  
目前，图形生成器仅按体素工作。这使得它们非常适合生成基础地面和生物群落，但用它生成树木或村庄等结构是不切实际的。使用自定义生成器在整个块上使用第二次传递可能更容易实现。

### Relays 继电器

A special `Relay` node exists to organize long connections between nodes. They do nothing on their own, they just redirect a connection. It also remains possible for a relay to have multiple destinations.  
存在一个特殊 `Relay` 节点来组织节点之间的长连接。他们自己什么都不做，他们只是重定向连接。中继也可能有多个目的地。

![Screenshot of a relay node](https://voxel-tools.readthedocs.io/en/latest/images/relay_node.webp)

## Custom generator 自定义生成器

See [Scripting](https://voxel-tools.readthedocs.io/en/latest/scripting/) 请参阅脚本

## Using `VoxelGeneratorGraph` as a brush  
用作 `VoxelGeneratorGraph` 画笔

This feature is currently only supported in `VoxelLodTerrain` and smooth voxels.  
此功能目前仅在平滑体素中 `VoxelLodTerrain` 受支持。

`VoxelTool` offers simple functions to modify smooth terrain with `do_sphere` for example, but it is also possible to define procedural custom brushes using `VoxelGeneratorGraph`. The same workflow applies to making such a graph, except it can accept an `InputSDF` node, so the signed distance field can be modified, not just generated.  
`VoxelTool` 例如，提供了修改平滑地形 `do_sphere` 的简单功能，但也可以使用 `VoxelGeneratorGraph` 定义程序自定义画笔。相同的工作流程也适用于制作这样的图形，只是它可以接受节点 `InputSDF` ，因此可以修改带符号的距离字段，而不仅仅是生成。

Example of additive `do_sphere` recreated with a graph:  
使用图形重新创建的添加剂 `do_sphere` 示例：

![Additive sphere brush graph](https://voxel-tools.readthedocs.io/en/latest/images/graph_sphere_brush.webp)

A more complex flattening brush, which both subtracts matter in a sphere and adds matter in a hemisphere to form a ledge (here defaulting to a radius of 30 for better preview, but making unit-sized brushes may be easier to re-use):  
更复杂的扁平画笔，既减去球体中的物质，又增加半球中的物质以形成壁架（此处默认半径为 30 以获得更好的预览，但制作单位大小的画笔可能更容易重复使用）：

![Dual flattening brush](https://voxel-tools.readthedocs.io/en/latest/images/graph_flatten_brush.webp)

One more detail to consider, is how big the original brush is. Usually voxel generators have no particular bounds, but it matters here because it will be used locally. For example if your make a spherical brush, you might use a `SdfSphere` node with radius `1`. Then, your original size will be `(2,2,2)`. You can then transform that brush (scale, rotate...) when using `do_graph` at the desired position.  
另一个需要考虑的细节是原始画笔有多大。通常体素生成器没有特定的界限，但在这里很重要，因为它将在本地使用。例如，如果您制作一个球形画笔，则可以使用 `SdfSphere` 半径 `1` 为 .然后，您的原始大小将是 `(2,2,2)` .然后，您可以在所需位置使用 `do_graph` 时变换该画笔（缩放、旋转...）。

## Re-usable graphs with `VoxelGraphFunction`  
可重复使用的图形与 `VoxelGraphFunction`

`VoxelGraphFunction` allows to create graphs that can be used inside other graphs. This is a convenient way to re-use and share graphs.  
`VoxelGraphFunction` 允许创建可以在其他图形中使用的图形。这是重用和共享图形的便捷方法。

### Creating a function 创建函数

A `VoxelGraphFunction` can be created in the inspector and edited just like a `VoxelGeneratorGraph`, except it will lack some features only found on the latter. It is recommended to save functions as their own `.tres` files, because this is what allows to pick them up in other graphs.  
A `VoxelGraphFunction` 可以在检查器中创建并像 一样 `VoxelGeneratorGraph` 进行编辑，只是它缺少一些仅在后者上找到的功能。建议将函数保存为自己的 `.tres` 文件，因为这是允许在其他图形中拾取它们的原因。

Note 注意

A `VoxelGraphFunction` cannot contain itself, directly or indirectly. Doing this will result in Godot failing to load it.  
A `VoxelGraphFunction` 不能直接或间接地包含自身。这样做将导致戈多无法加载它。

### Exposing inputs and outputs  
公开输入和输出

To be usable in other graphs, functions should have inputs and outputs. Inputs can be added to the function by creating nodes `InputX`, `InputY`, `InputZ`, `InputSDF` or `CustomInput`. Outputs can be added by creating nodes `OutputX`, `OutputY`, `OutputZ`, `CustomOutput` etc.  
为了可以在其他图形中使用，函数应该有输入和输出。可以通过创建节点 `InputX` 、 `InputY` `InputZ` 、 `InputSDF` 或 `CustomInput` 来将输入添加到函数中。可以通过创建节点 `OutputX` 、、 `OutputZ` 、 `OutputY` 等 `CustomOutput` 来添加输出。

However, an extra step is necessary to expose those inputs and outputs to external users of the function. To expose them, select the graph (or click in the background if opened already), go to the inspector, and click `Edit input/outputs`.  
但是，需要额外的步骤才能向函数的外部用户公开这些输入和输出。要显示它们，请选择图形（如果已打开，则在后台单击），转到检查器，然后单击 `Edit input/outputs` 。

![Screenshot of the function input/output editor dialog](https://voxel-tools.readthedocs.io/en/latest/images/function_io_dialog.webp)

Currently, defining manually exposed inputs and outputs isn't supported, but is planned. You may instead click on `Auto-generate`, which will find nodes automatically and expose them as inputs and outputs. This also defines the order in which they will be exposed.  
目前，不支持定义手动公开的输入和输出，但已计划。您可以改为单击 `Auto-generate` ，这将自动找到节点并将它们公开为输入和输出。这也定义了它们的公开顺序。

Non-custom inputs and outputs such as `InputX` or `OutputX` are _special_ nodes, and are identified by their type. They are recognized by the engine for specific purposes. You can have multiple nodes with the same type, but they will always refer to the same input of the function.  
非自定义输入和输出（如 `InputX` or `OutputX` ）是特殊节点，由其类型标识。它们被引擎识别用于特定目的。您可以有多个具有相同类型的节点，但它们将始终引用函数的相同输入。

Custom inputs and outputs _are identified by their name_. If you add 2 `CustomInput` nodes and give them the same name, they will get their data from the same input. It is recommended to give a name to custom input and output nodes. Empty names still count as a name (so multiple `CustomInput` without names will refer to the same unnamed input).  
自定义输入和输出由其名称标识。如果添加 2 个 `CustomInput` 节点并为其指定相同的名称，它们将从相同的输入中获取数据。建议为自定义输入和输出节点命名。空名称仍算作一个名称（因此多个 `CustomInput` 没有名称的名称将引用相同的未命名输入）。

Multiple special inputs or inputs with the same type is not allowed. Multiple custom inputs or outputs with the same name is not allowed.  
不允许多个特殊输入或相同类型的输入。不允许使用多个自定义输入或同名输出。

### Exposing parameters 公开参数

Currently parameters cannot be exposed, but it is planned.  
目前参数无法公开，但已计划。

### Handling changes 处理更改

When an existing function changes (new/removed inputs/outputs for example), it is possible that other graphs using it will break. If you try to open them, some of the nodes and connections could be missing.  
当现有函数发生变化（例如，新的/删除的输入/输出）时，使用它的其他图形可能会中断。如果尝试打开它们，则可能会丢失某些节点和连接。

Currently, you are expected to fix these graphs, and save them. You can also change the offending function so that its inputs, outputs and parameters are what you expect. However if you save a broken graph, you might loose some connections or nodes.  
目前，您需要修复这些图形并保存它们。您还可以更改有问题的函数，使其输入、输出和参数符合您的期望。但是，如果保存损坏的图形，则可能会丢失某些连接或节点。

### Debugging 调试

Editor tools such as profiling, output previews or range analysis are currently unsupported inside a `VoxelGraphFunction`. It is also not possible to inspect internal nodes of a function when editing a `VoxelGeneratorGraph`.  
编辑器工具（如性能分析、输出预览或范围分析）目前在 中 `VoxelGraphFunction` 不受支持。编辑 `VoxelGeneratorGraph` .

It is planned to have these tools available when editing a standalone `VoxelGraphFunction` in the future. This will be done by moving features out of `VoxelGeneratorGraph` so they become more generic.  
计划在将来编辑独立文件 `VoxelGraphFunction` 时提供这些工具。这将通过将功能移出 `VoxelGeneratorGraph` 以使其变得更加通用来完成。

Inspecting a function "instance" (and sub-instances...) may be desirable, but it is tricky to implement. It could be done as an "Open Inside" feature, to inspect data within the context of the "containing graph". However because functions are fully unpacked and optimized out internally, the engine has to trace back the information to original nodes. Tracing is already present to some degree, but only maps the "top-level" graph to fully-expanded/optimized graph, with no in-between information. This might be worked on further in the future.  
检查函数“实例”（和子实例...）可能是可取的，但实现起来很棘手。它可以作为“内部开放”功能来完成，以检查“包含图”上下文中的数据。但是，由于函数在内部完全解包和优化，因此引擎必须将信息追溯到原始节点。跟踪在某种程度上已经存在，但仅将“顶级”图映射到完全扩展/优化的图，没有中间信息。将来可能会进一步研究这个问题。

### VoxelGeneratorGraph nodes  
体素生成器图节点

A complete list of nodes [can be found here](https://voxel-tools.readthedocs.io/en/latest/graph_nodes/).  
可以在此处找到节点的完整列表。

## Modifiers 修饰符

Modifiers are generators that affect a limited region of the volume. They can stack on top of base generated voxels or other modifiers, and affect the final result. This is a workflow that mostly serves if your world has a finite size, and you want to set up specific shapes of the landscape in a non-destructive way from the editor.  
修饰符是影响体积有限区域的生成器。它们可以堆叠在基本生成的体素或其他修饰符之上，并影响最终结果。当您的世界大小有限，并且您希望从编辑器中以非破坏性方式设置特定的景观形状时，这是一个工作流程。

Note 注意

This feature is only implemented with `VoxelLodTerrain` at the moment, and only works to sculpt smooth voxels. It is in early stages so it is quite limited.  
此功能目前仅通过 实现 `VoxelLodTerrain` ，并且仅适用于雕刻平滑体素。它处于早期阶段，因此非常有限。

Modifiers can be added with nodes as child of the terrain. `VoxelModifierSphere` adds or subtracts a sphere, while `VoxelModifierMesh` adds or subtracts a mesh. For the latter, the mesh must be baked into an SDF volume first, using the `VoxelMeshSDF` resource.  
可以将修改器与节点一起添加为地形的子项。 `VoxelModifierSphere` 添加或减去球体，同时 `VoxelModifierMesh` 添加或减去网格。对于后者，必须首先使用 `VoxelMeshSDF` 资源将网格烘焙到 SDF 体积中。

Because modifiers are part of the procedural generation stack, destructive edits will always override them. If a block is edited, modifiers cannot affect it. It is then assumed that such edits would come from players at runtime, and that modifiers don't change.  
由于修饰符是程序生成堆栈的一部分，因此破坏性编辑将始终覆盖它们。如果编辑了块，则修饰符不会影响它。然后假设此类编辑将在运行时来自玩家，并且修饰符不会更改。

## Caching 缓存

Generators are designed to be deterministic: if the same area is generated twice, the result must be the same. This means, ultimately, we only need to store edited voxels (aka "destructive" editing), while non-edited regions can be recomputed on the fly. Even if you want to access one voxel and it happens to be in a non-edited location, then the generator will be called just to obtain that voxel.  
生成器被设计为确定性的：如果同一区域生成两次，则结果必须相同。这意味着，最终，我们只需要存储编辑的体素（又名“破坏性”编辑），而未编辑的区域可以动态重新计算。即使您想要访问一个体素并且它恰好位于未编辑的位置，也会调用生成器以获取该体素。

However, if a generator is too expensive or not expected to run this way, it may be desirable to store the output in memory so that querying the same area again picks up the cached data.  
但是，如果生成器太昂贵或预计不会以这种方式运行，则可能需要将输出存储在内存中，以便再次查询同一区域以获取缓存的数据。

By default, `VoxelTerrain` caches blocks in memory until they get far from any viewer. `VoxelLodTerrain` does not cache blocks by default. There is no option yet to change that behavior. It is also possible to tell a `VoxelGenerator` to save its outputs to the current `VoxelStream`, if any is setup. However, these blocks will act as edited ones, so they will behave as if it was changes done destructively.  
默认情况下，将块缓存在内存中， `VoxelTerrain` 直到它们远离任何查看器。 `VoxelLodTerrain` 默认情况下不缓存块。目前还没有改变这种行为的选项。也可以告诉 a `VoxelGenerator` 将其输出保存到当前 `VoxelStream` ，如果有的话。但是，这些块将充当编辑过的块，因此它们的行为就像是破坏性的更改一样。
