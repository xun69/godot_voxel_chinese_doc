---
created: 2023-09-26T22:29:23 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/module_development/
author: 
---

# Module development模块开发

> ## Excerpt
> This page will give some info about the module's internals.此页面将提供有关模块内部的一些信息。

---
This page will give some info about the module's internals.  
此页面将提供有关模块内部的一些信息。

The source code of the module can be found on [Github](https://github.com/Zylann/godot_voxel).  
该模块的源代码可以在Github上找到。

## Contributing 贡献

To contribute to the module, you need to clone the repo using [Git](https://git-scm.com/), and create your branch on Github so you'll be able to make Pull Requests.  
要为模块做出贡献，您需要使用 Git 克隆存储库，并在 Github 上创建分支，以便能够发出拉取请求。

### C++ code C++代码

It is recommended to read the **Engine Development** section on the official [Godot Documentation](https://docs.godotengine.org/en/stable/). It explains how to compile the engine, setup an IDE and how custom modules are made.  
建议阅读官方 Godot 文档中的引擎开发部分。它解释了如何编译引擎、设置 IDE 以及如何创建自定义模块。

For code guidelines related to Voxel Tools, see [Code Guidelines](https://voxel-tools.readthedocs.io/en/latest/module_development/#code-guidelines)  
有关与体素工具相关的代码指南，请参阅代码指南

### Main documentation 主要文档

The documentation is written using Markdown, formatted using [Mkdocs](https://www.mkdocs.org/) and made available as a website on [ReadTheDocs](https://readthedocs.org/).  
该文档是使用Markdown编写的，使用Mkdocs格式化，并作为ReadTheDocs上的网站提供。

To contribute to the main pages, make your change to `.md` files located under the `doc/docs` folder, and post a PR on Github.  
要为主页做出贡献，请对 `doc/docs` 文件夹下的文件进行更改 `.md` ，并在 Github 上发布 PR。

### API documentation API 文档

To contribute to the class reference (API), you may edit XML files under `doc/classes` instead, similarly to how it's done for regular Godot modules or core classes.  
为了贡献类引用 （API），您可以改为在 下 `doc/classes` 编辑 XML 文件，类似于对常规 Godot 模块或核心类所做的那样。

After an XML file has been changed, it can be converted into its Markdown counterpart by using the `build.py` script in `doc/tools`, using this command:  
更改 XML 文件后，可以使用以下命令使用 中的 `build.py` `doc/tools` 脚本将其转换为其 Markdown 对应项：

`build.py` has other arguments to do other things. If you run it without arguments, help will be printed.  
`build.py` 有其他论据可以做其他事情。如果在没有参数的情况下运行它，将打印帮助。

### Graph nodes documentation  
图节点文档

Graph nodes of \[VoxelGeneratorGraph\] are currently not represented with Godot classes. Therefore they use their own documentation in an XML file, using a workflow similar to classes. The XML file is the single souce of truth for node descriptions and categories shown in the editor, as well as the online documentation.  
\[VoxelGeneratorGraph\] 的图节点目前没有用 Godot 类表示。因此，他们在 XML 文件中使用自己的文档，使用类似于类的工作流。XML 文件是编辑器以及在线文档中显示的节点描述和类别的唯一事实来源。

The XML file can be generated or updated from nodes present in the engine by running Godot with the following argument:  
XML文件可以通过使用以下参数运行Godot来从引擎中存在的节点生成或更新：

`--voxel_doc_tool src dst`

Where `src` is a path to the original XML, and `dst` is a path to write the updated XML. Both paths can be the same. This XML file should be already versionned under `doc/graph_nodes.xml`.  
其中 `src` 是原始 XML 的路径， `dst` 是写入更新的 XML 的路径。两条路径可以相同。此 XML 文件应已在 下 `doc/graph_nodes.xml` 进行版本控制。

The XML file can then be used to generate several documentations:  
然后，可以使用 XML 文件生成多个文档：

-   The Markdown documentation, appearing on the website  
    Markdown 文档，出现在网站上
-   The C++ documentation, appearing in the editor  
    C++文档，显示在编辑器中

Both are generated by running the script `graph_nodes_doc.py` from inside `doc/tools/`.  
两者都是通过从内部 `doc/tools/` 运行脚本 `graph_nodes_doc.py` 生成的。

## Layers 图层

### Main layers 主要层

This module has 3 main layers:  
该模块有 3 个主要层：

-   Voxel: the voxel engine. Wrapped into `zylann::voxel::` namespace.  
    体素：体素引擎。包装到命名空间中 `zylann::voxel::` 。
-   Util: library of functions, helpers and data structures, which does not depend on Voxel. Wrapped into `zylann::` namespace.  
    Util：函数、助手和数据结构库，不依赖于体素。包装到命名空间中 `zylann::` 。
-   Thirdparty: third-party libraries.  
    第三方：第三方库。

### Folders 文件夹

The module is divided in several folders, each with different dependencies. Because of this, it is possible to use `VoxelMesher`, `VoxelGenerator` or `VoxelStream` standalone, without needing to use a `VoxelTerrain` node for example.  
该模块分为多个文件夹，每个文件夹都有不同的依赖项。因此，可以使用 ，或 `VoxelStream` 独立使用 `VoxelMesher` ， `VoxelGenerator` 而无需使用 `VoxelTerrain` 节点。

| Directory 目录 | Description 描述 |
| --- | --- |
| constants/ 常数/ | Constants and lookup tables used throughout the engine.  
整个引擎中使用的常量和查找表。 |
| doc/ .doc/ | Contains documentation 包含文档 |
| edition/ 版/ | High-level utilities to access and modify voxels. May depend on voxel nodes.  
用于访问和修改体素的高级实用程序。可能取决于体素节点。 |
| editor/ 编辑 器/ | Editor-specific code. May also depend on voxel nodes.  
特定于编辑器的代码。也可能取决于体素节点。 |
| engine/ 发动机/ | Contains task management. Depends on meshers, streams, storage but not directly on nodes.  
包含任务管理。依赖于网格器、流、存储，但不直接依赖于节点。 |
| generators/ 发电机/ | Procedural generators. They only depend on voxel storage and math.  
程序生成器。它们仅依赖于体素存储和数学。 |
| meshers/ 网格划分/ | Only depends on voxel storage, math and some Godot graphics APIs.  
仅依赖于体素存储、数学和一些 Godot 图形 API。 |
| misc/ 杂项/ | Various scripts and configuration files, stored here to avoid cluttering the main folder.  
各种脚本和配置文件，存储在这里以避免主文件夹混乱。 |
| modifiers/ 修饰 符/ | Files related to the modifiers feature.  
与修饰符功能相关的文件。 |
| shaders/ 着色/ | Shaders used internally by the engine, both in text form and formatted C++ form.  
引擎内部使用的着色器，包括文本形式和格式化C++形式。 |
| storage/ 存储/ | Storage and memory data structures.  
存储和内存数据结构。 |
| streams/ 流/ | Files handling code. Only depends on filesystem and storage.  
文件处理代码。仅取决于文件系统和存储。 |
| terrain/ 地形/ | Contains all the nodes. Depends on the rest of the module, except editor-only parts.  
包含所有节点。取决于模块的其余部分，但仅编辑器部分除外。 |
| tests/ 测试/ | Contains tests. These run when Godot starts if enabled in the build script.  
包含测试。如果在构建脚本中启用，则当 Godot 启动时，它们会运行。 |
| thirdparty/ 第三方/ | Third-party libraries, in source code form. They are compiled statically so Godot remains a single executable.  
第三方库，源代码形式。它们是静态编译的，因此Godot仍然是一个可执行文件。 |
| util/ 实用/ | Generic utility functions and structures. They don't depend on voxel stuff.  
通用实用程序函数和结构。他们不依赖于体素的东西。 |

### Code 代码

In addition to layers reflected by the folder structure, there is an implicit distinction between Godot and this module: if a piece of code does not need to depend on Godot, then it will tend to not depend on Godot.  
除了文件夹结构所反映的层之外，Godot 和这个模块之间还有一个隐含的区别：如果一段代码不需要依赖 Godot，那么它往往不依赖于 Godot。

For example, the _implementation_ of Transvoxel has very little dependencies on Godot. Indeed, it doesn't care what a resource is, doesn't need Variant, doesnt need bindings, doesn't need to use OOP etc. That's why the _mesher resource_ does not contain the _logic_, but instead acts as a "bridge" between the algorithm and its usage within Godot.  
例如，Transvoxel的实现对Godot的依赖性很小。事实上，它不关心资源是什么，不需要变体，不需要绑定，不需要使用 OOP 等。这就是为什么网格资源不包含逻辑，而是充当算法与其在Godot中的使用之间的“桥梁”。

Same for `VoxelBuffer`: this class is actually not a full-fledged Godot object. It is much lighter than that, because it can have thousands of instances, or even supports being allocated on the stack and moved. It is exposed as a wrapper object instead for the few cases where scripters have to interact with it.  
同样适用于 `VoxelBuffer` ：这个类实际上不是一个成熟的戈多对象。它比这轻得多，因为它可以有数千个实例，甚至支持在堆栈上分配和移动。在脚本编写者必须与之交互的少数情况下，它作为包装器对象公开。

## Tests 测试

Tests are not mandatory, but if there is time to make new ones, it's good to have.  
测试不是强制性的，但如果有时间进行新的测试，那就太好了。

The module recently includes a `tests/` folder, which contains unit tests. At time of writing, there are very few of them, and I still don't write new ones often. As a game developer, writing unit tests for everything isn't part of my habits, but I recognize that for a module like this one, it is always better to have some if a feature can be easily tested. It even helped fix a few bugs already.  
该模块最近包含一个 `tests/` 文件夹，其中包含单元测试。在撰写本文时，它们很少，我仍然不经常写新的。作为一名游戏开发人员，为所有内容编写单元测试并不是我习惯的一部分，但我认识到，对于像这样的模块，如果可以轻松测试功能，最好有一些。它甚至已经帮助修复了一些错误。

No test framework is used at the moment, instead they just run by either printing an error when they fail or not. In Godot 4 the Doctest framework is used, so we may see if we can migrate to that later.  
目前没有使用测试框架，相反，它们只是通过在失败或不失败时打印错误来运行。在Godot 4中使用了Doctest框架，因此我们可以看看以后是否可以迁移到该框架。

## Threads 线程

The module uses several background threads to process voxels. The number of threads can be adjusted in Project Settings.  
该模块使用多个后台线程来处理体素。线程数可以在项目设置中调整。

![Schema of threads](https://voxel-tools.readthedocs.io/en/latest/images/threads_schema.webp)

There is one pool of threads. This pool can be given many tasks and distributes them to all its threads. So the more threads are available, the quicker large amounts of tasks get done. Tasks are also sorted by priority, so for example updating a mesh near a player will run before generating a voxel block 300 meters away.  
有一个线程池。可以给这个池分配许多任务，并将它们分发到它的所有线程。因此，可用的线程越多，大量任务的完成速度就越快。任务也按优先级排序，因此例如，在生成 300 米外的体素块之前，将运行更新玩家附近的网格。

Some tasks are scheduled in a "serial" group, which means only one of them will run at a time (although any thread can run them). This is to avoid clogging up all the threads with waiting tasks if they all lock a shared resource. This is used for I/O such as loading and saving to disk.  
某些任务计划在“串行”组中，这意味着一次只能运行其中一个任务（尽管任何线程都可以运行它们）。这是为了避免在等待任务都锁定共享资源时阻塞所有线程。这用于 I/O，例如加载和保存到磁盘。

Threads are managed in [VoxelEngine](https://voxel-tools.readthedocs.io/en/latest/api/VoxelEngine/).  
线程在体素引擎中进行管理。

Note: this task system does not account for "frames". Tasks can run at any time for less or more than one frame of the main thread.  
注意：此任务系统不考虑“框架”。任务可以随时运行少于或多个主线程的帧。

## Code guidelines 代码准则

### Syntax 语法

For the most part, use `clang-format` and follow Godot conventions.  
在大多数情况下，使用 `clang-format` 并遵循戈多惯例。

-   Class and struct names `PascalCase`  
    类和结构名称 `PascalCase`
-   Constants, enums and macros `CAPSLOCK_CASE`  
    常量、枚举和宏 `CAPSLOCK_CASE`
-   Other names `snake_case` 其他名称 `snake_case`
-   Globals prefixed with `g_`  
    前缀为 `g_`
-   Statics prefixed with `s_`  
    前缀为 的 `s_` 静态
-   Thread-locals prefixed with `tls_`  
    以 `tls_`
-   Parameters prefixed with `p_`, but not really enforced so far. Matters for big functions.  
    以 为 `p_` 前缀的参数，但到目前为止尚未真正强制执行。大功能很重要。
-   Private and protected fields prefixed with `_`  
    前缀为 的 `_` 私有和受保护字段
-   Some private functions start with `_`, either to mimic Godot API, or if it's a re-used function that performs no checks  
    一些私有函数以 开头 `_` ，要么是为了模仿 Godot API，要么是不执行检查的重用函数
-   Signal handler functions are prefixed with `_on_` and should never be called manually  
    信号处理程序函数以 为 `_on_` 前缀，绝不应手动调用
-   Enums prefixed by their name. Example: `enum Type { TYPE_ONE, TYPE_TWO }`  
    以名称为前缀的枚举。例： `enum Type { TYPE_ONE, TYPE_TWO }`
-   Open braces at the end of line, close them next line  
    行尾左大括号，下行闭合
-   Never omit braces 从不省略大括号
-   Space between binary operators and control flow: `if (a + b == 42)`  
    二进制运算符和控制流之间的空间： `if (a + b == 42)`
-   Indent with tabs 使用制表符缩进
-   Private wrapper functions can be used to adapt to the script API and are prefixed with `_b_`.  
    私有包装器函数可用于适应脚本 API，并以 `_b_` .
-   Use Clang-format to automate most of these rules (there should be a file included at the root of the C++ project)  
    使用 Clang-format 来自动化大多数这些规则（C++项目的根目录应该包含一个文件）
-   Prefer comments with `//` only  
    首选仅包含评论的评论 `//`
-   Some virtual functions from wrapper classes are prefixed with `_zn_` to encapsulate signature differences when compiling as a module or as a GDExtension.  
    包装类中的某些虚拟函数带有前缀 `_zn_` ，以便在编译为模块或 GDExtension时封装签名差异。

### File structure 文件结构

-   Use `.h` for headers and `.cpp` for implementation files.  
    用于 `.h` 标头和 `.cpp` 实现文件。
-   File names use `snake_case`.  
    文件名使用 `snake_case` .
-   Constructors and destructors go on top  
    构造函数和析构函数位于顶部
-   Public API goes on top, private stuff goes below  
    公共 API 在上面，私有的东西在下面
-   Bindings go at the bottom.  
    绑定位于底部。
-   Avoid long lines. Preferred maximum line length is 120 characters. Don't fit too many operations on the same line, use locals.  
    避免排长队。首选的最大行长度为 120 个字符。不要在同一条线上安装太多操作，请使用局部变量。
-   Defining types or functions in `.cpp` may be better for compilation times than in header if they are internal.  
    如果 `.cpp` 类型或函数是内部的，则在编译时间中定义类型或函数可能比在标头中定义类型或函数更好。

### C++ features C++功能

-   Don't use `auto` unless the type is impossible to express or a long template (like STL ones). IDEs aren't granted (Github reviews and diffs)  
    除非类型无法表达或模板较长（如 STL 模板），否则不要使用 `auto` 。未授予 IDE（Github 审查和差异）
-   Moderate use of lambdas and functors are fine. Not `std::function`.  
    适度使用 lambda 和函子是可以的。不是 `std::function` .
-   Lambda captures should be defined explicitely (try to reduce usage of `[=]` or `[&]`)  
    应明确定义 Lambda 捕获（尝试减少 或 `[&]` 的使用 `[=]` ）
-   STL is ok if it measurably performs better than Godot alternatives.  
    如果STL的表现明显优于Godot替代品，那么它就可以了。
-   Initialize variables next to declaration  
    初始化声明旁边的变量
-   Avoid using macros to define logic or constants. Prefer `static const`, `constexpr` and `inline` functions.  
    避免使用宏来定义逻辑或常量。首选 `static const` 和 `constexpr` `inline` 函数。
-   Prefer adding `const` to variables that won't change after being initialized (function arguments are spared for now as it would make signatures very long)  
    更喜欢添加到 `const` 初始化后不会更改的变量（暂时保留函数参数，因为它会使签名很长）
-   Don't exploit booleanization when an explicit alternative exists. Example: use `if (a == nullptr)` instead of `if (!a)`  
    当存在显式替代项时，不要利用布尔化。示例：使用 `if (a == nullptr)` 代替 `if (!a)`
-   If possible, avoid plain arrays like `int a[42]`. Debuggers don't catch overruns on them. Prefer using wrappers such as `FixedArray` and `Span` (or `std::array` and `std::span` once [this](https://github.com/godotengine/godot/issues/31608) is fixed)  
    如果可能，请避免使用纯数组，例如 `int a[42]` 。调试器不会捕获它们的溢出。更喜欢使用包装器，例如 `FixedArray` 和 `Span` （或 `std::array` 一旦 `std::span` 修复）
-   Use `uint32_t`, `uint16_t`, `uint8_t` in case integer size matters.  
    使用 `uint32_t` ， ， `uint16_t` `uint8_t` 以防整数大小很重要。
-   If possible, use forward declarations in headers instead of including files  
    如果可能，请在标头中使用前向声明，而不是包含文件
-   Don't do `using namespace` in headers (Except with `godot::`, but that's only to help supporting GDExtension using the same codebase, since Godot core does not have this namespace).  
    不要在标头中做 `using namespace` （除了 ，但这只是为了帮助支持使用相同的代码库的 GDExtension `godot::` ，因为 Godot 核心没有这个命名空间）。
-   `mutable` must ONLY be used for thread synchronization primitives. Do not use it with "cache data" to make getters `const`, as it can be misleading in multi-threaded context.  
    `mutable` 只能用于线程同步原语。不要将它与“缓存数据”一起使用来制作getter `const` ，因为它在多线程上下文中可能会产生误导。
-   No use of exceptions  
    不使用例外

### Error handling 错误处理

-   Exceptions are not used.  
    不使用例外。
-   Check invariants, fail early. Use `CRASH_COND` or `ZN_ASSERT` in debug mode to make sure states are as expected even if they don't cause immediate harm.  
    检查不变量，尽早失败。使用 `CRASH_COND` 或 `ZN_ASSERT` 在调试模式下确保状态符合预期，即使它们不会立即造成伤害。
-   Crashes aren't nice to users, so in user-facing code (scripting) use `ERR_FAIL_COND` or `ZN_ASSERT_RETURN` macros for code that can recover from error, or to prevent hitting internal assertions  
    崩溃对用户来说并不好，因此在面向用户的代码（脚本）中使用宏 `ZN_ASSERT_RETURN` 来获取 `ERR_FAIL_COND` 可以从错误中恢复的代码，或防止命中内部断言
-   Macros prefixed with `ZN_` are Godot-agnostic and may be used for portability in areas that don't depend on Godot too much.  
    前缀为 Godot 的宏与 Godot 无关，可用于不太依赖 Godot `ZN_` 的区域的可移植性。

### Performance 性能

In performance-critical areas which run a lot:  
在运行频繁的性能关键领域：

-   Avoid allocations. Re-use memory with memory pools, `ObjectPool`, fixed-size arrays or use `std::vector` capacity.  
    避免分配。通过内存池、 `ObjectPool` 固定大小的阵列或使用 `std::vector` 容量重复使用内存。
-   Avoid `virtual`, `Ref<T>`, `String`  
    避免 `virtual` 、 、 `Ref<T>` `String`
-   Don't resize `PoolVectors` or `Vector<T>`, or do it in one go if needed  
    不要调整大小 `PoolVectors` 或 `Vector<T>` ，或者如果需要，一次性完成
-   Careful about what is thread-safe and what isn't. Some major areas of this module work within threads.  
    注意什么是线程安全的，什么是不是。此模块的一些主要区域在线程中工作。
-   Reduce mutex locking to a minimum, and avoid locking for long periods.  
    将互斥锁减少到最低限度，避免长时间锁定。
-   Use data structures that are fit to the most frequent use over time (will often be either array, vector or hash map).  
    使用适合随时间推移最频繁使用的数据结构（通常是数组、向量或哈希映射）。
-   Consider statistics if their impact is negligible. It helps users to monitor how well the module performs even in release builds.  
    如果统计数据的影响可以忽略不计，请考虑统计数据。它可以帮助用户监控模块的性能，即使在发布版本中也是如此。
-   Profile your code, in release mode. This module is Tracy-friendly, see `util/profiling.hpp`.  
    在发布模式下分析代码。此模块对 Tracy 友好，请参阅 `util/profiling.hpp` 。
-   Care about alignment when making data structures. For exmaple, pack fields smaller than 4 bytes so they use space better  
    在制作数据结构时要注意对齐。例如，打包小于 4 个字节的字段，以便更好地利用空间

### Godot API 戈多 API

-   In areas where performance matters, use the most direct APIs for the job. Especially, don't use nodes. See `RenderingServer` and `PhysicsServer`.  
    在性能很重要的领域，使用最直接的 API 来完成作业。特别是，不要使用节点。请参阅 `RenderingServer` 和 `PhysicsServer` 。
-   Only expose a function to the script API if it is safe to use and guaranteed to remain present for a while  
    仅当函数可以安全使用并保证存在一段时间时，才向脚本 API 公开函数
-   When possible, use `memnew`, `memdelete`, `memalloc` and `memfree` so memory usage is counted within Godot monitors  
    如果可能，请使用 `memnew` 、 `memdelete` 等 `memalloc` `memfree` ，以便在 Godot 监视器中计算内存使用量
-   Don't leave random prints. For verbose mode you may also use `ZN_PRINT_VERBOSE()` instead of `print_verbose()`.  
    不要留下随机打印。对于详细模式，您也可以使用 `ZN_PRINT_VERBOSE()` `print_verbose()` 代替 。
-   Use `int` as argument for functions exposed to scripts if they don't need to exceed 2^31, even if they are never negative, so errors are clearer if the user makes a mistake  
    如果脚本不需要超过 2^31，则用作 `int` 脚本公开的函数的参数，即使它们从不为负数，因此如果用户犯了错误，错误会更清晰
-   If possible, keep Godot usage to a minimum, to make the code more portable, and sometimes faster for future GDExtension. Some areas use custom equivalents defined in `util/`.  
    如果可能的话，将Godot的使用保持在最低限度，以使代码更具可移植性，有时在将来的GDExtension中更快。某些区域使用 中 `util/` 定义的自定义等效项。

Compiling as a module or an extension is both supported, so it involves some restrictions:  
编译为模块或扩展都受支持，因此涉及一些限制：

-   Don't include Godot headers directly. Use headers from `util/godot`.  
    不要直接包含戈多标头。使用来自 的 `util/godot` 标头。
-   Only use APIs that are available to GDExtensions (or the script API). If they exist in both but are different, use wrappers defined in `util/godot`.  
    仅使用可用于 GDExtension（或脚本 API）的 API。如果它们存在于两者中但不同，请使用 中 `util/godot` 定义的包装器。

### Namespaces 命名空间

The intented namespaces are `zylann::` as main, and `zylann::voxel::` for voxel-related stuff. There may be others for different parts of the module.  
有意的命名空间是 `zylann::` 主要的，并且 `zylann::voxel::` 用于与体素相关的东西。模块的不同部分可能还有其他部分。

Registered classes are also namespaced to prevent conflicts. These do not appear in Godot's ClassDB, so voxel-related classes are also prefixed `Voxel`. Other more generic classes are prefixed `ZN_`.  
注册的类也具有命名空间以防止冲突。这些没有出现在Godot的ClassDB中，因此与体素相关的类也带有前缀 `Voxel` 。其他更泛型的类带有前缀 `ZN_` 。

If a registered class needs the same name as an internal one, it can be placed into a `::gd` sub-namespace. On the other hand, internal classes can also be suffixed `Internal`.  
如果已注册的类需要与内部类相同的名称，则可以将其放入 `::gd` 子命名空间中。另一方面，内部类也可以加后缀 `Internal` 。

### Version control 版本控制

-   Prefer separating commits with logic changes and commits with code formatting  
    首选使用逻辑更改分隔提交，并使用代码格式分隔提交
-   When doing a PR, prefer to squash WIP commits  
    执行 PR 时，更喜欢压缩 WIP 提交

## Debugging 调试

### Command line arguments 命令行参数

When you start Godot, by default it starts the project manager. When you choose a project from there, it will relaunch itself, but that breaks the debugger's connection. So it is recommended to use command line arguments to directly start Godot in the project and mode you want.  
当你启动Godot时，默认情况下它会启动项目经理。当您从那里选择一个项目时，它将重新启动自身，但这会断开调试器的连接。所以建议使用命令行参数，在你想要的项目和模式下直接启动Godot。

First, make sure Godot is launched within the working directory of your project.  
首先，确保Godot在项目的工作目录中启动。

-   To debug the game, launch Godot with no argument, and it will start from the main scene.  
    要调试游戏，请毫无争议地启动Godot，它将从主场景开始。
-   To debug a specific scene of the project, launch Godot with the relative path to the scene as command line argument  
    要调试项目的特定场景，请使用场景的相对路径作为命令行参数启动 Godot
-   To debug the editor, add the `-e` argument.  
    若要调试编辑器，请添加 `-e` 参数。

Example of options setup in in VSCode `launch.json` on Windows:  
在 Windows 上的 VSCode `launch.json` 中设置的选项示例：

```
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(Windows) Launch",
            "type": "cppvsdbg", // For MSVC
            //"type": "cppdbg", // For GDB
            "request": "launch",
            "program": "${workspaceFolder}/bin/godot.windows.editor.dev.x86_64.exe", // Dev build (old target=debug)
            //"program": "${workspaceFolder}/bin/godot.windows.editor.x86_64.exe", // Non-dev build (old target=release_debug)
            "args": [
                "-v", // Verbose output

                //"-e", // Editor mode

                //"--debug-collisions",

                // Run a specific scene
                //"local_tests/sqlite/test_sqlite.tscn",
                //"local_tests/texturing/test_textured_terrain.tscn"
                //"local_tests/texturing/test_texturing.tscn"
            ],
            "stopAtEntry": false,
            "cwd": "D:/PROJETS/INFO/GODOT/Games/SolarSystem/Project",
            "environment": [],
            "visualizerFile": "${workspaceFolder}/modules/voxel/misc/voxel.natvis"
        }
    ]
}

```

### Breakpoint on error 出错时的断点

It is recommended to use a debugger to have better information when errors or crashes occur. It may be useful to open `core/error/error_macros.cpp` (in Godot 4.x) and leave a breakpoint in `_err_print_error`, so that every time an error occurs, the debugger will break in there, providing you with the live call stack and variable states to inspect.  
建议使用调试器在发生错误或崩溃时获得更好的信息。打开 `core/error/error_macros.cpp` （在Godot 4.x中）并在 中 `_err_print_error` 保留一个断点可能很有用，这样每次发生错误时，调试器都会中断其中，为您提供实时调用堆栈和要检查的变量状态。

If you debug the editor, Godot tends to print a lot more errors for things that aren't critical, such as making temporary mistakes in the script editor, or trying to index a resource file in the explorer dock and failing for whatever reason. In this case you may either need clean dedicated test projects, or place breakpoints after launch.  
如果您调试编辑器，Godot 往往会为不重要的事情打印更多错误，例如在脚本编辑器中犯临时错误，或者尝试在资源管理器停靠中索引资源文件并因任何原因失败。在这种情况下，您可能需要干净的专用测试项目，或者在启动后放置断点。

### Debug print 调试打印

Godot: 戈多：

```
#include <core/string/print_string.h>

print_line(String("Hello {0}, my age is {1}").format(varray(name, age)));

```

Non-Godot: 非戈多：

```
#include "util/log.h"
#include "util/string_funcs.h"

println(format("Hello {}, my age is {}", name, age));

```

### Pretty printing 漂亮的打印

Godot and the voxel module both use their own container types, in addition to STL's ones. Debuggers often aren't able to inspect them. For example, Godot's `Vector<T>` class is similar to `std::vector<T>` but debuggers are unable to let you inspect what's in them.  
除了STL的容器类型之外，Godot和体素模块都使用自己的容器类型。调试器通常无法检查它们。例如，Godot 的 `Vector<T>` 类类似于 但 `std::vector<T>` 调试器无法让你检查其中的内容。

To fix this, it is usually possible to provide your debugger a file listing special patterns to inspect these types in a more user-friendly way.  
若要解决此问题，通常可以向调试器提供一个文件，其中列出了特殊模式，以更用户友好的方式检查这些类型。

In VSCode, the cpp-tools extension supports Natvis files. Godot comes with such a file in `platform/windows/godot.natvis`. To get pretty printing for Godot types, in your `launch.json` file, add the following line:  
在VSCode中，cpp-tools扩展支持natvis文件。戈多在. `platform/windows/godot.natvis` 要获得 Godot 类型的漂亮打印，请在您的 `launch.json` 文件中添加以下行：

```
            "visualizerFile": "${workspaceFolder}/platform/windows/godot.natvis"

```

Unfortunately, only one file can be provided at the moment. [An issue is open](https://github.com/Microsoft/vscode-cpptools/issues/925) to request support for multiple files. That means if you also want pretty-printing for structures of the voxel module, you have to replace the natvis path with the following:  
不幸的是，目前只能提供一个文件。一个问题开放，请求支持多个文件。这意味着，如果您还想对体素模块的结构进行漂亮的打印，则必须将natvis路径替换为以下内容：

```
            "visualizerFile": "${workspaceFolder}/modules/voxel/misc/voxel.natvis"

```

## Profile with Tracy 特雷西的个人资料

This module contains macros to profile specific code sections. By default, these macros expand to [Tracy Profiler](https://github.com/wolfpld/tracy) zones. It allows to check how long code takes to run, and displays it in a timeline.  
此模块包含用于分析特定代码段的宏。默认情况下，这些宏将扩展到 Tracy 探查器区域。它允许检查代码运行需要多长时间，并将其显示在时间线中。

It was tested with Tracy 0.7.8.  
它用Tracy 0.7.8进行了测试。

![Tracy screenshot](https://voxel-tools.readthedocs.io/en/latest/images/tracy.webp)

Alternative profilers are also mentionned in the [Godot docs](https://docs.godotengine.org/en/latest/contributing/development/debugging/using_cpp_profilers.html). They profile everything and appear to be based on CPU sampling, while Tracy is an instrumenting profiler providing specific, live results on a timeline.  
Godot 文档中也提到了替代分析器。它们分析所有内容，似乎基于 CPU 采样，而 Tracy 是一个检测分析器，在时间轴上提供特定的实时结果。

### How to use profiler scopes  
如何使用探查器作用域

A profiling scope bounds a section of code. It takes the time before, the time after, and records it into a timeline. In C++ we can use RAII to automatically close a section when we exit a function or block, so usually a single macro is needed at the beginning of the profiled zone.  
分析范围限定一段代码。它获取之前、之后的时间，并将其记录到时间轴中。C++我们可以使用 RAII 在退出函数或块时自动关闭一个部分，因此通常在分析区域的开头需要一个宏。

The macros are profiler-agnostic, so if you want to use another profiler it is possible to change them.  
宏与探查器无关，因此如果要使用其他探查器，可以更改它们。

You need to include `util/profiling.h` to access the macros.  
您需要包含 `util/profiling.h` 才能访问宏。

To profile a whole function:  
要分析整个函数，请执行以下操作：

```
void some_function() {
    ZN_PROFILE_SCOPE();
    //...
}

```

To profile part of a function:  
要分析函数的一部分：

```
void some_function() {
    // Some code...

    // Could be an `if`, `for`, `while`, or a simple block as here
    {
        ZN_PROFILE_SCOPE();
        // Profiled code...
    }

    //...
}

```

By default scopes take the name of the function, or file and a line number, but you can give a name explicitely using `ZN_PROFILE_SCOPE_NAMED("Hello")`. Only compile-time strings are supported, don't use `String` or `std::string`.  
默认情况下，作用域采用函数的名称或文件和行号，但您可以使用 显式 `ZN_PROFILE_SCOPE_NAMED("Hello")` 指定名称。仅支持编译时字符串，请勿使用 `String` 或 `std::string` .

It is also possible to plot numeric values so they are displayed in the timeline too:  
也可以绘制数值，以便它们也显示在时间轴中：

```
void process_every_frame() {
    // Some code...

    ZN_PROFILE_PLOT("Bunnies", bunnies.size());
}

```

### Adding Tracy to Godot  
将特雷西添加到戈多

To add Tracy support, clone it under `thirdparty/tracy` (Godot's `thirdparty` folder, not the voxel module). Then in `modules/voxel/SCsub`, add the following lines:  
要添加 Tracy 支持，请将其克隆到（Godot 的 `thirdparty` 文件夹，而不是体素模块）下 `thirdparty/tracy` 。然后在 中添加 `modules/voxel/SCsub` 以下行：

```
# tracy library
env.Append(CPPDEFINES="TRACY_ENABLE")
env_voxel.Append(CPPDEFINES="TRACY_ENABLE")
voxel_files += ["#thirdparty/tracy/TracyClient.cpp"]

```

Those lines might already be there, if so just uncomment them.  
这些行可能已经存在，如果是这样，只需取消注释它们。

Once you are done profiling, don't forget to remove these lines, otherwise profiling data will accumulate in memory without being retrieved.  
完成分析后，不要忘记删除这些行，否则分析数据将累积在内存中而不被检索。

Note 注意

Tracy has a concept of frame mark, which is usually provided by the application, to tell the profiler when each frame begins. Godot does not provide profiling macros natively, so the frame mark was hacked into `VoxelEngine` process function. This allows to see frames of the main thread in the timeline, but they will be offset from their real beginning.  
Tracy 有一个帧标记的概念，通常由应用程序提供，用于告诉探查器每个帧何时开始。Godot 本身不提供性能分析宏，因此帧标记被黑客入侵到进程函数中 `VoxelEngine` 。这允许在时间轴中看到主线程的帧，但它们将从其实际开始偏移。

This way of integrating Tracy was based on this [commit by vblanco](https://github.com/vblanco20-1/godot/commit/2c5613abb8c9fdb5c4bfe3b52fdb665a91b43579)  
这种整合Tracy的方式是基于vblanco的这个提交

## Preprocessor macros 预处理器宏

The module has a few preprocessor macros that can be defined in order to turn off parts of the code getting compiled. Some can be specified through SCons command line parameters.  
该模块具有一些预处理器宏，可以定义这些宏以关闭正在编译的部分代码。有些可以通过 SCons 命令行参数指定。

-   `MESHOPTIMIZER_ZYLANN_NEVER_COLLAPSE_BORDERS`: this one must be defined to fix an issue with `MeshOptimizer`. See [https://github.com/zeux/meshoptimizer/issues/311](https://github.com/zeux/meshoptimizer/issues/311)  
    `MESHOPTIMIZER_ZYLANN_NEVER_COLLAPSE_BORDERS` ：必须定义此值才能解决 的问题 `MeshOptimizer` 。见 https://github.com/zeux/meshoptimizer/issues/311
-   `MESHOPTIMIZER_ZYLANN_WRAP_LIBRARY_IN_NAMESPACE`: this one must be defined to prevent conflict with Godot's own version of MeshOptimizer. See [https://github.com/zeux/meshoptimizer/issues/311#issuecomment-955750624](https://github.com/zeux/meshoptimizer/issues/311#issuecomment-955750624)  
    `MESHOPTIMIZER_ZYLANN_WRAP_LIBRARY_IN_NAMESPACE` ：必须定义这个以防止与Godot自己的MeshOptimizer版本发生冲突。见 https://github.com/zeux/meshoptimizer/issues/311#issuecomment-955750624
-   `VOXEL_ENABLE_FAST_NOISE_2`: if defined, the module will compile with integrated support for SIMD noise using FastNoise2. It is optional in case it causes problem on some compilers or platforms. SCons parameter: `voxel_fast_noise_2=yes`  
    `VOXEL_ENABLE_FAST_NOISE_2` ：如果已定义，该模块将使用 FastNoise2 进行编译，并集成了对 SIMD 噪声的支持。它是可选的，以防它在某些编译器或平台上引起问题。SCons 参数： `voxel_fast_noise_2=yes`
-   `VOXEL_RUN_TESTS`: If `True`, tests will be compiled and run on startup to verify if some features of the engine still work correctly. It is off by default in production builds. This is mostly for debug builds when doing C++ development on the module. SCons parameter: `voxel_tests=yes`  
    `VOXEL_RUN_TESTS` ：如果 ，则将 `True` 编译测试并在启动时运行，以验证引擎的某些功能是否仍然正常工作。默认情况下，它在生产版本中处于关闭状态。这主要用于在模块上进行C++开发时的调试版本。SCons 参数： `voxel_tests=yes`
-   `ZN_GODOT`: must be defined when compiling this project as a module.  
    `ZN_GODOT` ：在将此项目编译为模块时必须定义。
-   `ZN_GODOT_EXTENSION`: must be defined when compiling this project as a GDExtension.  
    `ZN_GODOT_EXTENSION` ：在将此项目编译为 GDExtension时必须定义。

## Shaders 着色器

The module contains shaders for some of its features, mainly compute shaders. They are found under the `shaders/dev/` folder.  
该模块包含其某些功能的着色器，主要是计算着色器。它们位于 `shaders/dev/` 文件夹下。

`shaders/dev` contains a Godot project. The purpose of this project is mainly to quickly test if shaders compile properly, and eventually test them with simple scenes and GDScript code.  
`shaders/dev` 包含一个戈多项目。这个项目的目的主要是快速测试着色器是否编译正确，并最终使用简单的场景和GDScript代码对其进行测试。

There are several ways shaders are written:  
有几种编写着色器的方法：

-   Plain: regular shaders, which will be used as-is.  
    普通：常规着色器，将按原样使用。
-   Templates: these contain `<PLACEHOLDER>` sections, which the engine will replace with generated code. Code inside those sections will be replaced and is only present to make the shader compile in the test project.  
    模板：这些包含 `<PLACEHOLDER>` 部分，引擎将用生成的代码替换这些部分。这些部分中的代码将被替换，并且仅用于使着色器在测试项目中编译。
-   Snippets: these contain `<SNIPPET>` sections, which will be inserted into templates or other generated code. Code outside those sections will not be used and is only present to make the shader compile in the test project.  
    代码段：这些 `<SNIPPET>` 包含部分，这些部分将插入到模板或其他生成的代码中。这些部分之外的代码将不会使用，并且仅用于使着色器在测试项目中编译。

Shipping external files when compiling as a module is inconvenient, so instead they are embedded in C++ directly, similarly to how Godot does. A script can be executed to update those generated files. You must open a command line inside the `shaders/` folder and run `python text2cpp.py`.  
在编译为模块时传送外部文件很不方便，因此它们直接嵌入C++中，类似于Godot的做法。可以执行脚本来更新这些生成的文件。您必须在 `shaders/` 文件夹中打开命令行并运行 `python text2cpp.py` 。

Currently, C++ code generating shaders is intertwined with the contents of those shaders. For example, C++ strings in code generation can contain variable names found in GLSL files, so you should have both open to understand the context.  
目前，生成着色器的C++代码与这些着色器的内容交织在一起。例如，代码生成中的C++字符串可以包含在 GLSL 文件中找到的变量名称，因此您应该打开两者以了解上下文。

## Using the module from another module  
使用另一个模块中的模块

Writing a custom C++ module directly in Godot is one way to access features of Godot and the voxel engine more directly, which can be better for performance and more stable than a GDExtension. You can do this too if you want to create a custom generator, mesher, stream, or just use components of the module, without having to modify the module directly.  
直接在 Godot 中编写自定义C++模块是更直接地访问 Godot 和体素引擎功能的一种方法，这比 GDExtension的性能更好且更稳定。如果要创建自定义生成器、网格器、流或仅使用模块的组件，而无需直接修改模块，也可以执行此操作。

You can include files from the voxel module by using `modules/voxel/` in your includes:  
您可以通过在包含 `modules/voxel/` 中使用以下内容来包含体素模块中的文件：

```
#include <modules/voxel/storage/voxel_buffer_internal.h>

```

You will also need to define preprocessor macros in your `SCsub` file:  
您还需要在 `SCsub` 文件中定义预处理器宏：

```
env_yourmodule.Append(CPPDEFINES = [
    'ZN_GODOT'
])

```

## GDExtension GDExtension¶

Warning 警告

This feature is under development and is not ready for production. It has bugs and can crash the engine. Check the [issue tracker](https://github.com/Zylann/godot_voxel/issues/333) for work in progress.  
此功能正在开发中，尚未准备好投入生产。它有错误，可能会使引擎崩溃。检查问题跟踪器以了解正在进行的工作。

This module can compile as a GDExtension library. This allows to distribute it as a library file (`.dll`, `.so`...) without having to recompile Godot Engine. TODO: Godot's documentation doesn't seem to contain information about GDExtension yet. For now, you can check [this old news](https://godotengine.org/article/introducing-gd-extensions) and the [GodotCpp repository](https://github.com/godotengine/godot-cpp).  
此模块可以编译为 GDExtension库。这允许将其作为库文件（ `.dll` ， `.so` ...）分发，而无需重新编译Godot引擎。TODO：Godot的文档似乎还没有包含有关GDExtension的信息。现在，您可以查看此旧新闻和GodotCpp存储库。

To compile the library: - Download a copy of [GodotCpp](https://github.com/godotengine/godot-cpp) - In the voxel module's root directory, write the path to GodotCpp at the beginning of the `SConstruct` script, or set the environment variable from command line. - Open the same kind of console you would use to compile Godot, change directory to the voxel module's root folder, and run SCons there. It will use the `SConstruct` file instead of `SCsub`. The library will be saved under a `bin/` folder.  
要编译库： - 下载 GodotCpp 的副本 - 在体素模块的根目录中，在 `SConstruct` 脚本开头写入 GodotCpp 的路径，或从命令行设置环境变量。- 打开与编译Godot相同的控制台，将目录更改为体素模块的根文件夹，并在那里运行SCons。它将使用 `SConstruct` 该文件而不是 `SCsub` .库将保存在一个 `bin/` 文件夹下。

Example of build command on Windows (unoptimized debug build for use in editor):  
Windows上的构建命令示例（用于编辑器的未优化调试版本）：

```
scons platform=windows target=debug -j4

```

The built library will be placed inside the `project/` folder, which contains a Godot 4 project. It is then possible to open it to test the extension. Note that it might not be setup for all platforms yet (so far Windows 64-bits is setup).  
构建的库将放置在 `project/` 包含 Godot 4 项目的文件夹中。然后可以打开它来测试扩展。请注意，它可能尚未针对所有平台进行设置（到目前为止，Windows 64 位已设置）。

There are a number of issues to address before this target can be usable. The extension is able to run, but there are known issues. Check the [issue tracker](https://github.com/Zylann/godot_voxel/issues/333) for work in progress.  
在实现此目标之前，有许多问题需要解决。扩展能够运行，但存在已知问题。检查问题跟踪器以了解正在进行的工作。
