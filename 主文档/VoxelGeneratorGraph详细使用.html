<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>VoxelGeneratorGraph详细使用</title>
	<link rel="stylesheet" href="../index.css">
	<!-- 引入语法高亮 -->
	<link href="../highlight/dark.min.css" rel="stylesheet">
	<script src="../highlight/highlight.min.js"></script>
	<!-- 引入JQuery -->
	<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
	<script>
		$(function(){
			// 根据正文内容创建目录
			let content = "";
			$(".main h1,.main h2,.main h3").each(function(index,ele){
				$(this).before(`<a name ="ctn_${index}"></li>`)
				switch(ele.tagName){
					case "H1":
						content += `<li class="h1"><a href="#ctn_${index}">${ele.textContent}</a></li>`;
						break;
					case "H2":
						content += `<li class="h2"><a href="#ctn_${index}">${ele.textContent}</a></li>`;
						break;
					case "H3":
						content += `<li class="h3"><a href="#ctn_${index}">${ele.textContent.split("(")[0]}</a></li>`;
						break;
				}
			})
			$(".right ul").append(content);
			// 侧边栏子文件夹点击事件
			$(".doc_tree li>span").on("click",function(){
				$(this).next("ul").toggle();
			})
		})
	</script>
</head>
<body>
<!-- 左侧 -->
	<aside class="left">
		<div class="logo_box">
			<a href="#" class="logo_text">Godot Voxel</a>
			<span>中文文档</span>
		</div>
		<!-- 文档列表 -->
		<div class="doc_tree">
<ul>
	<li><a href="../README.html">README</a></li>
<li><span>API</span>
	<ul>
		<li><a href="../API/API文档.html">API文档</a></li>
		<li><a href="../API/FastNoise2.html">FastNoise2</a></li>
		<li><a href="../API/VoxelBlockSerializer.html">VoxelBlockSerializer</a></li>
		<li><a href="../API/VoxelBlockyAttribute.html">VoxelBlockyAttribute</a></li>
		<li><a href="../API/VoxelBlockyAttributeAxis.html">VoxelBlockyAttributeAxis</a></li>
		<li><a href="../API/VoxelBlockyAttributeCustom.html">VoxelBlockyAttributeCustom</a></li>
		<li><a href="../API/VoxelBlockyAttributeDirection.html">VoxelBlockyAttributeDirection</a></li>
		<li><a href="../API/VoxelBlockyAttributeRotation.html">VoxelBlockyAttributeRotation</a></li>
		<li><a href="../API/VoxelBlockyLibrary.html">VoxelBlockyLibrary</a></li>
		<li><a href="../API/VoxelBlockyLibraryBase.html">VoxelBlockyLibraryBase</a></li>
		<li><a href="../API/VoxelBlockyModel.html">VoxelBlockyModel</a></li>
		<li><a href="../API/VoxelBlockyModelCube.html">VoxelBlockyModelCube</a></li>
		<li><a href="../API/VoxelBlockyModelEmpty.html">VoxelBlockyModelEmpty</a></li>
		<li><a href="../API/VoxelBlockyModelMesh.html">VoxelBlockyModelMesh</a></li>
		<li><a href="../API/VoxelBlockyType.html">VoxelBlockyType</a></li>
		<li><a href="../API/VoxelBlockyTypeLibrary.html">VoxelBlockyTypeLibrary</a></li>
		<li><a href="../API/VoxelBoxMover.html">VoxelBoxMover</a></li>
		<li><a href="../API/VoxelBuffer.html">VoxelBuffer</a></li>
		<li><a href="../API/VoxelColorPalette.html">VoxelColorPalette</a></li>
		<li><a href="../API/VoxelDataBlockEnterInfo.html">VoxelDataBlockEnterInfo</a></li>
		<li><a href="../API/VoxelEngine.html">VoxelEngine</a></li>
		<li><a href="../API/VoxelGenerator.html">VoxelGenerator</a></li>
		<li><a href="../API/VoxelGeneratorFlat.html">VoxelGeneratorFlat</a></li>
		<li><a href="../API/VoxelGeneratorGraph.html">VoxelGeneratorGraph</a></li>
		<li><a href="../API/VoxelGeneratorHeightmap.html">VoxelGeneratorHeightmap</a></li>
		<li><a href="../API/VoxelGeneratorImage.html">VoxelGeneratorImage</a></li>
		<li><a href="../API/VoxelGeneratorNoise.html">VoxelGeneratorNoise</a></li>
		<li><a href="../API/VoxelGeneratorNoise2D.html">VoxelGeneratorNoise2D</a></li>
		<li><a href="../API/VoxelGeneratorScript.html">VoxelGeneratorScript</a></li>
		<li><a href="../API/VoxelGeneratorWaves.html">VoxelGeneratorWaves</a></li>
		<li><a href="../API/VoxelGraphFunction.html">VoxelGraphFunction</a></li>
		<li><a href="../API/VoxelInstanceComponent.html">VoxelInstanceComponent</a></li>
		<li><a href="../API/VoxelInstanceGenerator.html">VoxelInstanceGenerator</a></li>
		<li><a href="../API/VoxelInstanceLibrary.html">VoxelInstanceLibrary</a></li>
		<li><a href="../API/VoxelInstanceLibraryItem.html">VoxelInstanceLibraryItem</a></li>
		<li><a href="../API/VoxelInstanceLibraryMultiMeshItem.html">VoxelInstanceLibraryMultiMeshItem</a></li>
		<li><a href="../API/VoxelInstanceLibrarySceneItem.html">VoxelInstanceLibrarySceneItem</a></li>
		<li><a href="../API/VoxelInstancer.html">VoxelInstancer</a></li>
		<li><a href="../API/VoxelLodTerrain.html">VoxelLodTerrain</a></li>
		<li><a href="../API/VoxelMeshSDF.html">VoxelMeshSDF</a></li>
		<li><a href="../API/VoxelMesher.html">VoxelMesher</a></li>
		<li><a href="../API/VoxelMesherBlocky.html">VoxelMesherBlocky</a></li>
		<li><a href="../API/VoxelMesherCubes.html">VoxelMesherCubes</a></li>
		<li><a href="../API/VoxelMesherDMC.html">VoxelMesherDMC</a></li>
		<li><a href="../API/VoxelMesherTransvoxel.html">VoxelMesherTransvoxel</a></li>
		<li><a href="../API/VoxelModifier.html">VoxelModifier</a></li>
		<li><a href="../API/VoxelModifierMesh.html">VoxelModifierMesh</a></li>
		<li><a href="../API/VoxelModifierSphere.html">VoxelModifierSphere</a></li>
		<li><a href="../API/VoxelNode.html">VoxelNode</a></li>
		<li><a href="../API/VoxelRaycastResult.html">VoxelRaycastResult</a></li>
		<li><a href="../API/VoxelStream.html">VoxelStream</a></li>
		<li><a href="../API/VoxelStreamRegionFiles.html">VoxelStreamRegionFiles</a></li>
		<li><a href="../API/VoxelStreamSQLite.html">VoxelStreamSQLite</a></li>
		<li><a href="../API/VoxelStreamScript.html">VoxelStreamScript</a></li>
		<li><a href="../API/VoxelTerrain.html">VoxelTerrain</a></li>
		<li><a href="../API/VoxelTool.html">VoxelTool</a></li>
		<li><a href="../API/VoxelToolBuffer.html">VoxelToolBuffer</a></li>
		<li><a href="../API/VoxelToolLodTerrain.html">VoxelToolLodTerrain</a></li>
		<li><a href="../API/VoxelToolTerrain.html">VoxelToolTerrain</a></li>
		<li><a href="../API/VoxelViewer.html">VoxelViewer</a></li>
		<li><a href="../API/VoxelVoxLoader.html">VoxelVoxLoader</a></li>
		<li><a href="../API/ZN_FastNoiseLite.html">ZN_FastNoiseLite</a></li>
		<li><a href="../API/ZN_FastNoiseLiteGradient.html">ZN_FastNoiseLiteGradient</a></li>
		<li><a href="../API/ZN_ThreadedTask.html">ZN_ThreadedTask</a></li>
	</ul>

</li>
<li><span>主文档</span>
	<ul>
		<li><a href="../主文档/VoxelGeneratorGraph节点.html">VoxelGeneratorGraph节点</a></li>
		<li><a href="../主文档/VoxelGeneratorGraph详细使用.html">VoxelGeneratorGraph详细使用</a></li>
		<li><a href="../主文档/下载安装.html">下载安装</a></li>
		<li><a href="../主文档/优化性能.html">优化性能</a></li>
		<li><a href="../主文档/体素相关概念.html">体素相关概念</a></li>
		<li><a href="../主文档/使用脚本创建和修改体素数据.html">使用脚本创建和修改体素数据</a></li>
		<li><a href="../主文档/创建多人游戏.html">创建多人游戏</a></li>
		<li><a href="../主文档/参与GoodotVoxel模块开发.html">参与GoodotVoxel模块开发</a></li>
		<li><a href="../主文档/在编辑器中的使用.html">在编辑器中的使用</a></li>
		<li><a href="../主文档/地形类型.html">地形类型</a></li>
		<li><a href="../主文档/块状地形.html">块状地形</a></li>
		<li><a href="../主文档/基于VoxelInstancer的实例化.html">基于VoxelInstancer的实例化</a></li>
		<li><a href="../主文档/学习资源.html">学习资源</a></li>
		<li><a href="../主文档/平滑地形.html">平滑地形</a></li>
		<li><a href="../主文档/快速上手.html">快速上手</a></li>
		<li><a href="../主文档/流.html">流</a></li>
		<li><a href="../主文档/生成器.html">生成器</a></li>
		<li><a href="../主文档/程序化生成.html">程序化生成</a></li>
	</ul>

</li>
<li><span>序列化格式</span>
	<ul>
		<li><a href="../序列化格式/SQLite格式.html">SQLite格式</a></li>
		<li><a href="../序列化格式/体素块格式v1.html">体素块格式v1</a></li>
		<li><a href="../序列化格式/体素块格式v2.html">体素块格式v2</a></li>
		<li><a href="../序列化格式/体素块格式v3.html">体素块格式v3</a></li>
		<li><a href="../序列化格式/体素块格式v4.html">体素块格式v4</a></li>
		<li><a href="../序列化格式/区域格式v2.html">区域格式v2</a></li>
		<li><a href="../序列化格式/区域格式v3.html">区域格式v3</a></li>
		<li><a href="../序列化格式/压缩数据格式.html">压缩数据格式</a></li>
		<li><a href="../序列化格式/实例块格式v0.html">实例块格式v0</a></li>
		<li><a href="../序列化格式/实例块格式v1.html">实例块格式v1</a></li>
		<li><a href="../序列化格式/序列化格式.html">序列化格式</a></li>
	</ul>

</li>
</ul>

		</div>

	</aside>
	<!-- 整体布局 -->
	<div class="layout center">
		<!-- 正文区 -->
		<div class="main">
<h1>VoxelGeneratorGraph详细使用</h1><p>

<h3> 概念</h3><p>


VoxelGeneratorGraph允许通过将操作节点连接在一起来表示 3D 密度。它采用 3D 坐标（X、Y、Z），并从中计算每个体素的值。例如，它可以做一个简单的2D或3D噪声，可以使用其他噪声，曲线甚至图像进行缩放，变形，掩盖。


这种方法的一大灵感再次来自有符号距离场的雕刻（每个体素存储到最近表面的距离），这就是为什么主输出节点可能是. <span class="inline_code">SdfOutput</span> 一堆节点也应该在SDF上工作。但是，只要结果对于游戏来说看起来是正确的，就不必严格尊重完美距离，因此大多数时候使用近似值更容易。

 注意


体素图介于编程 3D 着色器和程序设计之间。它的速度与C++发电机相似，但只有基本指令，因此涉及一些数学。将来添加更多高级节点时，这可能会有所缓解。

<h3> 示例</h3><p>

<h4> 平面</h4><p>


具有可见输出的最简单图形是平面。平面的 SDF 是到海平面的距离 （0），即 <span class="inline_code">sdf = y</span> 。换句话说，表面将显示在体素值与零交叉的位置。


右键单击图形的背景，选择节点 <span class="inline_code">InputY</span> 和 <span class="inline_code">SdfOutput</span> ，然后通过将它们的端口拖在一起将它们连接在一起。

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_flat.webp' alt="Plane voxel graph screenshot" />



可以通过减去一个常数 （ <span class="inline_code">sdf = y <li>height</span> ） 来确定平面的高度，这样就会 <span class="inline_code">sdf == 0</span> 在更高的坐标处发生。为此，必须添加一个额外的节点：</li><p>

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_flat_offset.webp' alt="Offset plane voxel graph screenshot" />



默认情况下， <span class="inline_code">Add</span> 节点不执行任何操作，因为它的 <span class="inline_code">b</span> 端口未连接到任何端口。可以为此类端口提供默认值。您可以通过单击节点并在检查器中进行更改来设置它。


（注意：我使用了 <span class="inline_code">Add</span> 负值 <span class="inline_code">b</span> ，但您也可以使用 <span class="inline_code">Subtract</span> 节点来获得相同的结果）。

<h4> 噪音 ¶</h4><p>


平面很简单，但有点无聊，因此生成地形的一种典型方法是添加良好的旧分形噪声。您可以在 2D（高度贴图）或 3D（体积）中执行此操作。2D方法更简单，因为我们只需要采用以前的设置，并在结果中添加2D噪声。此外，由于噪声是在 \[-1 到 1\] 范围内产生的，我们还需要一个乘数来使其更大 （ <span class="inline_code">sdf = y <li>height + noise2d(x, y) * noise_multiplier</span> ）。</li><p>


有几种类型的噪声可用，每种都有自己的参数。在撰写本文时， <span class="inline_code">FastNoise2D</span> 噪音是最佳选择。 <span class="inline_code">Noise2D</span> 也可以工作，但它更慢，更有限（它使用戈多 <span class="inline_code">OpenSimplexNoise</span> 的类）。

 注意


创建此节点后，必须在其参数中创建新 <span class="inline_code">FastNoiseLite</span> 资源。如果未设置该资源，则会发生错误，并且不会生成体素。

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_noise2d.webp' alt="Voxel graph 2D noise" />



3D噪声的计算成本更高，但很有趣，因为它实际上会产生悬垂甚至小洞穴。在以前的设置中，可以用 3D 噪声替换 2D 噪声：

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_noise3d_not_expanded.webp' alt="Voxel graph 3D noise" />



您可能会注意到，尽管它是 3D 的，但它似乎仍然会产生高度图。这是因为在图表 <span class="inline_code">Y</span> 中添加的噪声值在朝向天空时会逐渐抵消到越来越高的值，这使得表面迅速消失。因此，如果我们 <span class="inline_code">Y</span> 乘以较小的值，它将增加得更慢，从而使 3D 噪声扩展得更多 （ <span class="inline_code">sdf = y * height_multiplier <li>height + noise3d(x, y, z)</span> ）：</li><p>

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_noise3d_expanded.webp' alt="Voxel graph 3D noise expanded" />


 注意


某些节点具有默认连接。例如，对于 3D 噪声，如果不连接输入，默认情况下它们将自动采用 （X，Y，Z） 体素位置。如果需要输入中的特定常量，可以通过在检查器中关闭 <span class="inline_code">autoconnect_default_inputs</span> 来选择退出此行为。

<h4> 星球 ¶</h4><p>


我们实际上并没有被迫像飞机一样不断创造世界。我们可以更疯狂，做行星。开始一个行星的一个好方法是用 <span class="inline_code">SdfSphere</span> 节点做一个球体：

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_sphere.webp' alt="Voxel graph sdf sphere node" />



我们在这里不能真正使用 2D 噪声，因此我们也可以添加 3D 噪声：

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_sphere_with_noise.webp' alt="Voxel graph sdf sphere with noise" />



但是，您可能仍然想要类似高度图的结果。一种方法是输入 3D 噪声归一化坐标，而不是全局噪声归一化坐标。选择脊状分形也可以给出侵蚀的外观，尽管它需要否定噪声乘数节点以反转其距离场（如果我们将其保留为正值，它将看起来膨胀而不是侵蚀）。

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_sphere_with_noise2.webp' alt="Voxel graph sdf sphere with height noise" />


 注意

如果将节点替换为 <span class="inline_code">SdfSphere</span> <span class="inline_code">SdfTorus</span> 节点，则可以获得甜甜圈形状的行星。 <img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_torus.webp' alt="Torus voxel graph" />
 


更多技术可以在过程生成部分找到。

<h3>  </h3><p>

块状体素的使用 ¶


可以通过使用 <span class="inline_code">OutputType</span> 节点而不是 <span class="inline_code">OutputSDF</span> 来使用此生成器。 <span class="inline_code">VoxelMesherBlocky</span> 但是，期望体素是 ID， <span class="inline_code">VoxelMesherBlocky</span> 而不是 SDF 值。


最简单的示例是选取任何现有的 SDF 生成器，并替换为 <span class="inline_code">OutputSDF</span> <span class="inline_code">Select</span> 连接到 <span class="inline_code">OutputType</span> .这个想法是在 SDF 值高于或低于阈值时，在两种不同体素类型（如空气或石头）的 ID 之间进行选择。

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_blocky_basic_heightmap.webp' alt="Example screenshot of a basic blocky heightmap made with a graph generator" />



如果需要更多种类，可以将节点链接起来， <span class="inline_code">Select</span> 使用不同的阈值和源组合多个层。

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_blocky_biome.webp' alt="Example screenshot of a blocky heightmap with two biomes made with a graph generator" />



<span class="inline_code">Select</span> 在两个可能的值之间创建一个“切口”，并且可能需要进行某种过渡。虽然对于渐变的每个值没有很多不同的类型（通常使用着色器完成），这是不可能的 <span class="inline_code">VoxelMesherBlocky</span> ，但是很容易在阈值中添加一些噪声。这再现了类似的“抖动”过渡，正如在《我的世界》中沙子和泥土之间所看到的那样。

<img src='./VoxelGeneratorGraph详细使用.assets/voxel_graph_blocky_biome_dithering.webp' alt="Example screenshot of a blocky heightmap with two biomes and dithering" />



目前，图形生成器仅按体素工作。这使得它们非常适合生成基础地面和生物群落，但用它生成树木或村庄等结构是不切实际的。使用自定义生成器在整个块上使用第二次传递可能更容易实现。

<h3> 继电器 ¶</h3><p>


存在一个特殊 <span class="inline_code">Relay</span> 节点来组织节点之间的长连接。他们自己什么都不做，他们只是重定向连接。中继也可能有多个目的地。

<img src='./VoxelGeneratorGraph详细使用.assets/relay_node.webp' alt="Screenshot of a relay node" />


<h2> 自定义生成器 ¶</h2><p>

 请参阅脚本

<h2>  </h2><p>

用作 <span class="inline_code">VoxelGeneratorGraph</span> 画笔 ¶


此功能目前仅在平滑体素中 <span class="inline_code">VoxelLodTerrain</span> 受支持。


<span class="inline_code">VoxelTool</span> 例如，提供了修改平滑地形 <span class="inline_code">do_sphere</span> 的简单功能，但也可以使用 <span class="inline_code">VoxelGeneratorGraph</span> 定义程序自定义画笔。相同的工作流程也适用于制作这样的图形，只是它可以接受节点 <span class="inline_code">InputSDF</span> ，因此可以修改带符号的距离字段，而不仅仅是生成。


使用图形重新创建的添加剂 <span class="inline_code">do_sphere</span> 示例：

<img src='./VoxelGeneratorGraph详细使用.assets/graph_sphere_brush.webp' alt="Additive sphere brush graph" />



更复杂的扁平画笔，既减去球体中的物质，又增加半球中的物质以形成壁架（此处默认半径为 30 以获得更好的预览，但制作单位大小的画笔可能更容易重复使用）：

<img src='./VoxelGeneratorGraph详细使用.assets/graph_flatten_brush.webp' alt="Dual flattening brush" />



另一个需要考虑的细节是原始画笔有多大。通常体素生成器没有特定的界限，但在这里很重要，因为它将在本地使用。例如，如果您制作一个球形画笔，则可以使用 <span class="inline_code">SdfSphere</span> 半径 <span class="inline_code">1</span> 为 .然后，您的原始大小将是 <span class="inline_code">(2,2,2)</span> .然后，您可以在所需位置使用 <span class="inline_code">do_graph</span> 时变换该画笔（缩放、旋转...）。

<h2>  </h2><p>

可重复使用的图形与 <span class="inline_code">VoxelGraphFunction</span> ¶


<span class="inline_code">VoxelGraphFunction</span> 允许创建可以在其他图形中使用的图形。这是重用和共享图形的便捷方法。

<h3> 创建函数 ¶</h3><p>


A <span class="inline_code">VoxelGraphFunction</span> 可以在检查器中创建并像 一样 <span class="inline_code">VoxelGeneratorGraph</span> 进行编辑，只是它缺少一些仅在后者上找到的功能。建议将函数保存为自己的 <span class="inline_code">.tres</span> 文件，因为这是允许在其他图形中拾取它们的原因。

 注意


A <span class="inline_code">VoxelGraphFunction</span> 不能直接或间接地包含自身。这样做将导致戈多无法加载它。

<h3>  </h3><p>

公开输入和输出 ¶


为了可以在其他图形中使用，函数应该有输入和输出。可以通过创建节点 <span class="inline_code">InputX</span> 、 <span class="inline_code">InputY</span> <span class="inline_code">InputZ</span> 、 <span class="inline_code">InputSDF</span> 或 <span class="inline_code">CustomInput</span> 来将输入添加到函数中。可以通过创建节点 <span class="inline_code">OutputX</span> 、、 <span class="inline_code">OutputZ</span> 、 <span class="inline_code">OutputY</span> 等 <span class="inline_code">CustomOutput</span> 来添加输出。


但是，需要额外的步骤才能向函数的外部用户公开这些输入和输出。要显示它们，请选择图形（如果已打开，则在后台单击），转到检查器，然后单击 <span class="inline_code">Edit input/outputs</span> 。

<img src='./VoxelGeneratorGraph详细使用.assets/function_io_dialog.webp' alt="Screenshot of the function input/output editor dialog" />



目前，不支持定义手动公开的输入和输出，但已计划。您可以改为单击 <span class="inline_code">Auto-generate</span> ，这将自动找到节点并将它们公开为输入和输出。这也定义了它们的公开顺序。


非自定义输入和输出（如 <span class="inline_code">InputX</span> or <span class="inline_code">OutputX</span> ）是特殊节点，由其类型标识。它们被引擎识别用于特定目的。您可以有多个具有相同类型的节点，但它们将始终引用函数的相同输入。


自定义输入和输出由其名称标识。如果添加 2 个 <span class="inline_code">CustomInput</span> 节点并为其指定相同的名称，它们将从相同的输入中获取数据。建议为自定义输入和输出节点命名。空名称仍算作一个名称（因此多个 <span class="inline_code">CustomInput</span> 没有名称的名称将引用相同的未命名输入）。


不允许多个特殊输入或相同类型的输入。不允许使用多个自定义输入或同名输出。

<h3> 公开参数 ¶</h3><p>


目前参数无法公开，但已计划。

<h3> 处理更改 ¶</h3><p>


当现有函数发生变化（例如，新的/删除的输入/输出）时，使用它的其他图形可能会中断。如果尝试打开它们，则可能会丢失某些节点和连接。


目前，您需要修复这些图形并保存它们。您还可以更改有问题的函数，使其输入、输出和参数符合您的期望。但是，如果保存损坏的图形，则可能会丢失某些连接或节点。

<h3> 调试 ¶</h3><p>


编辑器工具（如性能分析、输出预览或范围分析）目前在 中 <span class="inline_code">VoxelGraphFunction</span> 不受支持。编辑 <span class="inline_code">VoxelGeneratorGraph</span> .


计划在将来编辑独立文件 <span class="inline_code">VoxelGraphFunction</span> 时提供这些工具。这将通过将功能移出 <span class="inline_code">VoxelGeneratorGraph</span> 以使其变得更加通用来完成。


检查函数“实例”（和子实例...）可能是可取的，但实现起来很棘手。它可以作为“内部开放”功能来完成，以检查“包含图”上下文中的数据。但是，由于函数在内部完全解包和优化，因此引擎必须将信息追溯到原始节点。跟踪在某种程度上已经存在，但仅将“顶级”图映射到完全扩展/优化的图，没有中间信息。将来可能会进一步研究这个问题。

<h3>  </h3><p>

体素生成器图节点 ¶


可以在此处找到节点的完整列表。

<h2> 修饰符 ¶</h2><p>


修饰符是影响体积有限区域的生成器。它们可以堆叠在基本生成的体素或其他修饰符之上，并影响最终结果。当您的世界大小有限，并且您希望从编辑器中以非破坏性方式设置特定的景观形状时，这是一个工作流程。

 注意


此功能目前仅通过 实现 <span class="inline_code">VoxelLodTerrain</span> ，并且仅适用于雕刻平滑体素。它处于早期阶段，因此非常有限。


可以将修改器与节点一起添加为地形的子项。 <span class="inline_code">VoxelModifierSphere</span> 添加或减去球体，同时 <span class="inline_code">VoxelModifierMesh</span> 添加或减去网格。对于后者，必须首先使用 <span class="inline_code">VoxelMeshSDF</span> 资源将网格烘焙到 SDF 体积中。


由于修饰符是程序生成堆栈的一部分，因此破坏性编辑将始终覆盖它们。如果编辑了块，则修饰符不会影响它。然后假设此类编辑将在运行时来自玩家，并且修饰符不会更改。

<h2> 缓存 ¶</h2><p>


生成器被设计为确定性的：如果同一区域生成两次，则结果必须相同。这意味着，最终，我们只需要存储编辑的体素（又名“破坏性”编辑），而未编辑的区域可以动态重新计算。即使您想要访问一个体素并且它恰好位于未编辑的位置，也会调用生成器以获取该体素。


但是，如果生成器太昂贵或预计不会以这种方式运行，则可能需要将输出存储在内存中，以便再次查询同一区域以获取缓存的数据。


默认情况下，将块缓存在内存中， <span class="inline_code">VoxelTerrain</span> 直到它们远离任何查看器。 <span class="inline_code">VoxelLodTerrain</span> 默认情况下不缓存块。目前还没有改变这种行为的选项。也可以告诉 a <span class="inline_code">VoxelGenerator</span> 将其输出保存到当前 <span class="inline_code">VoxelStream</span> ，如果有的话。但是，这些块将充当编辑过的块，因此它们的行为就像是破坏性的更改一样。
		</div>
		
	</div>
	<!-- 右侧 - 文章目录区 -->
	<aside class="right">
		<h3>目录</h3>
		<ul>
			
		</ul>
	</aside>
	<!-- 实施语法高亮 -->
	<script>hljs.highlightAll();</script>
</body>
</html>