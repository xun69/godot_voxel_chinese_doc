---
created: 2023-09-26T22:29:22 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/performance/
author: 
---

# Performance性能

> ## Excerpt
> This section discusses performance-related topics, such as making the voxel engine run fast. It can be more technical than the other sections.本节讨论与性能相关的主题，例如使体素引擎快速运行。它可能比其他部分更具技术性。

---
This section discusses performance-related topics, such as making the voxel engine run fast. It can be more technical than the other sections.  
本节讨论与性能相关的主题，例如使体素引擎快速运行。它可能比其他部分更具技术性。

## Threads 线程

### Thread count 线程计数

This module uses threads to speed up heavy operations and avoid stalls.  
该模块使用线程来加快繁重的操作并避免停顿。

Depending on how many threads your CPU can run at the same time, the optimal number of threads can vary. This may also differ for players running your game. The module automatically determines the number of threads to use at runtime, based on how many concurrent threads the CPU supports.  
根据 CPU 可以同时运行的线程数，最佳线程数可能会有所不同。对于运行游戏的玩家，这也可能会有所不同。该模块根据 CPU 支持的并发线程数自动确定运行时要使用的线程数。

You can change how many threads are allocated in your Project Settings, in the `Voxel` section. The automatic calculation will be based on the following properties:  
您可以在项目设置的 `Voxel` 部分中更改分配的线程数。自动计算将基于以下属性：

| Parameter name 参数名称 | Type 类型 | Description 描述 |
| --- | --- | --- |
| `voxel/threads/count/minimum` | `int` | Minimum amount of threads  
最小线程数 |
| `voxel/threads/count/margin_below_maximum` | `int` | How many threads below max concurrent count should be considered maximum. `0` means the maximum concurrent count will be the maximum. `1` means the maximum concurrent count minus 1 will be the maximum.  
低于最大并发计数的线程数应视为最大值。 `0` 表示最大并发计数将是最大值。 `1` 表示最大并发计数减 1 将是最大值。 |
| `voxel/threads/count/ratio_over_maximum` | `float` | Portion of max concurrent threads to attempt using, between 0 and 1. For example, `0.5` will attempt to use half of them. The result will be clamped using the other options.  
尝试使用的最大并发线程数的一部分，介于 0 和 1 之间。例如， `0.5` 将尝试使用其中的一半。结果将使用其他选项进行钳制。 |

Several notes: 几点说明：

-   It is recommended to not use all available threads for voxel stuff. Games use more for other things, and players may even do something else in background (such as music, YouTube playlist or voice chat).  
    建议不要将所有可用的线程用于体素内容。游戏更多地用于其他事情，玩家甚至可以在后台执行其他操作（例如音乐，YouTube播放列表或语音聊天）。
-   It is not possible to use zero threads. The module is designed to use threads at the moment.  
    不能使用零线程。该模块目前设计为使用线程。
-   You can check at runtime how many theads are allocated with a script and using `VoxelEngine.get_stats()`. It is also printed if `debug/settings/stdout/verbose_stdout` is enabled in project settings (or `-v` in command line).  
    您可以在运行时检查使用脚本并使用 分配了多少头 `VoxelEngine.get_stats()` 头。如果在项目设置（或在 `-v` 命令行）中启用，也会 `debug/settings/stdout/verbose_stdout` 打印它。
-   Changing these settings requires an editor restart (or game restart) to take effect.  
    更改这些设置需要编辑器重新启动（或游戏重新启动）才能生效。

### Main thread timeout 主线程超时

Some tasks still have to run on the main thread, and sometimes their total time can exceed the duration of a frame, if we were to add all the remaining things that have to be processed.  
有些任务仍然必须在主线程上运行，如果我们要添加所有必须处理的剩余内容，有时它们的总时间可能会超过一帧的持续时间。

To mitigate this, the module has an option to stop processing these tasks beyond a certain amount of milliseconds, and continue them over next frames. In `ProjectSettings`, look for `voxel/threads/main/time_budget_ms`.  
为了缓解这种情况，模块可以选择停止处理这些任务超过一定的毫秒量，并在下一帧继续处理它们。在 中 `ProjectSettings` 查找 `voxel/threads/main/time_budget_ms` 。

## Rendering 渲染

Terrains are rendered with many unique meshes. That can amount for a lot of draw calls and work for the engine to cull. It is possible to reduce the number of blocks in several ways:  
地形使用许多独特的网格进行渲染。这相当于大量的绘制调用，并需要引擎剔除。可以通过多种方式减少块的数量：

-   Reduce view distance 缩短视距
-   Reduce LOD distance, if you use `VoxelLodTerrain`  
    减小 LOD 距离（如果使用 `VoxelLodTerrain` ）
-   Increase mesh block size: they default to 16, but it can be set to 32 instead. This reduces the number of draw calls, but may increase the time it takes to modify voxels.  
    增加网格块大小：它们默认为 16，但可以设置为 32。这将减少绘制调用的数量，但可能会增加修改体素所需的时间。

## Slow mesh updates issue with OpenGL  
OpenGL 的网格更新速度慢问题

### Issue 问题

Godot 3.x is using OpenGL, and there is an issue which currently degrades performance of this voxel engine a lot. Framerate is not necessarily bad, but the speed at which voxel terrain updates is very low, compared to what it should be. So far the issue has been seen on Windows, on both Intel or nVidia cards.  
Godot 3.x正在使用OpenGL，并且存在一个问题，该问题目前会大大降低此体素引擎的性能。帧率不一定不好，但体素地形的更新速度与应有的速度相比非常低。到目前为止，该问题已在Windows，英特尔或nVidia卡上出现。

Note: Godot 4.x will have an OpenGL renderer, but this issue has not been tested here yet.  
注意：Godot 4.x 将有一个 OpenGL 渲染器，但此问题尚未在此处进行测试。

### Workarounds 解决方法

Note: you don't have to do them all at once, picking just one of them can improve the situation.  
注意：您不必一次完成所有操作，仅选择其中之一可以改善这种情况。

-   Increase `voxel/threads/main/time_budget_ms` to a value higher than frame time (by default it is about 8 ms, which is half of a frame). However this can slowdown FPS while meshes are updated.  
    增加到 `voxel/threads/main/time_budget_ms` 高于帧时间的值（默认情况下约为 8 毫秒，即帧的一半）。但是，这可能会在更新网格时减慢 FPS。
-   Or turn on `debug/settings/stdout/verbose_stdout` in project settings. This internally enables an OpenGL debugging extension, which for some reason fixes the expected timing of OpenGL calls. It's the most effective fix regarding framerate, but has drawbacks because it prints a lot, and was intented as a debugging feature.  
    或者在项目设置 `debug/settings/stdout/verbose_stdout` 中打开。这在内部启用了 OpenGL 调试扩展，由于某种原因，该扩展修复了 OpenGL 调用的预期计时。这是关于帧速率的最有效修复，但也有缺点，因为它打印很多，并且旨在作为调试功能。
-   Or turn off `display/window/vsync/use_vsync` in project settings. Not as effective and eats more resources, but improves performance.  
    或在项目设置中关闭 `display/window/vsync/use_vsync` 。效果不佳，消耗更多资源，但提高了性能。
-   Or turn on `display/window/vsync/vsync_via_compositor` in project settings. Not as effective but can improve performance in windowed mode.  
    或者在项目设置 `display/window/vsync/vsync_via_compositor` 中打开。效果不佳，但可以提高窗口模式下的性能。

### Explanation 解释

The engine relies a lot on uploading many meshes at runtime, and this cannot be threaded efficiently in Godot 3.x so far. So instead, meshes are uploaded in the main thread, until part of the frame time elapsed. Beyond that time, the engine stops and continues next frame. This is intented to smooth out the load and avoid stutters _caused by the task CPU-side_. Other tasks that cannot be threaded are also put into the same queue, like creating colliders.  
该引擎在很大程度上依赖于在运行时上传许多网格，到目前为止，这在Godot 3.x中无法有效地线程化。因此，网格在主线程中上传，直到部分帧时间过去。超过该时间，引擎将停止并继续下一帧。这是为了平滑负载并避免由任务 CPU 端引起的卡顿。其他无法线程化的任务也会放入同一队列中，例如创建碰撞体。

Unfortunately, the first call to OpenGL during the frame appears to take a whopping 15 milliseconds _on the CPU_. This happens no matter how heavy the call is. The voxel engine detects that, and immediately stops uploading meshes, thinking it has done too much. As a result, typically only one mesh ends up being uploaded each frame, which is ridiculously low. We could lift the time limit, but if it were to continue running tasks, it would start stuttering due to overshooting the 16ms limit of the frame.  
不幸的是，在帧期间对OpenGL的第一次调用似乎在CPU上花费了惊人的15毫秒。无论呼叫有多重，都会发生这种情况。体素引擎检测到这一点，并立即停止上传网格，认为它做得太多了。因此，通常每帧最终只上传一个网格，这太低了。我们可以取消时间限制，但如果它继续运行任务，它会由于超过帧的 16 毫秒限制而开始卡顿。

When one workaround is used, like enabling `verbose_stdout`, this slowdown completely disappears. Instead, the "delay" moves at the end of the frame. This has been linked to a debugging OpenGL extension getting turned on. For more information, see [Godot issue #52801](https://github.com/godotengine/godot/issues/52801).  
当使用一种解决方法（例如启用 `verbose_stdout` ）时，这种减速将完全消失。相反，“延迟”在帧的末尾移动。这已链接到打开的调试 OpenGL 扩展。有关更多信息，请参阅 Godot 问题 #52801。

## Slowdown when moving fast with Vulkan  
使用 Vulkan 快速移动时速度减慢

### Issue 问题

If you move fast while near a terrain with a lot of chunks (mesh size 16 and high LOD detail), the renderer can cause noticeable slowdowns. This is because Godot4's Vulkan allocator is much slower to destroy mesh buffers than Godot 3 was, and it does that on the main thread. When you move fast, a lot of meshes get created in front of the camera, and a lot get destroyed behind the camera at the same time. Creation is cheap, destruction is expensive.  
如果在具有大量块（网格大小为 16 和高 LOD 细节）的地形附近快速移动，渲染器可能会导致明显的减速。这是因为Godot4的Vulkan分配器破坏网格缓冲区的速度比Godot 3慢得多，而且它在主线程上这样做。当您快速移动时，会在摄像机前创建许多网格体，同时会在摄像机后面破坏很多网格体。创造是廉价的，破坏是昂贵的。

This was observed by profiling with Tracy in a `release_debug` build (typical mode used for official optimized builds):  
这是通过在 `release_debug` 构建中使用 Tracy 进行分析（用于官方优化构建的典型模式）观察到的：

![Screenshot of Tracy profiler showing slow buffer deallocation](https://voxel-tools.readthedocs.io/en/latest/images/tracy_profile_slow_vulkan_dealloc.webp)

Lots of buffers get freed on the main thread at the end of the frame, and it can take a while, causing a CPU spike. On the other hand, there is no such issue when the same amount of meshes is allocated. This issue also was not noticeable in Godot 3.  
在帧结束时，主线程上会释放大量缓冲区，这可能需要一段时间，从而导致 CPU 峰值。另一方面，当分配相同数量的网格时，不存在这样的问题。这个问题在戈多3中也不明显。

This problem reproduces specifically when a lot of small meshes are destroyed (small as in 16x16 pieces of terrain, variable size), while a lot of them (thousands) already exist at the same time. Note, some of them are not necessarily visible.  
当许多小网格被破坏（小如 16x16 地形，大小可变）时，这个问题会特别重现，而其中很多（数千个）已经同时存在。请注意，其中一些不一定可见。

### Workarounds 解决方法

It is not possible for the module to just "pool the meshes", because when new meshes need to be created, the API requires to create new buffers anyways and drops the old ones (AFAIK). It is also not possible to use a thread on our side because the work is deferred to the end of the frame, not on the call site.  
模块不可能只是“池化网格”，因为当需要创建新网格时，API 无论如何都需要创建新的缓冲区并删除旧缓冲区 （AFAIK）。也不可能在我们这边使用线程，因为工作被推迟到框架的末尾，而不是在调用站点上。

A mitigation is in place to smooth the spikes by spreading the amount of destroyed meshes over time, but the slowdown is still noticeable.  
已采取缓解措施，通过随着时间的推移分散破坏的网格数量来平滑峰值，但速度仍然明显。

The only workarounds involve limiting the game:  
唯一的解决方法是限制游戏：

-   Increase mesh block size to 32 to reduce their number, at the expense of edition cost  
    将网格块大小增加到 32 个以减少其数量，但代价是版本成本
-   Limit the speed at which the player can move when close to voxels  
    限制玩家在接近体素时可以移动的速度
-   Reduce LOD distance so less blocks have to be destroyed, at the expense of quality  
    减小 LOD 距离，从而减少需要破坏的块，但会牺牲质量

## Access to voxels 访问体素

This section explains in more detail how multithreading is implemented with voxel storage, and what are the implications when you access and modify voxels.  
本节更详细地介绍如何使用体素存储实现多线程，以及访问和修改体素时的含义。

### The problem 问题

Up to version `godot3.2.3` of the module, reading and writing to voxels did not care about multithreading. It was possible to access them without locking, because all the threaded operations using them (saving and meshing) were given copies of the voxels, made on the main thread.  
在模块版本 `godot3.2.3` 之前，读取和写入体素并不关心多线程。可以在不锁定的情况下访问它们，因为使用它们的所有线程操作（保存和网格划分）都获得了在主线程上创建的体素副本。

This made things simple, however it causes several issues.  
这使事情变得简单，但是它会导致几个问题。

-   If threads are unable to consume tasks faster than they are issued, copies of voxel data will keep accumulating rapidly and make the game run out of memory.  
    如果线程无法以比发出任务更快的速度消耗任务，则体素数据的副本将继续快速累积，并使游戏耗尽内存。
-   Copying blocks and their neighbors takes time and is potentially wasteful because it's not guaranteed to be used.  
    复制块及其邻居需要时间，并且可能会浪费，因为它不能保证被使用。
-   It assumes the threaded task will only need to access a specific block at a fixed LOD, which is not always the case in other voxel engines (such as UE4 Voxel Plugin by Phyronnaz). For example, Transvoxel running on a big block may attempt to access higher-resolution blocks to better approximate the isosurface, which is not possible with the current approach.  
    它假设线程任务只需要访问固定LOD的特定块，而在其他体素引擎（例如Phyronnaz的UE4体素插件）中并不总是如此。例如，在大块上运行的Transvoxel可能会尝试访问更高分辨率的块以更好地近似等值面，这在当前方法中是不可能的。

### Internal changes 内部更改

The old design starts to change in version `godot3.2.4`. Copies aren't made preemptively on the main thread anymore, and are done in the actual threaded task instead. This means accessing voxels now require to lock the data during each transaction, to make sure each thread gets consistent data. Locking is required **if you access voxels which are part of a multithreaded volume**, like a terrain present in the scene tree. You don't need to if you know the data is not used by any other thread, like inside generators, custom streams, known copies or other storage not owned by an active component of the voxel engine.  
旧设计开始在版本中 `godot3.2.4` 发生变化.副本不再在主线程上抢占式制作，而是在实际的线程任务中完成。这意味着访问体素现在需要在每次事务期间锁定数据，以确保每个线程获得一致的数据。如果访问属于多线程体积一部分的体素（如场景树中存在的地形），则需要锁定。如果您知道数据未被任何其他线程使用，例如内部生成器、自定义流、已知副本或不属于体素引擎活动组件的其他存储，则无需这样做。

#### RWLocks per VoxelBuffer

The locking strategy was initially implemented by adding an `RWLock` on every `VoxelBuffer`. Such locks are read-write-locks, also known as shared mutexes.  
锁定策略最初是通过 `RWLock` 在每个 . `VoxelBuffer` 此类锁是读写锁，也称为共享互斥锁。

While simple, this method meant that if you had a 16x16x16 loaded terrain area containing voxels, you'd have to allocate 4,096 `RWLocks` from the system, and lock them all if a region needed to be accessed. For example, updating a mesh means accessing a block and its 26 neighbors, so 27 locks. They also had to be locked in a specific order, because two threads trying to lock multiple blocks in different order would lead to a dead-lock, freezing the game. `RWLock` is also quite heavy on Windows, taking 244 bytes (half of the base data structure for data blocks). Besides, certain platforms (such as consoles or mobile systems) might not allow creating that many locks.  
这种方法虽然简单，但意味着如果您有一个包含体素的 16x16x16 加载地形区域，则必须 `RWLocks` 从系统中分配 4,096 个，并在需要访问某个区域时将它们全部锁定。例如，更新网格意味着访问一个块及其 26 个邻居，即 27 个锁。它们还必须按特定顺序锁定，因为两个线程试图以不同的顺序锁定多个块会导致死锁，从而冻结游戏。 `RWLock` 在Windows上也相当重，占用244字节（数据块基本数据结构的一半）。此外，某些平台（例如控制台或移动系统）可能不允许创建那么多锁。

#### Spatial lock (17/06/2023)  
空间锁定 （17/06/2023）

Later on, `RWLocks` were removed from `VoxelBuffer`. They were replaced with `VoxelSpatialLock`.  
后来， `RWLocks` 从 `VoxelBuffer` 中删除了 .它们被替换为 `VoxelSpatialLock` .

A spatial lock is just a list of boxes protected by a mutex. If you want to read voxels in a specific area, try adding that box to the list, and remove it once you're done. If you want to also write voxels, tag that box as "write mode". The spatial lock will block locking attempts if an existing box in "write mode" is intersecting yours, while allowing multiple "read mode" boxes to overlap. It essentially acts the same as `RWLock`, except only one short-duration mutex is used to protect the list, and there is no need for thousands of them to exist. This approach requires the same amount of locks regardless of the size of the box.  
空间锁只是受互斥锁保护的框列表。如果要读取特定区域中的体素，请尝试将该框添加到列表中，并在完成后将其删除。如果您还想写入体素，请将该框标记为“写入模式”。如果处于“写入模式”的现有框与你的框相交，空间锁将阻止锁定尝试，同时允许多个“读取模式”框重叠。它本质上与 相同 `RWLock` ，只是只使用一个短期互斥锁来保护列表，并且不需要存在数千个互斥锁。无论盒子的大小如何，这种方法都需要相同数量的锁。

#### Read and write 读写

Multiple threads can read the same block, but only one can modify it at once. If a thread wants to modify the block while it is already locked for _read_, the thread will be blocked until all other threads finished reading it. This can cause stutter if done too often on the main thread, so if it becomes a problem, a possible solution is to lock for _read_, copy the block and then modify it (Copy-on-Write). Another solution is to run expensive modifications in a thread and use "try lock" instead of "lock", delaying the task instead of blocking the thread.  
多个线程可以读取同一个块，但一次只能修改一个线程。如果线程想要在块已锁定读取时修改块，则该线程将被阻止，直到所有其他线程完成读取它。如果在主线程上过于频繁地操作，这可能会导致卡顿，因此如果它成为问题，可能的解决方案是锁定读取，复制块，然后修改它（写入时复制）。另一种解决方案是在线程中运行昂贵的修改并使用“try lock”而不是“lock”，延迟任务而不是阻塞线程。

### Editing voxels efficiently  
高效编辑体素

This matters for scripters.  
这对脚本编写者很重要。

If you use `VoxelTool`, all locking mechanisms are handled for you automatically. However, you must be aware that it doesn't come for free: if you want to access voxels randomly and modify them randomly, you will pretty much get the worst overhead. If you want to access a well-defined region and you know where to read, and where to write ahead of time, then optimizing becomes possible.  
如果使用 `VoxelTool` ，则会自动处理所有锁定机制。但是，您必须意识到它不是免费的：如果您想随机访问体素并随机修改它们，您将几乎获得最糟糕的开销。如果你想访问一个定义明确的区域，并且你知道在哪里阅读，以及在哪里提前写入，那么优化就成为可能。

For example, _on a terrain node_, `VoxelTool.get_voxel` or `set_voxel` are the simplest, yet the slowest way to modify voxels. This is not only because of locking, but also because the engine has to go all the way through several data structures to access the voxel. This is perfectly fine for small isolated edits, like the player digging or building piece by piece.  
例如，在地形节点上， `VoxelTool.get_voxel` 或 `set_voxel` 是修改体素的最简单但最慢的方法。这不仅是因为锁定，还因为引擎必须一直通过多个数据结构才能访问体素。这对于小型孤立的编辑来说是完全可以的，例如玩家逐块挖掘或构建。

This is what happen when you change a single voxel in a terrain (as of 17/06/2023. May also vary depending on the operation and terrain configuration):  
当您更改地形中的单个体素时，就会发生这种情况（截至 2023 年 6 月 17 日。也可能因操作和地形配置而异）：

-   Your voxel position is converted into block coordinates  
    体素位置将转换为块坐标
-   The map containing blocks is locked (so we are sure nothing else modifies it as we access it)  
    包含块的地图被锁定（因此我们确定在访问它时没有其他内容会修改它）
-   The block is queried. If it isn't loaded, the edit will fail as "area not editable".  
    查询块。如果未加载，则编辑将失败为“区域不可编辑”。
-   If the block is loaded but does not cache voxel data (in some configurations, non-edited blocks do not store data), the whole block will be generated on the spot using `VoxelGenerator` and modifiers and will be inserted in the map.  
    如果块已加载但不缓存体素数据（在某些配置中，未编辑的块不存储数据），则整个块将使用 and 修饰符当 `VoxelGenerator` 场生成，并插入到地图中。
-   The map containing blocks is unlocked  
    包含方块的地图已解锁
-   The block itself gets locked in Write mode. Nothing else can access it. If something else is already using the block, the current thread will block until it unlocks.  
    块本身在写入模式下被锁定。没有其他任何东西可以访问它。如果其他东西已经在使用该块，则当前线程将阻塞，直到解锁。
-   Your voxel position is converted into block-relative voxel position and bound-checked  
    您的体素位置将转换为块相对体素位置并进行边界检查
-   The voxel channel is accessed: if it contains no voxel data due to the whole block containing the same value (optimization), data will get allocated so that the voxel you are modifying can take a different value.  
    访问体素通道：如果由于整个块包含相同的值（优化），它不包含体素数据，则将分配数据，以便您正在修改的体素可以采用不同的值。
-   The channel's format is checked: coming from a script, the value you pass could be a 64-bit integer or a float, but channel data may be 8, 16, 32 or 64 bits with various encodings. By default, it is 16 bits, so the value may get clamped and encoded.  
    检查通道的格式：来自脚本，您传递的值可以是 64 位整数或浮点数，但通道数据可以是 8、16、32 或 64 位，具有各种编码。默认情况下，它是 16 位，因此该值可能会被钳位和编码。
-   The value actually gets stored  
    值实际存储
-   The block is unlocked and marked as modified  
    块已解锁并标记为已修改
-   The terrain is notified that a change occurred in the block you edited.  
    系统会通知地形您编辑的街区发生了更改。
-   If the terrain has a mesher, a re-meshing task will be scheduled (if not already done so far) to update visuals and maybe collisions.  
    如果地形有网格划分器，则将安排重新网格划分任务（如果到目前为止尚未完成）以更新视觉效果，甚至更新碰撞。
-   If the terrain has a network synchronizer, it will schedule an "area changed" RPC message.  
    如果地形具有网络同步器，它将计划“区域已更改”RPC 消息。
-   If the terrain has a VoxelInstancer, it will check if instances lost contact with ground.  
    如果地形具有体素实例，它将检查实例是否与地面失去联系。

As you can see, a lot is going on with a single voxel. Repeating this all over for many voxels is not efficient. That's why bulk edits may be preferred, because a lot of these operations will happen only once for the whole edit, an the only thing that will get executed many times is the actual voxel data changes.  
如您所见，单个体素正在发生很多事情。对许多体素重复此操作是没有效率的。这就是为什么批量编辑可能是首选的原因，因为在整个编辑过程中，许多这些操作只会发生一次，唯一会执行多次的是实际的体素数据更改。

If you want to excavate whole chunks or generating structures, try to use specialized bulk functions instead, such as `do_sphere()`, `do_box()`, `raycast` or `paste()`. These will be more efficient because they can cache data structures on the way and perform locking in the best way they can.  
如果要挖掘整个块或生成结构，请尝试改用专用的批量函数，例如 `do_sphere()` 、 `do_box()` 或 `raycast` `paste()` 。这些将更有效，因为它们可以在途中缓存数据结构并以最佳方式执行锁定。

If your changes are very custom or depend on a lot of pre-existing voxels, you can use `copy()` to extract a chunk of voxels into a `VoxelBuffer` so you can read them very fast without locking. You can even choose to do your changes on that same buffer, and finally use `paste()` when you're done.  
如果您的更改非常自定义或依赖于大量预先存在的体素，则可以使用 将 `copy()` 体素块提取到 中 `VoxelBuffer` ，以便您可以非常快速地阅读它们而无需锁定。您甚至可以选择在同一缓冲区上进行更改，最后在完成后使用 `paste()` 。

## Tuning `VoxelGeneratorGraph` 调优 `VoxelGeneratorGraph`

`VoxelGeneratorGraph` uses a number of optimization strategies to make the calculations faster. You may want to fine-tune them in some cases depending on the kind of volume you want to generate, although it should run ok by default. When you get more familiar with the tool it may be useful to know how it works under the hood, notably to troubleshoot generation issues when they occur.  
`VoxelGeneratorGraph` 使用多种优化策略来加快计算速度。在某些情况下，您可能希望根据要生成的卷类型对其进行微调，尽管默认情况下它应该运行正常。当您更熟悉该工具时，了解它在后台的工作方式可能会很有用，尤其是在发生生成问题时对其进行故障排除。

### Buffer processing 缓冲处理

Contrary to many node-based or expression tools existing in Godot so far, voxel graphs are not tailored to run on voxels one by one. The main use case is to process a bunch of them. Indeed, for a 16x16x16 block, there are 4096 voxels to generate. That would mean traversing the entire graph 4096 times, and the cost of doing that individually can exceed the cost of the calculations themselves. Besides, switching constantly between node types to run different operations is not CPU-friendly due to all the jumps required.  
与迄今为止Godot中存在的许多基于节点或表达式的工具相反，体素图并不是为逐个在体素上运行而量身定制的。主要用例是处理一堆。实际上，对于 16x16x16 块，需要生成 4096 个体素。这意味着遍历整个图形 4096 次，单独执行此操作的成本可能超过计算本身的成本。此外，由于需要所有跳转，在节点类型之间不断切换以运行不同的操作对 CPU 不友好。

So instead, outputs of each node are associated small buffers for a subset of the voxels, say, a 16x16 slice. Then, the graph is traversed once ahead-of-time to obtain a simple list of operations. It is guaranteed that if a node depends on another, the other will have run before.  
因此，相反，每个节点的输出都是体素子集（例如 16x16 切片）的关联小缓冲区。然后，提前遍历一次图形以获得简单的操作列表。可以保证，如果一个节点依赖于另一个节点，则另一个节点之前会运行。

![Graph to operations schema](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_operation_list.webp)

Finally, the generator executes the list, node by node, and each node computes a bunch of voxels at once instead of just one. This ensures that the CPU is almost exclusively used for the operations themselves, providing performance similar to C++, while graph traversal becomes neglibible. It also offers the opportunity to use [SIMD](https://en.wikipedia.org/wiki/SIMD) very easily, which can be even faster than if the code was written in plain C++.  
最后，生成器逐个节点执行列表，每个节点一次计算一堆体素，而不仅仅是一个。这确保了 CPU 几乎专门用于操作本身，提供类似于C++的性能，而图形遍历变得可以忽略不计。它还提供了非常轻松地使用 SIMD 的机会，这比用普通C++编写的代码还要快。

Buffer processing is mostly an internal detail so there are no particular settings on the scripting API.  
缓冲区处理主要是内部细节，因此脚本 API 上没有特定设置。

### Range analysis 范围分析

Before processing voxels in a specific region of space (a box), the generator first runs a [range analysis](https://en.wikipedia.org/wiki/Interval_arithmetic) pass. Each node has an alternative implementation using intervals, with the sole purpose of estimating the range of values it will output in the area. It's like a broad-phase before the heavy work.  
在处理特定空间区域（框）中的体素之前，生成器首先运行范围分析过程。每个节点都有一个使用间隔的替代实现，其唯一目的是估计它将在该区域输出的值范围。这就像繁重工作之前的宽阶段。

It is possible to inspect results of this pass in the editor by enabling it with the `Analyse range` button. The analysis will focus on the box specified in the dialog, which will appear as a yellow wireframe in the 3D viewport.  
可以通过使用 `Analyse range` 按钮启用此通道在编辑器中检查此传递的结果。分析将侧重于对话框中指定的框，该框将在 3D 视口中显示为黄色线框。

![Analyse range editor screenshot](https://voxel-tools.readthedocs.io/en/latest/images/range_analysis_dialog.webp)

You can also hover the output label of any node to see what range was calculated for it:  
您还可以将鼠标悬停在任何节点的输出标签上，以查看为其计算的范围：

![Range analysis tooltips](https://voxel-tools.readthedocs.io/en/latest/images/range_analysis_tooltip.webp)

Note 注意

Noise is typically between -1 and 1, but we take it a step further. Ranges are approximated using maximum derivatives, which is how fast noise can vary along a given distance. Each noise algorithm has its own. We calculate noise at the center of the box, and add half of the maximum derivative, positively and negatively. In other words, in the box, we know noise cannot exceed the central value + the maximum variation along extents of the box. At close range, this can successfully detect valleys and hills, without fully computing them.  
噪声通常在 -1 和 1 之间，但我们更进一步。范围是使用最大导数近似的，这是噪声在给定距离上变化的速度。每种噪声算法都有自己的噪声算法。我们计算盒子中心的噪声，并加上最大导数的一半，正数和负数。换句话说，在盒子中，我们知道噪声不能超过中心值+沿盒子范围的最大变化。在近距离，这可以成功检测山谷和丘陵，而无需完全计算它们。

Results of this pass are used for several optimization techniques described below.  
此传递的结果用于下面描述的几种优化技术。

### SDF clipping SDF 裁剪

3D volumes represented with meshes to form a terrain have an interesting property: to generate them, we are mostly interested in the areas where voxel values are crossing the isolevel (zero). That means we could completely discard regions of space that are guaranteed to never get near zero, and simplify them to a single value (like "only matter" or "only air"). Doing that in 3 dimensions has tremendous speed implications so it is a major feature of this generator.  
用网格表示以形成地形的 3D 体积具有一个有趣的属性：要生成它们，我们最感兴趣的是体素值与等值水平（零）交叉的区域。这意味着我们可以完全丢弃保证永远不会接近零的空间区域，并将它们简化为单个值（如“仅物质”或“仅空气”）。在 3 个维度上这样做具有巨大的速度影响，因此它是该生成器的主要功能。

Range analysis is used to perform this optimization. In a given area, if the maximum value of SDF is lower than a threshold below zero, then the whole block is skipped and assigned a uniform negative value. The same happens with a threshold above zero.  
范围分析用于执行此优化。在给定区域中，如果 SDF 的最大值低于低于零的阈值，则跳过整个块并分配一个统一的负值。阈值高于零时也会发生同样的情况。

It is possible to choose that threshold with the `sdf_clip_threshold` property in the inspector. If given an extremely large value like `10000`, it will essentially turn off this optimization.  
可以使用检查器中的 `sdf_clip_threshold` 属性选择该阈值。如果给定一个非常大的值，例如 `10000` ，它基本上会关闭此优化。

It is exposed because in some situations, clipping can cause artifacts when the edge of a block is too close from a clipped one. Indeed, clipping blocks cause discontinuities in the distance field.  
它之所以公开，是因为在某些情况下，当块的边缘与剪裁的块的边缘太近时，剪切可能会导致伪影。实际上，裁剪块会导致距离场的不连续性。

![Sdf clipping schema](https://voxel-tools.readthedocs.io/en/latest/images/sdf_clipping.webp)

Usually they happen far enough from the surface to be of any concern, but sometimes they can come close if the threshold is too low:  
通常它们发生在离表面足够远的地方，以至于引起任何关注，但有时如果阈值太低，它们可能会接近：

![Sdf clipping artifacts](https://voxel-tools.readthedocs.io/en/latest/images/sdf_clipping_artifacts.webp)

So by default the threshold is above zero and should cover most cases.  
因此，默认情况下，阈值高于零，应涵盖大多数情况。

It is also possible to instruct the generator to invert clipped blocks, which will make them stand out:  
也可以指示生成器反转剪裁的块，这将使它们脱颖而出：

![Sdf clipping debug](https://voxel-tools.readthedocs.io/en/latest/images/sdf_clip_debug.webp)

### Local optimization 局部优化

Conditionals (`if/else`) are not supported by this voxel graph implementation. The main reason is because of the buffer processing approach. The CPU can churn through buffers very fast, but branching on a per-voxel basis would disrupt it. Besides, range analysis might get a lot more complicated if branching was added. They can exist within nodes, but cannot exist as a graph-level primitive. So the usual approach is to blend things by mixing, adding, subtracting parts of the graph. But when a graph becomes big, even with SDF clipping, performance could be better. Conditionals are often used to optimize locally, so how can we do this without?  
此体素图实现不支持条件 （ `if/else` ）。主要原因是缓冲区处理方法。CPU 可以非常快速地搅动缓冲区，但基于每个体素进行分支会中断它。此外，如果添加分支，范围分析可能会变得更加复杂。它们可以存在于节点中，但不能作为图形级基元存在。因此，通常的方法是通过混合，添加，减去图形的各个部分来混合事物。但是，当图形变大时，即使使用 SDF 裁剪，性能也可能更好。条件通常用于局部优化，那么如果没有条件，我们怎么能做到这一点呢？

Let's consider an example world made of two biomes, each generated with a big node setup, and blended together across the world's X axis.  
让我们考虑一个由两个生物群落组成的示例世界，每个生物群落都由一个大节点设置生成，并在世界的 X 轴上混合在一起。

![Two biomes](https://voxel-tools.readthedocs.io/en/latest/images/biomes.webp)

If we don't optimize this, both biomes will constantly get calculated at every point of space close enough to the surface. But if we look at the range analysis we performed earlier, and focus on one of the biomes, we notice that the range of values received by the `Mix` node are such that only one biome is blended. In other words, one of the inputs of `Mix` has no effect on its result, and is therefore ignored there.  
如果我们不对此进行优化，两个生物群系都会在足够接近地表的每个空间点上不断计算。但是，如果我们查看之前执行的范围分析，并专注于其中一个生物群系，我们会注意到 `Mix` 节点接收的值范围使得只有一个生物群系被混合。换句话说，其中一个 `Mix` 输入对其结果没有影响，因此在那里被忽略。

![Ignored input](https://voxel-tools.readthedocs.io/en/latest/images/range_of_ignored_input.webp)

So each biome then only computes its own branch when far away enough from the blending area:  
因此，每个生物群系只有在离混合区域足够远时才计算自己的分支：

![Ignored biome range debug](https://voxel-tools.readthedocs.io/en/latest/images/biomes_optimization.png)

Thanks again to range analysis, the generator is able to detect this locally, and _dynamically skips whole branches of nodes_ if they are found to not affect the final result. Therefore, it is not required to add conditionals for this use case, it's done automatically. You can visualize this by turning on the analysis tool, which will grey out nodes that are ignored in the specified area.  
再次感谢范围分析，生成器能够在本地检测到这一点，如果发现节点的整个分支不影响最终结果，则动态跳过它们。因此，不需要为此用例添加条件，它是自动完成的。您可以通过打开分析工具来可视化这一点，该工具将使指定区域中忽略的节点变灰。

Internally, the generator parses the graph locally (using a faster data structure since the graph is compiled) to obtain an alternative list of operations. This list is currently nicknamed an `execution map`, because it maps the full list of operations to a reduced one.  
在内部，生成器在本地解析图形（使用更快的数据结构，因为图形已编译）以获取替代操作列表。此列表当前昵称为 `execution map` ，因为它将完整的操作列表映射到简化的操作列表。

![Execution map schema](https://voxel-tools.readthedocs.io/en/latest/images/voxel_graph_operation_list_optimized.webp)

This setting can be toggled in the inspector.  
可以在检查器中切换此设置。

Note 注意

This feature may be more or less precise depending on the range of values parts of the graph are producing. So it is possible that two different graphs providing the same result can run at different speeds. For this reason, analysing ranges can prove useful to understand why parts of the graph are still computed.  
此功能可能或多或少精确，具体取决于图形各部分生成的值范围。因此，提供相同结果的两个不同图形可能会以不同的速度运行。出于这个原因，分析范围对于理解为什么仍然计算图形的某些部分很有用。

### Subdivision 细分

Previous optimizations are tied to the size of the considered area. The bigger the area, the less precise they will be. For example, with a larger box, it is more likely to find a place where voxels produce a surface. It is also more likely for more biomes or other shapes to appear and blend together. Besides, changing the size of our world chunks isn't a light decision.  
以前的优化与所考虑区域的大小相关联。面积越大，精度就越低。例如，对于较大的框，更有可能找到体素产生表面的位置。也更有可能出现更多的生物群系或其他形状并混合在一起。此外，改变我们世界块的大小并不是一个轻松的决定。

So a simple improvement is to tell the generator to further subdivide itself the region of space it works on. Usually a subdivision size of 16x16x16 is ok. 8x8x8 is even more precise, but below that size the cost of iteration will eventually exceed the cost of computations again (see Buffer processing). Subdivision sizes must also divide volume block sizes without remainder. This is mostly to avoid having to deal with buffers of different sizes.  
因此，一个简单的改进是告诉生成器进一步细分它工作的空间区域。通常 16x16x16 的细分大小是可以的。8x8x8 甚至更精确，但低于该大小，迭代成本最终将再次超过计算成本（请参阅缓冲区处理）。细分大小还必须划分卷块大小，不带余数。这主要是为了避免处理不同大小的缓冲区。

### XZ caching XZ 缓存

When generating voxel-based terrains, despite the attractiveness of overhangs, there can be a large part of your generator only relying on the X and Z coordinates. Typically, generating from 2D noise as a base layer is one of these situations. When the generator is done with a slice along X and Z, it increases Y and does the slice above. But since 2D noise only depends on X and Z, it would get recomputed again. And noise is expensive.  
生成基于体素的地形时，尽管悬垂很有吸引力，但生成器的很大一部分可能仅依赖于 X 和 Z 坐标。通常，从 2D 噪声生成作为基础层是其中一种情况。当生成器沿 X 和 Z 完成切片时，它会增加 Y 并执行上面的切片。但由于2D噪声仅取决于X和Z，因此会再次重新计算。而且噪音很贵。

This situation is similar to the following pseudocode:  
这种情况类似于以下伪代码：

```
for z in size_z:
    for x in size_x:
        for y in size_y:
            set_voxel(x, y, z, noise2d(x, z) + y)

```

Typically, to optimize this, you would move out the `noise2d` call into the outer loop, like so:  
通常，为了优化这一点，您需要将 `noise2d` 调用移出到外部循环中，如下所示：

```
for z in size_z:
    for x in size_x:
        n = noise2d(x, z)
        for y in size_y:
            set_voxel(x, y, z, n + y)

```

This way, the 2D noise is only computed once for each column of voxels along Y, which speeds up generation a lot.  
这样，沿 Y 的每列体素仅计算一次 2D 噪声，从而大大加快了生成速度。

In Voxel Graphs, the same optimization occurs. When the list of operations is computed, they are put in two groups: `XZ` and `XZY`. All operations that only depend on X and Z are put into the `XZ` group, and others go into the `XZY` group. When generating a block of voxels, the `XZ` group is executed once for the first slice of voxels, and the `XZY` group is executed for every slice, re-using results from the `XZ` group.  
在体素图中，会发生相同的优化。计算操作列表时，将它们分为两组： `XZ` 和 `XZY` 。所有仅依赖于 X 和 Z 的操作都放入组中，其他操作放入 `XZ` `XZY` 组中。生成体素块时，对体素的第一个切片执行一次组，对 `XZY` 每个切片执行组， `XZ` 重用 `XZ` 组的结果。

This optimization only applies on both X and Z axes. It can be toggled in the inspector.  
此优化仅适用于 X 轴和 Z 轴。可以在检查器中切换它。

### Buffer reduction 缓冲区减少

The graph attempts to use as few temporary buffers as possible. For example, if you have 10 nodes processing before the output, it won't necessarily allocate 10 unique buffers to store intermediary outputs. Instead, buffers will be re-used for multiple nodes, if that doesn't change the result. Buffers are assigned ahead-of-time, when the graph is compiled. It saves memory, and might improve performance because less data has to be loaded into CPU cache. This feature is disabled when the graph is compiled in debug mode, as it allows inspecting the state of each output.  
图形尝试使用尽可能少的临时缓冲区。例如，如果在输出之前有 10 个节点进行处理，则不一定会分配 10 个唯一缓冲区来存储中间输出。相反，缓冲区将重新用于多个节点，如果这不会改变结果。缓冲区是在编译图形时提前分配的。它可以节省内存，并且可能会提高性能，因为必须加载到 CPU 缓存中的数据更少。在调试模式下编译图形时，此功能将被禁用，因为它允许检查每个输出的状态。
