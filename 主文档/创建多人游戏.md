# 创建多人游戏

体素游戏中的多人游戏可以通过许多不同的细节来实现。并非支持引擎的所有功能，它仍然有点实验性，将来可能会发生变化。因此，如何在带有日期的部分中解释了如何设置多人游戏。最新的方法通常与新的/更好/更简单的方式有关，而旧的最终可能会被删除。

---

**注意**

本页假定您已经具备一般多人游戏编程方面的知识。强烈建议您事先学习。你可以看看Godot关于网络的文档页面。

---

## 2023/04/13 - 带有和 `VoxelNetworkTerrain*` 节点的 `VoxelTerrain` 服务器端查看器


这是对以前方法的新迭代，基于相同的原理，但将其集成到引擎中，并提高了速度。


服务器将是权威的，客户端只是从中接收信息。客户端和服务器将需要不同的设置。


这将依赖于Godot的高级多人游戏API，使用RPC。在地形开始处理之前设置客户端或服务器非常重要。这可以在将游戏世界添加到树中或在 中 `_ready` 初始化多人游戏之前完成。

###  在服务器上

-     
    添加到 `VoxelTerrain` 场景中。
-     
    添加一个 `VoxelTerrainMultiplayerSynchronizer` 节点作为 `VoxelTerrain` .
-     
    当玩家加入时，请确保 `VoxelViewer` 为其创建一个。分配其 `network_peer_id` 并启用 `requires_data_block_notifications` .您可能还希望关闭 `require_visuals` 代表远程玩家的查看器，因为通常不需要渲染其周围环境。

###  在客户端

-     
    添加到 `VoxelTerrain` 场景中。
-     
    将节点添加 `VoxelTerrainMultiplayerSynchronizer` 为 . `VoxelTerrain` 确保它与服务器等效项具有相同的名称。
-     
    客户端仍然需要一个 `VoxelViewer` ，这将允许地形检测何时可以卸载体素数据（服务器不发送该信息）。为了减少在块过早卸载时在地形中出现“漏洞”的可能性，您可以为服务器 `VoxelViewer` 提供稍大的视图距离。
-     
    客户端可以同步远程播放器，以便播放器可以看到它们，但您不应向其添加 （ `VoxelViewer` 只有服务器这样做）。客户端不必为远程玩家流式传输地形，它只有一个用于本地玩家的地形。

## 2022/01/31 - 带有一些脚本的 `VoxelTerrain` 服务器端查看器


这是支持功能的第一次迭代，允许实现多人游戏。


这个想法是让服务器具有权威性，客户端只是从中接收信息。

`VoxelTerrain` 在检查器中具有类别 `Networking` 。这些属性不一定特定于多人游戏，但实际上是为了试验而添加的，因此将它们组合在一起。


客户端和服务器将需要不同的设置。

###  在服务器上

-     
    正常配置 `VoxelTerrain` ，使用生成器和流。
-     
    打开 `VoxelTerrain` ，启用 `block_enter_notification_enabled`
-     
    将脚本添加到 `VoxelTerrain` 实现 `func _on_data_block_entered(info)` .每次新的体素块进入远程玩家区域时，都会调用此函数。这将是您可以将块发送到客户端的地方。您可以使用 将 `VoxelBlockSerializer` 体素数据打包到字节中。 `info.are_voxels_edited()` 布尔值可以判断块是否被编辑过：如果没有，你可以避免发送整个数据，而只是告诉客户端在本地生成块。
-     
    当玩家加入时，请确保为其创建 ， `VoxelViewer` 分配其 `network_peer_id` 并启用 `requires_data_block_notifications` .这将使地形加载其周围的块，并在需要将块发送到对等方时发出通知。
-     
    在 上 `VoxelTerrain` ，启用 `area_edit_notification_enabled`
-     
    在 `VoxelTerrain` 脚本中，实现 `func _on_area_edited(origin, size)` .每次在边界框中编辑体素时，都会调用此函数。内部的体素可能必须发送给所有足够近的玩家。您可以通过调用 `get_viewer_network_peer_ids_in_area(origin, size)` 来获取网络对等 ID 的列表。

###  在客户端

-     
    配置 `VoxelTerrain` 一个网格器，也许还有一个生成器，然后关闭 `automatic_loading_enabled` .体素只会根据服务器发送的内容进行加载。
-     
    添加处理网络消息的脚本。从服务器接收到块时，使用该 `try_set_block_data` 函数将其存储在内部 `VoxelTerrain` 。
-     
    当从服务器收到一盒已编辑的体素时，您可以使用 和 `VoxelTool` `paste` 函数来替换已编辑的体素。如果您希望客户端在本地生成块，则可以使用生成器创建一个 `generate_block_async()` 带有 .如果使用异步生成，请注意，写入的块将取消正在加载的 `try_set_block_data` 块。这意味着如果客户端在此期间收到编辑过的块，则生成块不会覆盖它。
-     
    客户端仍然需要一个 `VoxelViewer` ，这将允许地形检测何时可以卸载体素数据（服务器不发送该信息）。为了减少块过早卸载时地形中出现“漏洞”的可能性，您可以为服务器提供比服务器 `VoxelViewer` 更大的视图距离。
-     
    客户端可以同步远程播放器，以便播放器可以看到它们，但您不应向其添加 （ `VoxelViewer` 只有服务器这样做）。客户端不必为远程玩家流式传输地形，它只有一个用于本地玩家的地形。

##  使用 `VoxelLodTerrain`


目前没有支持，但已计划。

##  协议说明


Godot 中的 RPC 使用 UDP（可靠或不可靠），因此向客户端发送大量体素的速度可能有限。相反，可以选择使用 TCP 发送块以及大型编辑。具有轻量级信息的小型编辑或确定性编辑可以继续使用可靠的 UDP。问题：您必须使用两个端口，一个用于UDP，一个用于TCP。因此，继续使用可靠的UDP也许是一个更好的主意。


注意：Minecraft的网络协议完全建立在TCP之上。

## 其他探索点

-     
    块缓存和版本控制：在客户端保存块，这样服务器下次就不必在它们没有更改时再次发送它们
-     
    客户端请求替代模型：让客户端主动请求带有自定义代码的块，而不是被动地从服务器接收它们
-     
    块差异：如果客户端可以接受知道世界种子，而不是期望客户端缓存数据（这需要服务器知道客户端知道什么），而是在体素数据服务器端存储差异映射，每个体素 1 位。然后，如果不到 30% 的块发生了变化，则仅发送差额并让客户端填补空白。
