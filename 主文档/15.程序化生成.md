---
created: 2023-09-26T22:29:22 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/procedural_generation/
author: 
---

# Procedural generation程序生成

> ## Excerpt
> This section describes techniques involved in procedural generation of terrains. Some are experimental and may be adjusted. Articles will either use graphs or scripts, and can be more advanced than other sections of the documentation, so you should first get familiar with the API.本节介绍地形程序生成所涉及的技术。有些是实验性的，可以调整。文章将使用图形或脚本，并且可能比文档的其他部分更高级，因此您应该首先熟悉 API。

---
This section describes techniques involved in procedural generation of terrains. Some are experimental and may be adjusted. Articles will either use graphs or scripts, and can be more advanced than other sections of the documentation, so you should first get familiar with the API.  
本节介绍地形程序生成所涉及的技术。有些是实验性的，可以调整。文章将使用图形或脚本，并且可能比文档的其他部分更高级，因此您应该首先熟悉 API。

## Caves with graph generator  
带有图形生成器的洞穴

It is possible to generate caves by subtracting noise "worms" from a base SDF terrain. To simplify the approach, let's first look at what 2D noise looks like, with a few octaves:  
可以通过从基础 SDF 地形中减去噪音“蠕虫”来生成洞穴。为了简化方法，让我们首先看一下2D噪声是什么样子的，有几个八度：

![Noise](https://voxel-tools.readthedocs.io/en/latest/images/noise.webp)

If we multiply that noise by itself (i.e square it), we obtain this:  
如果我们将噪声乘以自身（即平方），我们得到：

![Squared noise](https://voxel-tools.readthedocs.io/en/latest/images/squared_noise.webp)

And if we clamp it to highlight values below a threshold close to zero, we can notice a path-like pattern going on:  
如果我们将其夹紧以突出显示低于接近零的阈值的值，我们可以注意到一个类似路径的模式：

![Squared noise path highlight](https://voxel-tools.readthedocs.io/en/latest/images/squared_noise_with_highlight.webp)

In 2D (or in 3D when using normalized coordinates) this is the key to produce rivers, or ravines. But the problem with caves is to obtain 3D, round-shaped "worms", not just 2D shapes. So we can cheat a little, by still using 2D noise, but instead we modulate the threshold along the Y axis. We need a parabola-shaped curve for this, which can be obtained with a second-degree polynome like `y^2 - 1`:  
在 2D 中（或在 3D 中使用归一化坐标时），这是生成河流或沟壑的关键。但洞穴的问题在于获得3D的圆形“蠕虫”，而不仅仅是2D形状。因此，我们可以通过仍然使用2D噪声来作弊，但是我们沿Y轴调制阈值。为此，我们需要一条抛物线形曲线，可以用二阶多项式获得，例如 `y^2 - 1` ：

![Cave threshold modulation](https://voxel-tools.readthedocs.io/en/latest/images/cave_threshold_modulation.webp)

Back to the voxel graph, we may connect directly the cave generation nodes to the output just to preview what they look like, without the rest of the terrain:  
回到体素图，我们可以直接将洞穴生成节点连接到输出，只是为了预览它们的外观，而无需其余地形：

![Cave voxel graph](https://voxel-tools.readthedocs.io/en/latest/images/caves_flat.webp)

After tweaking noise and other values, we obtain those famous worms, but there are two problems:  
在调整噪声和其他值后，我们得到了那些著名的蠕虫，但有两个问题：

-   The caves are still flat, they don't go up or down  
    洞穴仍然是平坦的，它们不上升或下降
-   They go on endlessly, there are no dead-ends  
    他们无休止地进行，没有死胡同

We can fix the first problem by adding an extra layer of 2D noise to the Y coordinate so it can perturb the caves vertically. Re-using the ground surface noise with an extra multiplier can prove effective sometimes, so we avoid computing extra noise.  
我们可以通过在 Y 坐标添加额外的 2D 噪声层来解决第一个问题，这样它就可以垂直扰动洞穴。用额外的乘数重新使用地表噪声有时可以证明是有效的，因此我们避免计算额外的噪声。

![Caves perturb](https://voxel-tools.readthedocs.io/en/latest/images/caves_perturb.webp)

The second problem can also be fixed with yet another layer of low-frequency noise, which can be added to the cave threshold so caves will shrink to become dead-ends on some regions. Again, adding multipliers may change how sharply that transition occurs.  
第二个问题也可以通过另一层低频噪声来解决，可以将其添加到洞穴阈值中，因此洞穴将缩小到某些区域成为死胡同。同样，添加乘数可能会改变这种转变的急剧程度。

![Cave voxel graph perturb and modulated](https://voxel-tools.readthedocs.io/en/latest/images/caves_perturb_modulated.webp)

Finally, we can blend our terrain with caves by subtracting them. This can be done with the `SdfSmoothSubtract` node, essentially doing `terrain - caves`.  
最后，我们可以通过减去洞穴来将我们的地形与洞穴混合在一起。这可以通过 `SdfSmoothSubtract` 节点来完成，本质上是做 `terrain - caves` .

![Cave voxel graph terrain subtract](https://voxel-tools.readthedocs.io/en/latest/images/caves_composed.webp)

There are likely variants of this to obtain different results.  
这种方法可能存在变体，以获得不同的结果。

## Handling block boundaries with voxel structures  
使用体素结构处理块边界

In Minecraft-style terrain, a very common problem that arises once base terrain is generated, is how to plant trees in it, because such structures would be voxels too. In that specific case, there are a number of caveats when doing that with this engine, which mainly revolve around the following limitation:  
在 Minecraft 风格的地形中，生成基础地形后出现的一个非常常见的问题是如何在其中种植树木，因为这样的结构也是体素。在这种特定情况下，使用此引擎执行此操作时有许多注意事项，主要围绕以下限制：

When generating blocks of 16x16x16 voxels, you cannot access voxels outside of this area. The engine generates blocks using multiple threads in a single pass, so accessing neighbors would severely affect performance, could break determinism, and accessing terrain directly would be unsafe.  
生成 16x16x16 体素块时，无法访问此区域之外的体素。引擎在一次传递中使用多个线程生成块，因此访问邻居会严重影响性能，可能会破坏确定性，并且直接访问地形是不安全的。

The following describes a method which does not involve accessing neighbors at all, and allows to generate trees in a terrain where the base height is deterministic (2D noise heightmap for example).  
下面描述了一种完全不涉及访问邻居的方法，并允许在基本高度是确定性的地形中生成树木（例如 2D 噪声高度图）。

### Deterministic approach 确定性方法

#### Finding where trees should grow in (X, Z)  
查找树木应该生长的位置 （X， Z）

The first thing to do is to figure out, in the current block, where should trees grow. For simplicity, we will consider it as a 2D problem, where trees can grow at specific (X, Z) positions (since Y is up). For that, we need to find positions of voxels just above ground, and do so in a deterministic manner, so that the same seed will produce the same results.  
首先要做的是弄清楚，在当前区块中，树木应该在哪里生长。为简单起见，我们将它视为一个 2D 问题，其中树木可以在特定的 （X， Z） 位置生长（因为 Y 向上）。为此，我们需要找到地面上方体素的位置，并以确定性的方式进行，以便相同的种子将产生相同的结果。

But how to make it deterministic? We can use the seed of a `RandomNumberGenerator` instance. But if we give it the seed of the world, every block will have trees at the same position in them. What we really need, is a seed that is unique per block. We can achieve that by using a hash of the 2D coordinates of the block:  
但是如何使它具有确定性呢？我们可以使用 `RandomNumberGenerator` 实例的种子。但是，如果我们给它世界种子，每个街区都会有树在相同的位置。我们真正需要的是每个区块唯一的种子。我们可以通过使用块的 2D 坐标哈希来实现这一点：

```
var block_position := Vector3i(
    origin_in_voxels.x >> 4,
    origin_in_voxels.y >> 4,
    origin_in_voxels.z >> 4) # floored division by 16

var rng := RandomNumberGenerator.new()
rng.seed = global_seed + hash(Vector2i(block_position.x, block_position.z))

```

And now we can generate how many trees are in the block, and where:  
现在我们可以生成块中有多少棵树，以及在哪里：

```
var block_size := out_buffer.get_size()
var tree_count := rng.randi_range(0, 2)
var tree_positions := []
tree_positions.resize(tree_count)
for i in tree_count:
    var tree_pos := Vector3i(
        rng.randi_range(0, block_size.x), 0, # We leave Y for later
        rng.randi_range(0, block_size.z))
    # Note, those positions are local to the block
    tree_positions[i] = tree_pos

```

#### Finding the altitude (Y)  
查找高度 （Y）

But we still need to calculate the altitude from which the tree will grow (the Y coordinate). One issue is that the engine generates cubic blocks, so when generating a given 16x16x16 voxel, you can't access what's below, you only know what's inside the area of the block.  
但是我们仍然需要计算树生长的高度（Y 坐标）。一个问题是引擎生成立方块，因此在生成给定的 16x16x16 体素时，您无法访问下面的内容，您只知道块区域内的内容。

However, if base terrain is generated using 2D heightmap noise, then we can calculate how high terrain is at any (x, z) coordinate by computing the height function again, wherever we need. Assuming we already have such function as `func get_height(x: float, y: float) -> float`, we can complete the Y coordinate like so:  
但是，如果使用 2D 高度图噪声生成基础地形，那么我们可以根据需要通过再次计算高度函数来计算任何 （x， z） 坐标处的地形高度。假设我们已经有了这样的 `func get_height(x: float, y: float) -> float` 函数，我们可以像这样完成 Y 坐标：

```
for i in len(tree_positions):
    var tree_pos_local : Vector3i = tree_positions[i]
    # Use world coordinates for this
    var tree_pos_global := tree_pos_local + origin_in_voxels
    tree_pos_global.y := get_height(tree_pos_global.x, tree_pos_global.z)
    # And bring back to local
    tree_pos_local = tree_pos_global - origin_in_voxels
    # And store back into the array
    tree_positions[i] = tree_pos_local

```

#### Placing the tree 放置树

Now we should be able to place the tree, but what if positions we found are outside the block? We can't set voxels at these positions.  
现在我们应该能够放置树，但是如果我们找到的位置在块外怎么办？我们无法在这些位置设置体素。

What we can do, is to first determine how big the tree will be. Once we know its bounding box, we can place voxels, but only those intersecting our block.  
我们能做的，是首先确定树会有多大。一旦我们知道它的边界框，我们就可以放置体素，但只能放置那些与我们的块相交的体素。

To determine how big the tree is, it sounds like we have to generate the tree first, and then determine its bounding box in voxels. We can do that in a separate blank buffer with large enough size, or using a `Dictionary` of `Vector3i` keys and `int` values. But at the end, it is preferable to store the result in an optimized `VoxelBuffer` of the right size.  
要确定树有多大，听起来我们必须先生成树，然后以体素为单位确定它的边界框。我们可以在具有足够大的单独空白缓冲区中执行此操作，或者使用 a `Dictionary` of `Vector3i` 键和 `int` 值。但最后，最好将结果存储在适当大小的优化 `VoxelBuffer` 中。

We won't describe how to generate the tree itself here, it's not really the point of this article and can be different with plenty of factors. But it could just be a vertical bar of trunk voxels, with a sphere of leaves on top. It is possible to optimize this step by pre-generating (or making by hand) a bunch of trees ahead of time and store them in a list, so all tree bounds are known and no need to spend time generating them in detail.  
我们不会在这里描述如何生成树本身，这不是本文的重点，并且可能因很多因素而有所不同。但它可能只是一个垂直的树干体素条，上面有一个叶子球体。可以通过提前预生成（或手工制作）一堆树并将它们存储在列表中来优化此步骤，因此所有树边界都是已知的，无需花时间详细生成它们。

We can pack tree data into a class:  
我们可以将树数据打包到一个类中：

```
class TreeInfo:
    # Position of the tree relative to our current block
    var instance_position := Vector3i()
    # Buffer storing only the tree, like a model, so it can later be pasted in the world
    var voxels : VoxelBuffer
    # Position of the base of the tree, within the VoxelBuffer containing the model of the tree
    var trunk_base_position := Vector3i()

```

So we can have a list of trees instead of just their positions:  
因此，我们可以有一个树列表，而不仅仅是它们的位置：

```
var trees : Array[TreeInfo] = []
for tree_pos in tree_positions:
    var tree : TreeInfo = generate_tree(rng)
    tree.position = tree_pos
    trees.append(tree)

```

We may wrap this logic in a function `func generate_trees_for_block(block_position: Vector3i) -> Array[TreeInfo]`, because it may be useful later.  
我们可以把这个逻辑包装在一个函数 `func generate_trees_for_block(block_position: Vector3i) -> Array[TreeInfo]` 中，因为它以后可能会有用。

Once we know the bounds of each tree, we can check if they intersect with the current block. If they do, we can use the `paste_masked` method to plant just the tree, without replacing solid voxels with empty ones from the tree's `VoxelBuffer`:  
一旦我们知道每棵树的边界，我们就可以检查它们是否与当前块相交。如果他们这样做，我们可以使用 `paste_masked` 该方法只种植树，而无需用树中的空体素替换实心体素 `VoxelBuffer` ：

```
# AABB of our current block, in local coordinates
var block_aabb := AABB(Vector3(), block_size.get_size() + Vector3i(1, 1, 1))

var voxel_tool := out_buffer.get_voxel_tool()

# Paste intersecting trees
for tree in trees:
    var lower_corner_pos := tree.instance_position - tree.trunk_base_position
    var tree_aabb := AABB(lower_corner_pos, tree.voxels.get_size() + Vector3(1,1,1))

    if tree_aabb.intersects(block_aabb):
        voxel_tool.paste_masked(lower_corner_pos, tree.voxels, 
            # Which channel we want to paste
            1 << VoxelBuffer.CHANNEL_TYPE,
            # Masking 0, since 0 is considered air
            VoxelBuffer.CHANNEL_TYPE, 0)

```

#### Fixing overlaps 修复重叠

Now trees should appear in the world, but when they overlap block borders, they will be cutoff. The reason is that each block is unaware of its neighbors, they generate only trees that originate inside them in the X and Z axes, and only affect voxels in themselves, since they can't modify their neighbors.  
现在世界上应该会出现树木，但是当它们与块边界重叠时，它们将被切断。原因是每个块都不知道其邻居，它们只生成源自 X 轴和 Z 轴内部的树，并且只影响体素本身，因为它们无法修改它们的邻居。

![Schema of individual blocks generating cutoff trees](https://voxel-tools.readthedocs.io/en/latest/images/tree_generation_cutoff_schema.webp)

We could decide to clamp their position so that they never overlap, but that might not be acceptable, given how "aligned" they will look in the game.  
我们可以决定固定它们的位置，使它们永远不会重叠，但考虑到它们在游戏中看起来多么“对齐”，这可能是不可接受的。

We can workaround this by applying the same reasoning we did to obtain their altitude. Instead of just considering trees in the current block, we can also check trees that would generate in neighbor blocks, since we can re-run the function to get them deterministically from a given block position. Then all we have to do is keep only those intersecting our block. Each block will then generate with neighbor trees in the right locations.  
我们可以通过应用与获取其高度相同的推理来解决此问题。除了考虑当前块中的树，我们还可以检查将在相邻块中生成的树，因为我们可以重新运行函数以从给定块位置确定地获取它们。然后我们所要做的就是只保留那些与我们的块相交的。然后，每个块将在正确的位置生成相邻树。

![Schema of neighbor trees being generated to take into account overlaps with the current block](https://voxel-tools.readthedocs.io/en/latest/images/tree_generation_neighbor_fix_schema.webp)

Note that it means each block will recalculate the locations of its own trees and neighbor trees, so trees in a given block will be calculated more than once during generation of the world. That also means `generate_tree` will be called more than once too. But if we cache generated tree models ahead of time (before the game starts), this process will be a lot cheaper.  
请注意，这意味着每个块将重新计算其自己的树和相邻树的位置，因此给定块中的树将在生成世界期间多次计算。这也意味着 `generate_tree` 也会被多次调用。但是如果我们提前缓存生成的树模型（在游戏开始之前），这个过程会便宜得多。

```
var trees : Array[TreeInfo] = []

# Get trees that originate from the current block and its neighbors
for nz in range(-1, 2):
    for nx in range(-1, 2):
        var trees_in_block := generate_trees_for_block(block_position + Vector3i(nx, 0, nz))
        trees.append_array(trees_in_block)

# Paste intersecting trees
for tree in trees:
    # Earlier code for pasting trees
    # ...

```

This method has been implemented [in this demo](https://github.com/Zylann/voxelgame/blob/2fa552abfdf52c688bbec27edd676018a31373e0/project/blocky_game/generator/generator.gd#L144), although the code is a bit different.  
此方法已在此演示中实现，尽管代码略有不同。

This approach is also used in Voronoi noise (also known as cellular noise in FastNoiseLite) to produce seamless cells.  
这种方法也用于Voronoi噪声（在FastNoiseLite中也称为蜂窝噪声）以产生无缝单元。

#### Limitations 限制

Of course this method has its limitations: if our terrain is more than just a heightmap, includes floating islands, complex carvings or 3D noise structures, it can make the process of finding altitude more complicated. At worse, generating neighbor columns of voxels or entire blocks would become necessary just to find the highest voxel, which would make it too slow.  
当然，这种方法有其局限性：如果我们的地形不仅仅是一个高度图，包括浮岛、复杂的雕刻或 3D 噪声结构，它会使寻找高度的过程更加复杂。更糟糕的是，生成体素或整个块的相邻列将变得必要，只是为了找到最高的体素，这将使它太慢。

To counter this, we could maybe cache generated blocks...  
为了解决这个问题，我们也许可以缓存生成的块......

### Caching approach 缓存方法

There is another approach to this problem, which can also be implemented with today's API limitations. But as we will see, it is actually more complex than it looks because of threading problems:  
这个问题还有另一种方法，也可以通过今天的 API 限制来实现。但正如我们将看到的，由于线程问题，它实际上比看起来更复杂：

The idea is, if generating a block requires to know its neighbors, then a generator can just generate them as well, at least only what is required. Here, we will consider a case where each block can affect its neighbors in a 1-block radius, but depending on the case that dependency can extend further in each axis.  
这个想法是，如果生成一个块需要知道它的邻居，那么生成器也可以生成它们，至少只生成所需的。在这里，我们将考虑一种情况，即每个块可以在 1 块半径内影响其邻居，但根据情况，依赖性可以在每个轴上进一步扩展。

#### Implementation 实现

Warning 警告

code in this article hasn't been tested and might not work as-is. It is only here to give an idea of what would be involved.  
本文中的代码尚未经过测试，可能无法按原样工作。它只是在这里给出一个想法，将涉及什么。

A generator can have a member variable containing partially-generated blocks:  
生成器可以有一个包含部分生成的块的成员变量：

```
class GeneratingBlock:
    var voxels : VoxelBuffer

    func _init():
        voxels = VoxelBuffer.new()
        voxels.create(16, 16, 16)

# [Vector3i] => GeneratingBlock
# Stores blocks that have been partially generated but not directly requested.
# These blocks have not finished generating, so they are not yet in the terrain.
# When a block is fully generated, we can remove it from here since we will not need it again.
var _generating_blocks := {}
# Since VoxelGenerators are invoked from multiple threads,
# we have to protect member variables against concurrent access.
var _generating_blocks_mutex := Mutex.new()

```

As you can see, as soon as we consider actual access to neighbors, we also have to deal with multi-threading, so mutexes become necessary.  
如您所见，一旦我们考虑对邻居的实际访问，我们还必须处理多线程，因此互斥锁变得必要。

When a generator is asked to generate a given block, it can look into `_generating_blocks` first if that block has already started generating, due to neighbors themselves generating in different threads. Indeed, if a block can affect its neighbors when it generates, then the opposite can happen too. Keep this in mind!  
当要求生成器生成给定的块时，它可以首先查看 `_generating_blocks` 该块是否已经开始生成，因为邻居本身在不同的线程中生成。事实上，如果一个区块在生成时会影响它的邻居，那么相反的情况也会发生。请记住这一点！

Then we will also check each neighbor we want to access. For each position missing a block, we will partially generate them (only base ground for example) and store them in `_generating_blocks`.  
然后我们还将检查我们要访问的每个邻居。对于每个缺少块的位置，我们将部分生成它们（例如仅基础）并将它们存储在 `_generating_blocks` .

Now, once we have the current block and its neighbors, we can generate base terrain AND trees for our current block AND its neighbors. The important part is that the current block will then contain ALL trees that intersect with it. Neighbors will not have them all because they won't have neighbor's neighbor trees (that's why we consider them partial). The code would have to take care of different local offsets when pasting trees since each block has a different origin in the world.  
现在，一旦我们有了当前区块及其邻居，我们就可以为当前区块及其邻居生成基础地形和树木。重要的部分是当前块将包含与其相交的所有树。邻居不会拥有它们，因为他们不会有邻居的邻居树（这就是为什么我们认为它们是部分的）。在粘贴树时，代码必须处理不同的本地偏移量，因为每个块在世界上都有不同的起源。

Once we are done, if the current block was in `_generating_blocks` at the start, we can remove it, since there should be nothing else affecting it. We will leave the 8 neighbors partially generated, if any, for other threads to start from in case they are requested.  
完成后，如果当前块在开始时处于状态 `_generating_blocks` ，我们可以将其删除，因为应该没有其他影响它的东西。我们将保留部分生成的 8 个邻居（如果有的话），以便在请求时从其他线程开始。

```
var block_position := Vector3i(
    origin_in_voxels.x >> 4,
    origin_in_voxels.y >> 4,
    origin_in_voxels.z >> 4) # floored division by 16

_generating_blocks_mutex.lock()

# [Vector3i] => GeneratingBlock
# Subset of blocks in the world, the central one being the current one
var blocks := {}

for nz in range(-1, 2):
    for nx in range(-1, 2):
        var block_position := current_block_position + Vector3i(nx, 0, nz)
        if _generating_blocks.has(block_position):
            blocks[block_position] = _generating_blocks[block_position]
        else:
            var block = GeneratingBlock.new()
            generate_base_ground(block)
            _generating_blocks[block_position] = block
            _blocks[block_position] = block

for block_position in blocks:
    var block = blocks[block_position]
    # Generate trees using some function, which also takes the map of the subset of blocks,
    # since it may be able to modify more than one block if trees overlap.
    # Following this process, the central block will have trees originating from it,
    # but also trees originating from ALL its neighbors.
    generate_trees(block, blocks)

var central_block : GeneratingBlock = _generating_blocks[current_block_position]
_generating_blocks.erase(current_block_position)

_generating_blocks_mutex.unlock()

out_voxels.copy_from(central_block.voxels)

```

#### Caveats 注意事项

The catch is, for all this to be done consistently, _we have to keep generating blocks locked with `Mutex` for the whole duration of the current block's generation_. If we don't do this, other threads could start messing with the same data and bad things could happen. This is what makes this method potentially very slow.  
问题是，为了始终如一地完成所有这些工作，我们必须在当前区块生成的整个过程中不断生成锁定 `Mutex` 的区块。如果我们不这样做，其他线程可能会开始弄乱相同的数据，并且可能会发生不好的事情。这就是这种方法可能非常慢的原因。

In the code shown earlier, `_generating_blocks_mutex` is naively locked for the entire generation process, which will slow down generation down to one thread, while other threads will be stuck waiting.  
在前面显示的代码中，在整个生成过程中被天真地锁定，这会减慢生成速度到一个线程， `_generating_blocks_mutex` 而其他线程将卡住等待。

Generating 1 block requires partially generating 8 others. We could consider locking `_generating_blocks` and indivdual `GeneratingBlock` separately, since threads could be working on sets of blocks that are not touching each other. But in the case they touch each other, each thread will want to lock 8 mutexes. But this can cause deadlocks, where two threads wait each other indefinitely.  
生成 1 个块需要部分生成其他 8 个块。我们可以考虑 `GeneratingBlock` 分别锁定 `_generating_blocks` 和单独，因为线程可以在不相互接触的块集上工作。但是在它们相互接触的情况下，每个线程都需要锁定 8 个互斥锁。但这可能会导致死锁，其中两个线程无限期地相互等待。

Let's say 2 threads want both to lock block A and B at different times:  
假设 2 个线程希望在不同时间锁定块 A 和 B：

-   Thread 1 locks block A  
    螺纹 1 锁块 A
-   Thread 2 locks block B  
    螺纹 2 锁块 B
-   Thread 1 locks block B: already locked, so it has to wait  
    线程 1 锁定块 B：已经锁定，因此必须等待
-   Thread 2 locks block A: already locked, so it has to wait  
    线程 2 锁定块 A：已经锁定，因此必须等待
-   Now both threads are stuck waiting forever.  
    现在两个线程都永远等待。

On top of this, if the dependency distance needs to be larger than 1 block, it can very quickly become a lot more expensive. 1-block dependency requires to check 26 neighbors. 2-block dependency requires 124 neighbors. 3-block dependency requires 342 neighbors...  
最重要的是，如果依赖距离需要大于 1 个块，它很快就会变得更加昂贵。1 块依赖项需要检查 26 个邻居。2 块依赖项需要 124 个邻居。3 块依赖需要 342 个邻居...

### Multi-pass generation 多通道生成

Multi-pass generation is another approach loosely inspired by the previously described "caching" method, but aiming to solve its shortcomings directly in the engine, and make the task simpler for the user.  
多通道生成是另一种受前面描述的“缓存”方法启发的方法，但旨在直接在引擎中解决其缺点，并使用户的任务更简单。

Ideas are the following:  
想法如下：

-   Split world generation into multiple passes, each with their own dependency ranges, in which case accessing neighbor voxels from a previous pass would become possible;  
    将世界生成拆分为多个通道，每个通道都有自己的依赖范围，在这种情况下，可以从以前的传递访问相邻体素;
-   Instead of waiting for their dependencies, threads would be allowed to pause their task and continue them later, allowing to do other work in the meantime.  
    线程将被允许暂停其任务并稍后继续它们，而不是等待它们的依赖项，从而允许在此期间执行其他工作。
-   Store partially-generated blocks in such a way that the user API is simplified, and eventually allowing to save partially-generated blocks so they don't have to be recomputed again next time the game is started  
    以简化用户 API 的方式存储部分生成的块，并最终允许保存部分生成的块，以便下次启动游戏时不必再次重新计算它们
-   Use a spatial lock instead of individual mutexes, to avoid deadlocks  
    使用空间锁而不是单个互斥锁，以避免死锁

However, it isn't available in the engine at the moment:  
但是，它目前在引擎中不可用：

-   It is complex to implement properly. In order to be efficient and avoid too many block lookups, the way the world streams has to account for a "pyramid" of dependencies between passes, and threads have to properly synchronize generating blocks without getting stuck.  
    正确实施很复杂。为了提高效率并避免过多的块查找，世界流的方式必须考虑传递之间的依赖关系的“金字塔”，线程必须正确同步生成块而不会卡住。
-   In some cases, an entire column of blocks is required (like Minecraft chunks), which implies there is a limit in height. The engine allows infinite height and uses cubic blocks, so that would require limits and changes just for this.  
    在某些情况下，需要一整列块（如 Minecraft 块），这意味着高度有限制。引擎允许无限高度并使用立方块，因此需要为此进行限制和更改。
-   It requires to break compatibility, because more features would have to be injected into generators to make them work in passes.  
    它需要破坏兼容性，因为必须将更多功能注入生成器才能使它们在传递中工作。
-   It would only work efficiently with a specific terrain type. It is data-heavy. `VoxelLodTerrain` wouldn't work with it, so any design changes must not impact games that don't need it, otherwise it would bloat the engine.  
    它只能在特定的地形类型下有效工作。它是数据密集型的。 `VoxelLodTerrain` 不适用于它，因此任何设计更改都不得影响不需要它的游戏，否则会使引擎膨胀。

This may be investigated in the future, as this kind of problem also occurs with other features such as light baking (which is also specific to this kind of terrain, unfortunately). At time of writing, some prerequisites have been implemented (task postponing and spatial lock), but it will take time until it gets properly integrated to the engine.  
将来可能会对此进行调查，因为此类问题也发生在其他功能上，例如轻度烘烤（不幸的是，这也是特定于这种地形的）。在撰写本文时，已经实现了一些先决条件（任务延迟和空间锁定），但需要时间才能将其正确集成到引擎中。
