---
created: 2023-09-26T22:29:22 (UTC +08:00)
tags: []
source: https://voxel-tools.readthedocs.io/en/latest/instancing/
author: 
---

# Instancing实例化

> ## Excerpt
> The module provides an instancing system with the VoxelInstancer node. This node must be added as child of a voxel terrain. It allows to spawn 3D models on top of the terrain's surface, which can later be removed when modified.该模块提供了一个带有VoxelInstancer节点的实例化系统。必须将此节点添加为体素地形的子节点。它允许在地形表面的顶部生成3D模型，以后可以在修改时将其删除。

---
The module provides an instancing system with the [VoxelInstancer](https://voxel-tools.readthedocs.io/en/latest/api/VoxelInstancer/) node. This node must be added as child of a voxel terrain. It allows to spawn 3D models on top of the terrain's surface, which can later be removed when modified.  
该模块提供了一个带有VoxelInstancer节点的实例化系统。必须将此节点添加为体素地形的子节点。它允许在地形表面的顶部生成3D模型，以后可以在修改时将其删除。

It can spawn two different kinds of objects:  
它可以生成两种不同类型的对象：

-   **Multimesh instances**. They can be extremely numerous, and can optionally have collision.  
    多网格实例。它们可以非常多，并且可以选择发生碰撞。
-   **Scene instances**. They use regular scenes, however it is much slower so should be tuned to low numbers.  
    场景实例。他们使用常规场景，但是速度要慢得多，因此应调整为低数字。

This system is primarily intented at natural spawning: grass, rocks, trees and other kinds of semi-random foliage. It is not suited for complex man-made structures like houses or villages, although scene instances can be used in some cases, if the available features suit your game.  
该系统主要用于自然产卵：草，岩石，树木和其他种类的半随机树叶。它不适合复杂的人造结构，如房屋或村庄，但如果可用功能适合您的游戏，在某些情况下可以使用场景实例。

This feature is currently only available under `VoxelLodTerrain`.  
此功能目前仅在 下 `VoxelLodTerrain` 可用。

## VoxelInstanceLibrary 体素实例库

### Library setup 库设置

In order to spawn items, `VoxelInstancer` needs a [VoxelInstanceLibrary](https://voxel-tools.readthedocs.io/en/latest/api/VoxelInstanceLibrary/) resource. This resource contains a list of all the items that can be spawned, and how they will be placed.  
为了生成项目， `VoxelInstancer` 需要一个VoxelInstanceLibrary资源。此资源包含可以生成的所有项的列表，以及如何放置这些项。

Select a `VoxelInstancer`. In the inspector, assign a library to the `library` property, or create a new embedded one. Then click on the library resource. Buttons appear at the top of the inspector:  
选择一个 `VoxelInstancer` .在检查器中，为 `library` 属性指定一个库，或创建一个新的嵌入库。然后单击库资源。按钮显示在检查器的顶部：

![Screenshot of the VoxelInstanceLibrary menu](https://voxel-tools.readthedocs.io/en/latest/images/instance_library_menu.webp)

You can add items to the library by clicking the "+" icon, and choose `Add Multimesh item`.  
您可以通过单击“+”图标将项目添加到库中，然后选择 `Add Multimesh item` 。

Items created this way come with a default setup, so you should be able to see something appear on top of the voxel surface.  
以这种方式创建的项目带有默认设置，因此您应该能够看到体素表面顶部显示的内容。

Note 注意

If you are making a planet, you may want to set the `up_mode` of `VoxelInstancer` to `Sphere` mode. This will tell the instancer where the upward direction is, and will align the items according to the local origin of the terrain.  
如果你正在制作一颗行星，你可能想将 `up_mode` of `VoxelInstancer` 设置为 `Sphere` 模式。这将告诉实例器向上的方向在哪里，并根据地形的本地原点对齐项目。

### Block LOD 块 LOD

The range at which items spawn is based on the LOD system of the voxel terrain itself. This is configured in the `lod_index` property of [VoxelInstanceLibraryItem](https://voxel-tools.readthedocs.io/en/latest/api/VoxelInstanceLibraryItem/). For example, choosing `0` will make the item spawn at the closest range, and fade quickly in the distance. Higher indexes will spawn on a larger range, so will also start to appear earlier as the player gets closer. Instances spawn in the same "blocks" as the ground.  
物品生成的范围基于体素地形本身的 LOD 系统。这是在VoxelInstanceLibraryItem `lod_index` 的属性中配置的。例如，选择 `0` 将使物品在最近的范围内生成，并在远处快速淡出。更高的索引将在更大的范围内生成，因此随着玩家越来越近，也会更早地开始出现。实例在与地面相同的“块”中生成。

![Screenshot showing the effect of lod_index on the range of instances](https://voxel-tools.readthedocs.io/en/latest/images/instances_lod_index.webp)

Usually landscapes may be composed of multiple layers so that the closer you get, the more details come in. Bigger items use high lod indexes to be seen from far away, while smaller items may use lower indexes.  
通常，景观可能由多个图层组成，因此越接近，细节就越多。较大的项目使用较高的 lod 索引从远处看到，而较小的项目可能使用较低的索引。

![Screenshot of landscape using layers of instances](https://voxel-tools.readthedocs.io/en/latest/images/landscape_with_instances.webp)

There is a balance to consider when choosing the appropriate `lod_index`: currently, larger indexes are _much more imprecise_, because they work on top of a lower-resolution mesh. When getting closer, it's possible that such instances are seen floating above ground, or sinking into it. This mostly happens in areas with sharp changes such as ridges, crevices or caves:  
在选择合适的网格时需要考虑一个平衡 `lod_index` ：目前，较大的索引更加不精确，因为它们在较低分辨率的网格之上工作。当靠近时，可能会看到这样的实例漂浮在地面上，或者沉入其中。这主要发生在山脊、裂缝或洞穴等变化剧烈的地区：

![Screemshot of misaligned instances](https://voxel-tools.readthedocs.io/en/latest/images/misaligned_instances.webp)

To combat this, you can adjust the `offset_along_normal` parameter in the `generator` associated to the item. This depends on the asset, so designing them such that they can have part of their bottom sunk into the ground can give some margin of error.  
为了解决这个问题，您可以调整与项目 `generator` 关联的 `offset_along_normal` 参数。这取决于资产，因此将它们设计为可以将部分底部沉入地下可能会产生一些误差。

Sometimes it might not be enough, so this problem still has to be worked out in the future. Possible approaches include:  
有时可能还不够，所以这个问题仍然需要在将来解决。可能的方法包括：

-   Querying the world generator to approximate the surface without using the mesh (not suitable if the ground was edited)  
    查询世界生成器以在不使用网格的情况下近似表面（如果对地面进行了编辑，则不适合）
-   Gradually snap the instances somehow as higher-resolution data becomes available  
    随着更高分辨率数据的可用，逐渐以某种方式捕捉实例
-   Load edited voxels for the entire world at once so they can be queried even from far distance (takes more memory)  
    一次加载整个世界的编辑体素，以便即使从远处也可以查询它们（占用更多内存）

Note 注意

When making grass or other items, it may be a good idea to fade meshes based on distance from the camera using a custom shader, so they won't disappear abruptly. Using a ground texture of similar colors also helps to make it blend.  
制作草或其他物品时，最好使用自定义着色器根据与摄像机的距离淡化网格，这样它们就不会突然消失。使用相似颜色的地面纹理也有助于使其混合。

### Mesh LOD 网格 LOD

A secondary LOD system is included, which applies to meshes themselves, to some limited extent. Godot 3 does not have a LOD system (Godot 4 will), so this allows to reduce vertex count over distance from within a set of visible meshes.  
包括一个辅助LOD系统，它在一定程度上适用于网格体本身。Godot 3没有LOD系统（Godot 4会），因此这允许从一组可见网格内减少远距离的顶点数量。

To use this, you have to fill the 3 mesh LOD properties on your `VoxelInstanceLibraryItem`:  
要使用它，您必须在 `VoxelInstanceLibraryItem` 以下位置填充 3 个网格 LOD 属性：

![Screenshot of mesh LOD properties](https://voxel-tools.readthedocs.io/en/latest/images/mesh_lod_properties.webp)

If only the `mesh` property is set, no LOD will be used.  
如果仅设置该 `mesh` 属性，则不会使用 LOD。

The distance at which a LOD will be chosen is currently hardcoded, because it depends on the `lod_index` the blocks for that item are loaded into, which in turn depends on the `lod_distance` property of the parent voxel terrain.  
选择 LOD 的距离当前是硬编码的，因为它取决于该项目的加载块，而后者又取决于 `lod_index` `lod_distance` 父体素地形的属性。

![Screenshot of mesh LODs with colors](https://voxel-tools.readthedocs.io/en/latest/images/mesh_lods.webp)

If you need fewer LODs, you can assign twice the same mesh. This system is quite rigid because in Godot 4 it might be changed to only have a single slot dedicated to impostor meshes. Indeed, Godot 4 might support LOD on meshes, but it is not planned for the last LODs to become impostors, so this should still be possible to achieve.  
如果需要较少的LOD，则可以分配两次相同的网格。这个系统非常严格，因为在Godot 4中，它可能会被更改为只有一个专用于冒名顶替者网格的插槽。事实上，Godot 4 可能支持网格体上的 LOD，但并没有计划让最后一个 LOD 成为冒名顶替者，所以这应该仍然可以实现。

Note 注意

Impostor meshes are simple quads that can fake the presence of the real model over far distances. For example, this is a really fast way to render forests from afar, while being able to use detailed trees when coming closer.  
冒名顶替者网格是简单的四边形，可以在很远的距离上伪造真实模型的存在。例如，这是一种从远处渲染森林的非常快速的方法，同时能够在靠近时使用详细的树木。

### Edition 版本

Editing instances manually in the editor is not supported yet. It is only possible to define where instances spawn by using procedural generation.  
尚不支持在编辑器中手动编辑实例。只能使用过程生成来定义实例生成的位置。

It is however possible to remove them from within the game, when digging the ground they spawned on.  
但是，在挖掘它们生成的地面时，可以从游戏中移除它们。

### Persistence 持久性

It is possible for some items to be persistent. This option can be enabled with the `persistent` property of [VoxelInstanceLibraryItem](https://voxel-tools.readthedocs.io/en/latest/api/VoxelInstanceLibraryItem/). If the parent terrain has a `VoxelStream` supporting it, then instances from edited blocks will be saved into the stream, and won't respawn next time the player gets close to the area. Non-persistent instances will always respawn on each surface where procedural conditions are fulfilled.  
某些项目可能是永久性的。可以使用 VoxelInstanceLibraryItem 的属性启用 `persistent` 此选项。如果父地形有 `VoxelStream` 支撑，则来自已编辑方块的实例将保存到流中，并且下次玩家靠近该区域时不会重生。非持久性实例将始终在满足过程条件的每个图面上重生。

The ID of persistent items is important, because it will be used in saved data. If you delete an item and try to load instances from a stream that still contains them, warnings will occur.  
持久性项的 ID 很重要，因为它将在保存的数据中使用。如果删除项目并尝试从仍包含实例的流中加载实例，则会出现警告。

At time of writing, only [VoxelStreamSQLite](https://voxel-tools.readthedocs.io/en/latest/api/VoxelStreamSQLite/) supports saving instances.  
在撰写本文时，只有VoxelStreamSQLite支持保存实例。

The save format is described in [this document](https://voxel-tools.readthedocs.io/en/latest/instancing/specs/instances_format.md).  
本文档介绍了保存格式。

### Setting up a Multimesh item from a scene  
从场景设置多网格体项目

It is possible to setup a Multimesh Item from an existing scene, as an alternative to setting it up in the inspector. The scene will be converted to fit multimesh rendering. One reason you could need this is to setup colliders, because although they are supported, it is not possible to set them in the inspector at the moment. It is also more convenient to design instances in the 3D editor using nodes.  
可以从现有场景设置多网格体项目，作为在检查器中设置它的替代方法。场景将被转换以适合多网格渲染。您可能需要此功能的一个原因是设置碰撞体，因为尽管它们受支持，但目前无法在检查器中设置它们。使用节点在 3D 编辑器中设计实例也更方便。

There are two ways of setting up from a scene:  
有两种方法可以从场景进行设置：

-   Assign the `scene` property. This will convert the scene at runtime. The scene will be linked to the item, so it will stay updated if the scene changes.  
    分配 `scene` 属性。这将在运行时转换场景。场景将链接到项目，因此如果场景发生变化，它将保持更新。
-   Use the `Setup from scene` button on top of the inspector. This does not link the scene, and rather assigns manual properties doing the conversion in the editor. The item will not update if the scene change. If the scene embeds meshes, materials or textures, they might end up being copied into the item's resource file.  
    使用检查器顶部的 `Setup from scene` 按钮。这不会链接场景，而是分配在编辑器中执行转换的手动属性。如果场景发生变化，该项目将不会更新。如果场景嵌入了网格、材质或纹理，它们最终可能会被复制到项目的资源文件中。

The conversion process expects your scene to follow a specific structure:  
转换过程希望场景遵循特定结构：

```
- PhysicsBody (StaticBody, RigidBody...)
    - MeshInstance_LOD0 <-- "LOD" suffixes are optional but allow to specify the 4 LODs if needed
    - MeshInstance_LOD1
    - MeshInstance_LOD2
    - MeshInstance_LOD3
    - CollisionShape1
    - CollisionShape2
    - ...

```

Materials can be setup in two ways:  
可以通过两种方式设置材料：

-   `material_override` on the MeshInstance  
    `material_override` 在网格实例上
-   Materials on the mesh resource directly  
    直接在网格资源上添加材料

Surface material properties on the `MeshInstance` node are not supported.  
不支持 `MeshInstance` 节点上的曲面材料属性。

### Scene instances 场景实例

Multimesh items are fast and efficient, but have limitations.  
多网格项目快速高效，但有局限性。

Instancing scenes is supported by adding items of type `VoxelInstanceLibrarySceneItem`. Instead of spawning multimeshes, regular scene instances will be created as child of `VoxelInstancer`. The advantage is the ability to put much more varied behavior on them, such as scripts, sounds, animations, or even further spawning logic or interaction. The only constraint is, the root of the scene must be `Node3D` or derive from it.  
通过添加类型 `VoxelInstanceLibrarySceneItem` 为的项目来支持实例化场景。常规场景实例将创建为 的 `VoxelInstancer` 子级，而不是生成多网格体。优点是能够对它们施加更多样化的行为，例如脚本、声音、动画，甚至进一步生成逻辑或交互。唯一的约束是，场景的根必须是 `Node3D` 或派生自它。

This freedom has a high price compared to multimesh instances. Adding many instances can become slow quickly, so the default density of these items is lower when you create them from the editor. It is strongly recommended to not use too complex scenes, because depending on the settings, it can lead to a freeze or crash of Godot if your computer cannot handle too many instances.  
与多网格实例相比，这种自由度的代价很高。添加许多实例可能会很快变慢，因此从编辑器创建这些项目时，这些项目的默认密度较低。强烈建议不要使用太复杂的场景，因为根据设置，如果您的计算机无法处理太多实例，可能会导致Godot冻结或崩溃。

Warning 警告

If you add a scene to the library and then try to load that library from that same scene, Godot will crash. This is a cyclic reference and is hard to detect in all cases at the moment.  
如果将场景添加到库中，然后尝试从同一场景加载该库，Godot 将崩溃。这是一个循环引用，目前很难在所有情况下检测到。

## Procedural generation 程序生成

### Built-in generator 内置生成器

![Screenshot of a layer of instances using noise](https://voxel-tools.readthedocs.io/en/latest/images/instances_procgen.webp)

Items are added with a default built-in generator, so they will already spawn based on procedural rules rather than being painted manually. You can tweak the generator by inspecting the `generator` property of [VoxelInstanceLibraryItem](https://voxel-tools.readthedocs.io/en/latest/api/VoxelInstanceLibraryItem/).  
项目是使用默认的内置生成器添加的，因此它们已经根据程序规则生成，而不是手动绘制。您可以通过检查 `generator` VoxelInstanceLibraryItem 的属性来调整生成器。

Persistent instances located in a block that was edited in the game will no longer regenerate.  
位于游戏中编辑的块中的持久实例将不再重新生成。

### Custom instance generator  
自定义实例生成器

The feature is recent and the API may still change, so this is not available to scripts at the moment.  
该功能是最新的，API 可能仍会更改，因此目前脚本无法使用此功能。

## Streaming events (advanced)  
流事件（高级）

`VoxelInstancer` knows when to spawn things by registering itself to its parent's block events. This is currently not available to the script API of `VoxelLodTerrain`, but may be added in the future.  
`VoxelInstancer` 知道何时通过向父级的块事件注册来生成事物。这目前不适用于 的 `VoxelLodTerrain` 脚本 API，但将来可能会添加。
